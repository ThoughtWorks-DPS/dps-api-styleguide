{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"API Style Guide Standards (DRAFT) This is a draft REST API style guide created by the Digital Platform Strategy group that will enable development teams building APIs to provide a consistent experience for API consumers. This document provides a comprehensive set of guidelines which fully specify how to document, build and interact with a REST API. By following this guide, the APIs should be: Easy to understand and learn General and abstracted from specific implementation and use cases Robust and easy to use Have common look and feel Follow a consistent RESTful style and syntax Consistent with other teams\u2019 REST APIs and the Organization\u2019s global architecture Note: For the remainder of the document, unless specifically noted, when we mention \u201cAPI\u201d we mean \u201cREST API.\u201d Intended Audience This document is for architects and developers responsible for building APIs and provides base-level guidance on RESTful API and style for the contracts. If there are any questions around design standards, please refer back to this guide. Existing APIs By adhering to the API standards outlined in this document, APIs across the Organization should provide a consistent experience for consumers. However, it is expected that pre-existing APIs and clients might not receive the same experience due to outdated API standards. Given that these guidelines are expected to evolve, the following rules apply: Existing APIs don\u2019t have to be changed, but change is recommended If an existing API is publicly available externally, it is required to provide an API which adheres to current guidelines. New clients of existing APIs based on outdated rules (inconsistent experience) should trigger the creation of an updated API conformant with the API Styleguide This could be a fa\u00e7ade API which proxies requests to the existing API. Normal Evolutionary Architecture principles may be applied to migrate clients to the new (conformant) API. New APIs are required to adhere to current guidelines. Note: APIs conforming to specific industry standards (e.g. FHIR) are expected to follow the above rules unless in direct conflict with the specific standard. Types of APIs In general, APIs generally fall into one of two categories: Domain APIs (aka Process APIs) \u2013 core services that expose data and capabilities Experience APIs (aka Backend for Frontends or BFFs) \u2013 specific APIs for channels (mobile, web, customer gateways, etc.) This style guide focuses only on Domain APIs (1). Experience APIs (2) are often presentation focused and optimized for different use cases such as flexibility in data retrieval or mobile device battery performance. This style guide does not distinguish between internal and external APIs primarily because all Domain APIs should be built with a view towards being externalizable. That is, always build internal APIs as if they were external APIs. Domain APIs within the Organization should follow the RESTful architectural style. To support this objective, this guide outlines a set of rules, standards, and conventions to follow that apply to RESTful API design.","title":"Home"},{"location":"#api-style-guide-standards-draft","text":"This is a draft REST API style guide created by the Digital Platform Strategy group that will enable development teams building APIs to provide a consistent experience for API consumers. This document provides a comprehensive set of guidelines which fully specify how to document, build and interact with a REST API. By following this guide, the APIs should be: Easy to understand and learn General and abstracted from specific implementation and use cases Robust and easy to use Have common look and feel Follow a consistent RESTful style and syntax Consistent with other teams\u2019 REST APIs and the Organization\u2019s global architecture Note: For the remainder of the document, unless specifically noted, when we mention \u201cAPI\u201d we mean \u201cREST API.\u201d","title":"API Style Guide Standards (DRAFT)"},{"location":"#intended-audience","text":"This document is for architects and developers responsible for building APIs and provides base-level guidance on RESTful API and style for the contracts. If there are any questions around design standards, please refer back to this guide.","title":"Intended Audience"},{"location":"#existing-apis","text":"By adhering to the API standards outlined in this document, APIs across the Organization should provide a consistent experience for consumers. However, it is expected that pre-existing APIs and clients might not receive the same experience due to outdated API standards. Given that these guidelines are expected to evolve, the following rules apply: Existing APIs don\u2019t have to be changed, but change is recommended If an existing API is publicly available externally, it is required to provide an API which adheres to current guidelines. New clients of existing APIs based on outdated rules (inconsistent experience) should trigger the creation of an updated API conformant with the API Styleguide This could be a fa\u00e7ade API which proxies requests to the existing API. Normal Evolutionary Architecture principles may be applied to migrate clients to the new (conformant) API. New APIs are required to adhere to current guidelines. Note: APIs conforming to specific industry standards (e.g. FHIR) are expected to follow the above rules unless in direct conflict with the specific standard.","title":"Existing APIs"},{"location":"#types-of-apis","text":"In general, APIs generally fall into one of two categories: Domain APIs (aka Process APIs) \u2013 core services that expose data and capabilities Experience APIs (aka Backend for Frontends or BFFs) \u2013 specific APIs for channels (mobile, web, customer gateways, etc.) This style guide focuses only on Domain APIs (1). Experience APIs (2) are often presentation focused and optimized for different use cases such as flexibility in data retrieval or mobile device battery performance. This style guide does not distinguish between internal and external APIs primarily because all Domain APIs should be built with a view towards being externalizable. That is, always build internal APIs as if they were external APIs. Domain APIs within the Organization should follow the RESTful architectural style. To support this objective, this guide outlines a set of rules, standards, and conventions to follow that apply to RESTful API design.","title":"Types of APIs"},{"location":"unified/api-principles/","text":"API Design Principles Consistency Promote usage by consistent language wherever possible. Consider using names provided by schemas in schema.org . They\u2019ve thought through conceptual pitfalls you may not have (e.g. firstName becomes inaccurate outside of Western culture; givenName is better). Use standard names for common operations like sorting, filtering, searching, paging, and projecting. Use ISO formats for dates, currencies, country codes, and standard representations for types like Money. Note: referring to schema.org for naming guidance does not imply following schema.org naming conventions (e.g. camelCase vs snake_case) which are defined elsewhere in this document Usability Build design affordances into your API. Aspire to make it so developers \u201cdon\u2019t have to think\u201d by making the API as easy as possible to consume, even if that makes the implementation harder. Always send JSON keys back for null values rather than stripping the key out of the payload (avoids existence checks by clients). Always send a response body on create and delete operations so that the developers can see the full resource representation after creation and after deletion. Use a standard error convention, and be as specific as possible when reporting the error. Define the HTTP Response Codes used and the purpose/meaning behind each one. Don\u2019t mutate the meaning of standard error codes. Don\u2019t return 200-with-an-error-payload. Evolution APIs should be built with an eye towards future evolution, without forced upgrades of clients. Avoid returning top-level raw arrays, which don't allow non-breaking evolution to add metadata (like paging). Implement pagination for all result-sets that may grow without bound (i.e. search results). Turn off all strict deserialization. Adding fields is a non-breaking change (Postel\u2019s Law - be liberal in what you accept, and conservative in what you produce). It\u2019s better for the contract to be incomplete than inaccurate. Encapsulation Use the API to hide dependency complexity. All ids are global, even if the System(s) of Record are federated. The client should not have to care about the origin of the id. Treat ids as opaque. There should be no intrinsic meaning in the value of the id. Avoid leaky abstractions by mapping System of Record field names and values to meaningful values. Externalization Build the API with the expectation that it will be consumed externally. API must be derived from the domain model and the intended use-cases it is meant to support. API contract must meet the need of the customer. Externalization of the contract must not require reimplementation, or a change in service contract.","title":"API Design Principles"},{"location":"unified/api-principles/#api-design-principles","text":"","title":"API Design Principles"},{"location":"unified/api-principles/#consistency","text":"Promote usage by consistent language wherever possible. Consider using names provided by schemas in schema.org . They\u2019ve thought through conceptual pitfalls you may not have (e.g. firstName becomes inaccurate outside of Western culture; givenName is better). Use standard names for common operations like sorting, filtering, searching, paging, and projecting. Use ISO formats for dates, currencies, country codes, and standard representations for types like Money. Note: referring to schema.org for naming guidance does not imply following schema.org naming conventions (e.g. camelCase vs snake_case) which are defined elsewhere in this document","title":"Consistency"},{"location":"unified/api-principles/#usability","text":"Build design affordances into your API. Aspire to make it so developers \u201cdon\u2019t have to think\u201d by making the API as easy as possible to consume, even if that makes the implementation harder. Always send JSON keys back for null values rather than stripping the key out of the payload (avoids existence checks by clients). Always send a response body on create and delete operations so that the developers can see the full resource representation after creation and after deletion. Use a standard error convention, and be as specific as possible when reporting the error. Define the HTTP Response Codes used and the purpose/meaning behind each one. Don\u2019t mutate the meaning of standard error codes. Don\u2019t return 200-with-an-error-payload.","title":"Usability"},{"location":"unified/api-principles/#evolution","text":"APIs should be built with an eye towards future evolution, without forced upgrades of clients. Avoid returning top-level raw arrays, which don't allow non-breaking evolution to add metadata (like paging). Implement pagination for all result-sets that may grow without bound (i.e. search results). Turn off all strict deserialization. Adding fields is a non-breaking change (Postel\u2019s Law - be liberal in what you accept, and conservative in what you produce). It\u2019s better for the contract to be incomplete than inaccurate.","title":"Evolution"},{"location":"unified/api-principles/#encapsulation","text":"Use the API to hide dependency complexity. All ids are global, even if the System(s) of Record are federated. The client should not have to care about the origin of the id. Treat ids as opaque. There should be no intrinsic meaning in the value of the id. Avoid leaky abstractions by mapping System of Record field names and values to meaningful values.","title":"Encapsulation"},{"location":"unified/api-principles/#externalization","text":"Build the API with the expectation that it will be consumed externally. API must be derived from the domain model and the intended use-cases it is meant to support. API contract must meet the need of the customer. Externalization of the contract must not require reimplementation, or a change in service contract.","title":"Externalization"},{"location":"unified/appendix/","text":"Appendices Other Patterns Designers of new services SHOULD refer to the RESTful Web Services Cookbook at Safari Books Online for other useful patterns. References Architectural Styles and the Design of Network-based Software Architectures, Roy Fielding Postel\u2019s law Wikipedia Definition of \u201cDomain model\u201d How JavaScript Works, Introducing Json, Douglas Crockford The JavaScript Object Notation (JSON) Data Interchange Format JSON Schema Specification Standard Schema Definitions OpenAPI Specification OpenAPI MindMap Semantic Versioning 2.0 JEP Enhanced Deprecation How and When to Deprecate APIs PayPal API Standards Zalando RESTful API Guidelines Haufe API Style guide RESTful Web Services Cookbook","title":"Appendix"},{"location":"unified/appendix/#appendices","text":"","title":"Appendices"},{"location":"unified/appendix/#other-patterns","text":"Designers of new services SHOULD refer to the RESTful Web Services Cookbook at Safari Books Online for other useful patterns.","title":"Other Patterns"},{"location":"unified/appendix/#references","text":"Architectural Styles and the Design of Network-based Software Architectures, Roy Fielding Postel\u2019s law Wikipedia Definition of \u201cDomain model\u201d How JavaScript Works, Introducing Json, Douglas Crockford The JavaScript Object Notation (JSON) Data Interchange Format JSON Schema Specification Standard Schema Definitions OpenAPI Specification OpenAPI MindMap Semantic Versioning 2.0 JEP Enhanced Deprecation How and When to Deprecate APIs PayPal API Standards Zalando RESTful API Guidelines Haufe API Style guide RESTful Web Services Cookbook","title":"References"},{"location":"unified/bulk/","text":"Bulk Operations This section describes guidelines for handling bulk calls in APIs. Methodology There are two different methods that one could use for bulk processing. Homogeneous: Operation involves request and response payload representing collection of resources of the same type. Same operation is applied on all items in the collection. Heterogeneous: Operation involves a request and response payload that contains one or more requests and response payloads respectively. Each nested request and response represents an operation on a specific type of resource. However, the container request and response have one or more operations operating on one or more types of resources. It is RECOMMENDED to use a public domain standard such as OData Batch Specification in such cases. This section only addresses bulk processing of payloads using the homogenous method. Request Format Each bulk request is a single HTTP request to one target API endpoint. This example illustrates a bulk add operation. Example Request: POST /v1/devices/cards HTTP/1.1 Host: api.foo.com Content-Length: total_content_length { ... \"items\": [ { \"account_number\": \"2097094104180012037\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false }, { \"account_number\": \"2097094104180012047\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false }, { \"account_number\": \"2097094104180012023\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false } ] } Response Format The response usually contains the status of each item. Failure of an individual item is described using Error Handling Guidelines for an individual item. Given below is such an example. Example Response: HTTP/1.1 200 OK { ... \"batch_result\":[ { \u2026 <Success_body> }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"#/credit_card/expire_month\", \"issue\": \"Required field is missing\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\":\"#/credit_card/currency\", \"value\":\"XYZ\", \"issue\":\"Currency code is invalid\", \"location\":\"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] } If the API supports atomic semantics to processing requests, there would be a single response code for the entire request with one or more errors as applicable. Example Response: HTTP/1.1 400 Bad Request { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"#/credit_card/currency\", \"value\": \"XYZ\", \"issue\": \"Currency code is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } Replace And Update Similar to bulk add, a service can support bulk update operation (replace using HTTP PUT or partial update using PATCH). This is possible provided the bulk add request also creates a first-class resource (e.g. a batch resource) that is uniquely identifiable using an id and returned to the client. The subsequent update operations could then use this id and perform updates on constituent elements of the batch as if an update is performed on a single resource. For bulk replace and update operations, every effort should be made to make the execution atomic (all or nothing semantics). When it is not possible to make it so, the response should be similar to the partial response of bulk add operation described in the previous section. HTTP Status Codes And Error Handling The following guidelines describe HTTP status code and error handling for bulk operations. If atomicity is supported (all or nothing), use the regular REST API standards for error handling as there would be only one response code. To support partial failures, you MUST return 200 OK as the overall bulk processing status with individual status of each bulk item. In case of an error while processing a bulk item, the error description MUST follow the Error Handling Guidelines. If asynchronous processing is supported, the API MUST return 202 Accepted with a status URI for the client to monitor the request. The client may choose to ignore the status URI if it has registered itself with the API server for notification via webhooks. Response-Request Correlation in Error Scenarios For a failed item, you MAY use the JSON Pointer Expressions in the error response for that item using the field attribute of error.json . The caller can then map a response item's processing state to the exact request item in the original bulk request. Given below is an error response sample using the JSON Pointer Expressions. Error Response Sample: HTTP/1.1 200 OK { ... \"batch_result\": [ { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/@account_number=='2097094104180012047'/address_id\", \"issue\": \"Invalid Address Id for the account\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/@account_number=='2097094104180012023'/phone_id\", \"value\": \"XYZ\", \"issue\": \"Phone Id is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] } The alternative is to create a response that contains the processing status of each item in the same order as it was received in the original request. The failed item would be represented using error.json with appropriate value in the field attribute. Error Response Sample: HTTP/1.1 200 OK { ... \"batch_result\": [ { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/0/address_id\", \"issue\": \"Invalid Address Id for the account\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/2/phone_id\", \"value\": \"XYZ\", \"issue\": \"Phone Id is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] }","title":"Bulk Operations"},{"location":"unified/bulk/#bulk-operations","text":"This section describes guidelines for handling bulk calls in APIs.","title":"Bulk Operations"},{"location":"unified/bulk/#methodology","text":"There are two different methods that one could use for bulk processing. Homogeneous: Operation involves request and response payload representing collection of resources of the same type. Same operation is applied on all items in the collection. Heterogeneous: Operation involves a request and response payload that contains one or more requests and response payloads respectively. Each nested request and response represents an operation on a specific type of resource. However, the container request and response have one or more operations operating on one or more types of resources. It is RECOMMENDED to use a public domain standard such as OData Batch Specification in such cases. This section only addresses bulk processing of payloads using the homogenous method.","title":"Methodology"},{"location":"unified/bulk/#request-format","text":"Each bulk request is a single HTTP request to one target API endpoint. This example illustrates a bulk add operation.","title":"Request Format"},{"location":"unified/bulk/#example-request","text":"POST /v1/devices/cards HTTP/1.1 Host: api.foo.com Content-Length: total_content_length { ... \"items\": [ { \"account_number\": \"2097094104180012037\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false }, { \"account_number\": \"2097094104180012047\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false }, { \"account_number\": \"2097094104180012023\", \"address_id\": \"466354\", \"phone_id\": \"0\", \"first_name\": \"M\", \"last_name\": \"Shriver\", \"primary_card_holder\": false } ] }","title":"Example Request:"},{"location":"unified/bulk/#response-format","text":"The response usually contains the status of each item. Failure of an individual item is described using Error Handling Guidelines for an individual item. Given below is such an example.","title":"Response Format"},{"location":"unified/bulk/#example-response","text":"HTTP/1.1 200 OK { ... \"batch_result\":[ { \u2026 <Success_body> }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"#/credit_card/expire_month\", \"issue\": \"Required field is missing\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\":\"#/credit_card/currency\", \"value\":\"XYZ\", \"issue\":\"Currency code is invalid\", \"location\":\"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] } If the API supports atomic semantics to processing requests, there would be a single response code for the entire request with one or more errors as applicable.","title":"Example Response:"},{"location":"unified/bulk/#example-response_1","text":"HTTP/1.1 400 Bad Request { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"#/credit_card/currency\", \"value\": \"XYZ\", \"issue\": \"Currency code is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\", \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }","title":"Example Response:"},{"location":"unified/bulk/#replace-and-update","text":"Similar to bulk add, a service can support bulk update operation (replace using HTTP PUT or partial update using PATCH). This is possible provided the bulk add request also creates a first-class resource (e.g. a batch resource) that is uniquely identifiable using an id and returned to the client. The subsequent update operations could then use this id and perform updates on constituent elements of the batch as if an update is performed on a single resource. For bulk replace and update operations, every effort should be made to make the execution atomic (all or nothing semantics). When it is not possible to make it so, the response should be similar to the partial response of bulk add operation described in the previous section.","title":"Replace And Update"},{"location":"unified/bulk/#http-status-codes-and-error-handling","text":"The following guidelines describe HTTP status code and error handling for bulk operations. If atomicity is supported (all or nothing), use the regular REST API standards for error handling as there would be only one response code. To support partial failures, you MUST return 200 OK as the overall bulk processing status with individual status of each bulk item. In case of an error while processing a bulk item, the error description MUST follow the Error Handling Guidelines. If asynchronous processing is supported, the API MUST return 202 Accepted with a status URI for the client to monitor the request. The client may choose to ignore the status URI if it has registered itself with the API server for notification via webhooks.","title":"HTTP Status Codes And Error Handling"},{"location":"unified/bulk/#response-request-correlation-in-error-scenarios","text":"For a failed item, you MAY use the JSON Pointer Expressions in the error response for that item using the field attribute of error.json . The caller can then map a response item's processing state to the exact request item in the original bulk request. Given below is an error response sample using the JSON Pointer Expressions.","title":"Response-Request Correlation in Error Scenarios"},{"location":"unified/bulk/#error-response-sample","text":"HTTP/1.1 200 OK { ... \"batch_result\": [ { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/@account_number=='2097094104180012047'/address_id\", \"issue\": \"Invalid Address Id for the account\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/@account_number=='2097094104180012023'/phone_id\", \"value\": \"XYZ\", \"issue\": \"Phone Id is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] } The alternative is to create a response that contains the processing status of each item in the same order as it was received in the original request. The failed item would be represented using error.json with appropriate value in the field attribute.","title":"Error Response Sample:"},{"location":"unified/bulk/#error-response-sample_1","text":"HTTP/1.1 200 OK { ... \"batch_result\": [ { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/0/address_id\", \"issue\": \"Invalid Address Id for the account\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" }, { \"name\": \"VALIDATION_ERROR\", \"details\": [ { \"field\": \"/items/2/phone_id\", \"value\": \"XYZ\", \"issue\": \"Phone Id is invalid\", \"location\": \"body\" } ], \"debug_id\": \"123456789\", \"message\": \"Invalid data provided\" \"information_link\": \"http://developer.foo.com/apidoc/blah#VALIDATION_ERROR\" } ] }","title":"Error Response Sample:"},{"location":"unified/controller-resources/","text":"Controller Resources Controller (aka Procedural) resources challenge the fundamental notion or concept of resource orientation where resources usually represent mapping to a conceptual set of entities or things in a domain system. However, often API developers come across a situation where they are unable to model a service executing (part of) a business process as a pure RESTful service. Some examples of use cases for controller resources are: When it is required to execute a processing function on the server from a set of inputs (client provided input or based on data from the server's information store or from an external information store). When it is required to combine one or more operations and execute them in an atomic fashion (aka a composite controller operation). When you want to hide a multi-step business process operation from a client to avoid unnecessary coupling between a client and server. Risks Design scalability When overused, the number of URIs can grow very quickly, as all permutations of root-level action can increase rapidly over time. This can also produce configuration complexity for routing/externalization. The URI cannot be extended past the action, which precludes any possibility of sub-resources. Testability: highly compromised in comparison to Collection Resource oriented designs (due the lack of corresponding GET/read operations). History: the ability to retrieve history for the given actions is forced to live in another resource (e.g. /action-resource-history ), or not at all. Benefits Avoids corrupting collection resource model with transient data (e.g. comments on state changes etc). Usability improvement: there are cases where a complex operation simplifies client interaction, where the client does not benefit from resource retrieval. For further reading on controller concepts, please refer to section 2.6 of the RESTful Web Services Cookbook . Below are the set of guidelines for modelling controller resources. Naming Of A Controller Resource Because a controller operation represents an action or a processing function in the server, it is more intuitive to express it using an English verb, i.e. the action itself as the resource name. Verbs such as 'activate', 'cancel', 'validate', 'accept', and 'deny' are usual suspects. There are many style options from which you can choose to define a controller resource. If the controller action is not associated with any resource context, you can express it as an independent resource at the namespace level ( /v1/credit/assess-eligibility ). This is typically only applicable for creating a variety of resources in an optimized operation. However, this is usually an anti-pattern. If the controller action is always in the context of a parent resource, then it should be expressed as a sub-resource (using a /) of the parent resource (e.g. v1/identity/external-profiles/{id}/confirm ). When an action is in the context of a collection resource, express it as an independent resource at the namespace level. The controller resource name in such cases SHOULD be composed of the action (an English verb) that the controller represent and the name of the collection resource. For example, if you want to express a search operation for deposits, the controller resource SHOULD read as v1/customer/search-deposits . NOTE: A controller action is a terminal resource. A sub-resource for a controller resource is thus invalid. For this reason, you SHOULD NOT define a sub-resource to a controller resource. It is also important to scope a controller to the minimum possible level of nesting in order to avoid resource pollution as such resources are use-case or action centric. HTTP Methods For Controller Resources In general, for most cases the HTTP POST method SHOULD be used as the default method for executing a controller operation. In scenarios where it is desired that the response of a controller operation be cache-able, GET SHOULD be used to execute the controller. For example, you can use a GET operation ( GET /calculate-shortest-path?from=x &to=y ) to calculate the shortest path between two nodes (origin and destination). The result of the GET operation is a collection of routes and their maps, and ideally you would like to cache the map for future use ( GET /retrieve ). HTTP Status Codes For Controller Resources In general, the following response codes can be used for a controller operation. 200 OK This is the default status code for any controller operation. The response MUST contain a body that describes the result of a controller operation. 201 Created Use 201 Created if the controller operation leads to creation of a resource. If a composite controller is used to create one or more resources and it is not possible to expresss them as a composite record, you MAY instead use 200 OK as response code. 204 No Content Use 204 No Content if the server declines to return anything as part of a controller action. Most of the out-of-band actions fall in this category. (e.g. v1/users/{id}/notify ). For errors, appropriate 4XX or 5XX error codes MAY be returned. Following sections provide some examples for modeling controller resources to carry out various kinds of complex operations. Complex Operation - Sub-Resource NOTE: Use with caution For associated risks, see Controller Resource above. There are often situations in which a canonical resource needs to impart certain actions or state changes which are not appropriate in a PUT or PATCH. These URIs look like other Sub-Resources , but imply action. A good use for this pattern is when a particular state change requires a \"comment\" (e.g. cancellation \"reason\"). Adding this comment, or other data such as location, would make the GET/PUT unnecessarily include those extra fields on every request/response. This action may change the status of the given resource implicitly. Additionally, when a resource identifier is required for an action, it's best to keep it in the URL. Some actions are business processes which are not innately a resource (and in some cases might not even change resource state). The response is typically 200 OK and the resource itself, if there are changes expected in the resource the consumer needs to capture. However, if no resource state change occurs, 204 No Content and no response body could also be considered appropriate. URI Template POST /{version}/{namespace}/{resource}/{resource-id}/{complex-operation} Example Request: POST /v1/payments/billing-agreements/I-0LN988D3JACS/suspend { \"note\": \"Suspending the agreement.\" } Example Response: 204 No Content However, when state changes are imparted in this manner, it does not mean that all state changes for the given resource should use a complex operation. Simple state transitions (i.e. changes to a status field) should still utilize PUT/PATCH. It is completely appropriate to mix patterns using PUT/PATCH on a Collection Resource + Complex Operation, in order to minimize the number of operations. Example Request (for mixed use of PUT): PATCH /v1/payments/billing-agreements/I-0LN988D3JACS [ { \"op\": \"replace\", \"path\": \"/\", \"value\": { \"description\": \"New Description\", \"shipping_address\": { \"line1\": \"2065 Hamilton Ave\", \"city\": \"San Jose\", \"state\": \"CA\", \"postal_code\": \"95125\", \"country_code\": \"US\" } } } ] Keep in mind that if there is any need to see the history of these actions, a Sub-resource Collection is appropriate to show all of the prior executions of this action. In that case, the verb should be reified . Complex Operation - Composite This type of complex operation creates/updates/deletes multiple resources in one operation. This serves as both a performance and usability optimization, as well as adding better atomicity when values in the request might affect multiple resources at the same time. Note in the sample below, the capture and the payment are both potentially affected by refund. A PUT or PATCH operation on the capture resource would have unintended side effects on the payment resource. To encapsulate both of these changes, the 'refund' action is used. URI Template POST /{version}/{namespace}/{action} Example Request: POST /v1/payments/captures/{capture-id}/refund Example Response: { \"id\": \"REF-0P209507D6694645N\", \"create_time\": \"2013-05-06T22:11:51Z\", \"update_time\": \"2013-05-06T22:11:51Z\", \"state\": \"completed\", \"amount\": { \"total\": \"110.54\", \"currency\": \"USD\" }, \"capture_id\": \"8F148933LY9388354\", \"parent_payment\": \"PAY-8PT597110X687430LKGECATA\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/refund/REF-0P209507D6694645N\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/payments/payment/PAY-8PT597110X687430LKGECATA\", \"rel\": \"parent_payment\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/payments/capture/8F148933LY9388354\", \"rel\": \"capture\", \"method\": \"GET\" } ] } Complex Operation - Transient This type of complex operation does not maintain state for the client, and creates no resources. This is about as RPC as it gets; other alternatives should be considered first. This is not usually utilized in sub-resources, as a sub-resource action would typically affect the parent resource. HTTP status 200 OK is always appropriate. Response body contains calculated values, which could potentially change if run again. As with all actions, resource-oriented alternatives should be considered first. URI Template POST /{version}/{namespace}/{action} Example Request: POST /v1/risk/evaluate-payment { \"code\": \"h43j5k6iop\" } Example Response 200 OK { \"status\": \"VALID\" } Complex Operation - Search When Collection Resources are used, it is best to use query parameters on the collection to filter the set. However, there are some situations that demand a very complex search syntax, where query parameter filtering on a collection might present usability problems, security / privacy issues, or run up against theoretical query parameter length limitations. In these situations, POST can be utilized with a request object to specify the search parameters. Pagination Assuming pagination will be required with large response quantities, it is important to remember that the consumer will need to use POST on each subsequent page. As such, it's important to maintain paging in the query parameters (one of the rare exceptions where POST body + query parameters are utilized). Paging query parameters should follow the same conventions as in Collection Resources. This allows for hypermedia links to provide next, previous, first, last page relationships with paging specified in the URL. URI Template POST /{version}/{namespace}/{search-resource} Example Request: POST /v1/factory/widgets-search { \"created_before\":\"1975-05-13\", \"status\": \"ACTIVE\", \"vendor\": \"Parts Inc.\" } Example Response: 200 OK { \"items\": [ <<lots of part objects here>> ], \"links\": [ { \"href\": \"https://api.sandbox.factory.io/v1/factory/widgets-search?page=2&page_size=10\", \"rel\": \"next\", \"method\": \"POST\" }, { \"href\": \"https://api.sandbox.factory.io/v1/factory/widgets-search?page=124&page_size=10\", \"rel\": \"last\", \"method\": \"POST\" }, ] } Resource-Oriented Alternative A better pattern is to create a Collection Resource of actions and provide a history of those actions taken in GET /{actions} . This allows for future expansion of use cases around a resource model, instead of a single action-oriented, RPC-style URL. Additionally, for various use cases, filtering the resource collection of historical actions is usually desirable. This also feeds well into event sourcing concepts, where the history of a given event can drive further functionality. File Upload Certains types of API operations require uploading a file (e.g. jpeg, png, pdf) as part of the API call. Services for such use cases, MUST NOT support or allow encoding the file content within a JSON body using Base64 encoding. For uploading a file, one of the following options SHOULD be used. Standalone Operation Services supporting such an operation SHOULD provide a separate dedicated URI for uploading and retrieving the files. Clients of such services upload the files using the file upload URI and retrieve the file metadata as part of the response to an upload operation. Format of the file upload request SHOULD conform to multipart/form-data content type ( RFC 2388 ). Example of a multipart/form-data request: The client first uploads the file using a file-upload URI provided by the service. POST /v1/identity/limit-resolution-files Content-Type: multipart/form-data; boundary=--foo_bar_baz Authorization: Bearer YOUR_ACCESS_TOKEN_HERE MIME-Version: 1.0 --foo_bar_baz Content-Type: text/plain Content-Disposition: form-data; name=\"title\" Identity Document --foo_bar_baz Content-Type: image/jpeg Content-Disposition: form-data; name=\"artifact\"; filename=\"passport.jpg\" ...(binary bytes of the image)... --foo_bar_baz-- Sample file upload response: If the file upload is successful, the server responds with the metadata of the uploaded file. { \"id\": \"file_egflf465vbk7468mvnb\", \"created_at\": 748557607545, \"size\" : 3457689458369, \"url\" : \"https://api.foo.com/v1/files/file_egflf465vbk7468mvnb\", \"type\" : \"image/jpeg\" } The client can use the uploaded file's URI (received in the above response) for any subsequent operation that requires the uploaded file as shown below. Example Request: POST /v1/identity/limits-resolutions Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token { ... \"identity_document_reference\" : \"https://api.foo.com/v1/files/file_egflf465vbk7468mvnb\" } As Attachment This option SHOULD be used if you have to combine the uploading of a file with an API request body or parameters in one API request. For example, for the purpose of optimization or to process both the file upload and request data in an atomic manner. For such use cases, the request SHOULD either use content-type multipart/mixed or multipart/related ( RFC 2387 ). Following is an example of such a request. Example of a multipart/related request: The first part in the below multipart request is the request metadata, while the second part contains the binary file content POST /v1/identity/limits-resolutions Host: api.foo.com Content-Type: multipart/related; boundary=--foo_bar_baz Authorization: Bearer oauth2_token --foo_bar_baz Content-Type: application/json; charset=UTF-8 { ... } --foo_bar_baz Content-Type: image/jpeg [JPEG_DATA] --foo_bar_baz-- HATEOAS Use Cases This section describes various use cases where HATEOAS could be used. See the Hypermedia section for more detailed guidelines when implementing HATEOAS-style APIs. As a guiding principle, when adopting HATEOAS, every API SHOULD strive for a single entry point. Any response from this entry point will have HATEOAS links using which the client can navigate to all other methods on the same resource or related resources and sub-resources. Patterns Following are different patterns for defining such an API entry point. Pattern 1: API with a top level entry point For most APIs, there's a natural top level object or a collection which can be the resources addressed by the entry point. For example, the API defined in the previous section has a collection resource /users which can be the entry point URI. Pattern 2: Entry point for complex controller style operations A complex multi step operation always has a logical entry point. For example, you want to build an API for a credit application process that involves multiple steps- a create application step, consumer consent step (to sign, agree to terms and conditions), an approval step- the last step of a successful credit application. /apply-credit is the API's entry point. All other steps would be guided by the \"application create\" step in the from of links based on the captured data. For example a successful \"create application\" step would return the link to the next state of the application process apply-sign . An unsuccessful (application with incorrect data) MAY return only a link to send only the incorrect/missing data (e.g PATCH link). Pattern 3: API without a top level entry point Consider an API that provides a set of independent controller style utility methods. For example, you want to build an identity API that provides the following utility methods. generate OTP (one time password) encrypt payload using a particular algorithm decrypt the payload, link tokens For such cases, the API MAY provide a separate resource /actions to return links to all resources that can be served by this API. GET /actions in the above example would return links to other api methods ( /generate-otp , /encrypt , /decrypt , /link-tokens ). Navigating A Collection For collection resources, a service MAY automatically provide a paginated collection. The Client can also specify its pagination preferences, if the query resultset is quite large. In such cases, the resultset is returned as a paginated collection with appropriate pagination related links. The Client utilizes these links to navigate through the resultset back-and-forth. For more details on this linking pattern, please refer to Pagination and HATEOAS links. Error Resolution There are often use cases where an API wants to provide additional context in case of error along with other error details beyond simple HTTP status codes. (See Error Standards for more). An API could return additional resource links to provide more hints on the error in order to resolve it. Consider an example from the /users API where the user wants to update his address details. Request: PATCH /v1/users/ALT-JFWXHGUV7VI { \"address\": { ... } } The service, however, finds that the user account is currently not active. It responds with an error explaining that an update of this account is not possible given the current state. It also returns an HATEOAS link in the response to activate the user account. Response: HTTP/1.1 422 Unprocessable Entity { \"name\":\"INVALID_OPERATION\", \"debug_id\":\"123456789\", \"message\":\"An update to an inactive account is not supported.\", \"links\": [ { \"href\": \"https://api.foo.com/v1/customer/partner-referrals/ALT-JFWXHGUV7VI/activate\", \"rel\": \"activate\", \"method\": \"POST\" } ] } The client can now prompt the user to first activate his account and then change his address details. Service-controlled Flow In a complex business operation that has one or more sub-business operations and business rules govern the state transitions at run-time, using HATEOAS links to describe or emit the allowed state transitions prevents clients from embedding the service-specific business logic into their code. Loose coupling or no coupling with server's business logic enables better evolution for both client and server. For example, an order can be cancelled when it is in a PENDING state. The order cannot be cancelled once it moves to a COMPLETED state. Following example shows how a service can use HATEOAS links to guide clients about next possible step(s) in business process. Example: Pending Order Order is in PENDING state, so the service returns the cancel HATEOAS link. Request: GET v1/checkout/orders/52181732T9513405D HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Response: HTTP/1.1 200 OK Content-Type: application/json { \"payment_details\":{ ... }, \"status\":\"PENDING\", \"links\":[ { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A/cancel\", \"rel\": \"cancel\", \"method\": \"POST\" } ] } Example: Completed Order Order is in COMPLETED state so the services does not return the cancel link anymore. Request: GET v1/checkout/orders/52181732T9513405D HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Response: HTTP/1.1 200 OK Content-Type: application/json { \"payment_details\":{ ... }, \"status\":\"COMPLETED\", \"links\":[ { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A\", \"rel\": \"self\", \"method\": \"GET\" } ] } NOTE: The service MAY decide to support cancellation of orders (for orders with COMPLETED status) in some countries in future but that does not require the client to change anything in its code. All that a client knows or has coded when it first integrated with the service is the request body that is required to cancel an order. Asynchronous Operations When an operation is carried out asynchronously, it is important to provide relevant links to client so that the client can find out more details about the operation such as finding out status or perform get, update and delete operations. Please refer to Asynchronous Operations to find how the HATEOAS links could be used in response of an asynchronous operation. Saving Bandwidth Some services always return very large response because of the nature of the domain they address. APIs of such services are sometimes referred as Composite APIs (they accumulate data from various sources or an aggregate of more than one services). For such APIs, sending the entire response drastically impacts performance of the API consumer, API server and the underlying network. In such cases, the client can ask the service to return partial representation using Prefer: return=minimal HTTP header. A service could send response with relevant HATEOAS links with minimal data to improve the performance.","title":"Controller Resources"},{"location":"unified/controller-resources/#controller-resources","text":"Controller (aka Procedural) resources challenge the fundamental notion or concept of resource orientation where resources usually represent mapping to a conceptual set of entities or things in a domain system. However, often API developers come across a situation where they are unable to model a service executing (part of) a business process as a pure RESTful service. Some examples of use cases for controller resources are: When it is required to execute a processing function on the server from a set of inputs (client provided input or based on data from the server's information store or from an external information store). When it is required to combine one or more operations and execute them in an atomic fashion (aka a composite controller operation). When you want to hide a multi-step business process operation from a client to avoid unnecessary coupling between a client and server.","title":"Controller Resources"},{"location":"unified/controller-resources/#risks","text":"Design scalability When overused, the number of URIs can grow very quickly, as all permutations of root-level action can increase rapidly over time. This can also produce configuration complexity for routing/externalization. The URI cannot be extended past the action, which precludes any possibility of sub-resources. Testability: highly compromised in comparison to Collection Resource oriented designs (due the lack of corresponding GET/read operations). History: the ability to retrieve history for the given actions is forced to live in another resource (e.g. /action-resource-history ), or not at all.","title":"Risks"},{"location":"unified/controller-resources/#benefits","text":"Avoids corrupting collection resource model with transient data (e.g. comments on state changes etc). Usability improvement: there are cases where a complex operation simplifies client interaction, where the client does not benefit from resource retrieval. For further reading on controller concepts, please refer to section 2.6 of the RESTful Web Services Cookbook . Below are the set of guidelines for modelling controller resources.","title":"Benefits"},{"location":"unified/controller-resources/#naming-of-a-controller-resource","text":"Because a controller operation represents an action or a processing function in the server, it is more intuitive to express it using an English verb, i.e. the action itself as the resource name. Verbs such as 'activate', 'cancel', 'validate', 'accept', and 'deny' are usual suspects. There are many style options from which you can choose to define a controller resource. If the controller action is not associated with any resource context, you can express it as an independent resource at the namespace level ( /v1/credit/assess-eligibility ). This is typically only applicable for creating a variety of resources in an optimized operation. However, this is usually an anti-pattern. If the controller action is always in the context of a parent resource, then it should be expressed as a sub-resource (using a /) of the parent resource (e.g. v1/identity/external-profiles/{id}/confirm ). When an action is in the context of a collection resource, express it as an independent resource at the namespace level. The controller resource name in such cases SHOULD be composed of the action (an English verb) that the controller represent and the name of the collection resource. For example, if you want to express a search operation for deposits, the controller resource SHOULD read as v1/customer/search-deposits . NOTE: A controller action is a terminal resource. A sub-resource for a controller resource is thus invalid. For this reason, you SHOULD NOT define a sub-resource to a controller resource. It is also important to scope a controller to the minimum possible level of nesting in order to avoid resource pollution as such resources are use-case or action centric.","title":"Naming Of A Controller Resource"},{"location":"unified/controller-resources/#http-methods-for-controller-resources","text":"In general, for most cases the HTTP POST method SHOULD be used as the default method for executing a controller operation. In scenarios where it is desired that the response of a controller operation be cache-able, GET SHOULD be used to execute the controller. For example, you can use a GET operation ( GET /calculate-shortest-path?from=x &to=y ) to calculate the shortest path between two nodes (origin and destination). The result of the GET operation is a collection of routes and their maps, and ideally you would like to cache the map for future use ( GET /retrieve ).","title":"HTTP Methods For Controller Resources"},{"location":"unified/controller-resources/#http-status-codes-for-controller-resources","text":"In general, the following response codes can be used for a controller operation.","title":"HTTP Status Codes For Controller Resources"},{"location":"unified/controller-resources/#200-ok","text":"This is the default status code for any controller operation. The response MUST contain a body that describes the result of a controller operation.","title":"200 OK"},{"location":"unified/controller-resources/#201-created","text":"Use 201 Created if the controller operation leads to creation of a resource. If a composite controller is used to create one or more resources and it is not possible to expresss them as a composite record, you MAY instead use 200 OK as response code.","title":"201 Created"},{"location":"unified/controller-resources/#204-no-content","text":"Use 204 No Content if the server declines to return anything as part of a controller action. Most of the out-of-band actions fall in this category. (e.g. v1/users/{id}/notify ). For errors, appropriate 4XX or 5XX error codes MAY be returned. Following sections provide some examples for modeling controller resources to carry out various kinds of complex operations.","title":"204 No Content"},{"location":"unified/controller-resources/#complex-operation-sub-resource","text":"NOTE: Use with caution For associated risks, see Controller Resource above. There are often situations in which a canonical resource needs to impart certain actions or state changes which are not appropriate in a PUT or PATCH. These URIs look like other Sub-Resources , but imply action. A good use for this pattern is when a particular state change requires a \"comment\" (e.g. cancellation \"reason\"). Adding this comment, or other data such as location, would make the GET/PUT unnecessarily include those extra fields on every request/response. This action may change the status of the given resource implicitly. Additionally, when a resource identifier is required for an action, it's best to keep it in the URL. Some actions are business processes which are not innately a resource (and in some cases might not even change resource state). The response is typically 200 OK and the resource itself, if there are changes expected in the resource the consumer needs to capture. However, if no resource state change occurs, 204 No Content and no response body could also be considered appropriate.","title":"Complex Operation - Sub-Resource"},{"location":"unified/controller-resources/#uri-template","text":"POST /{version}/{namespace}/{resource}/{resource-id}/{complex-operation}","title":"URI Template"},{"location":"unified/controller-resources/#example-request","text":"POST /v1/payments/billing-agreements/I-0LN988D3JACS/suspend { \"note\": \"Suspending the agreement.\" }","title":"Example Request:"},{"location":"unified/controller-resources/#example-response","text":"204 No Content However, when state changes are imparted in this manner, it does not mean that all state changes for the given resource should use a complex operation. Simple state transitions (i.e. changes to a status field) should still utilize PUT/PATCH. It is completely appropriate to mix patterns using PUT/PATCH on a Collection Resource + Complex Operation, in order to minimize the number of operations.","title":"Example Response:"},{"location":"unified/controller-resources/#example-request-for-mixed-use-of-put","text":"PATCH /v1/payments/billing-agreements/I-0LN988D3JACS [ { \"op\": \"replace\", \"path\": \"/\", \"value\": { \"description\": \"New Description\", \"shipping_address\": { \"line1\": \"2065 Hamilton Ave\", \"city\": \"San Jose\", \"state\": \"CA\", \"postal_code\": \"95125\", \"country_code\": \"US\" } } } ] Keep in mind that if there is any need to see the history of these actions, a Sub-resource Collection is appropriate to show all of the prior executions of this action. In that case, the verb should be reified .","title":"Example Request (for mixed use of PUT):"},{"location":"unified/controller-resources/#complex-operation-composite","text":"This type of complex operation creates/updates/deletes multiple resources in one operation. This serves as both a performance and usability optimization, as well as adding better atomicity when values in the request might affect multiple resources at the same time. Note in the sample below, the capture and the payment are both potentially affected by refund. A PUT or PATCH operation on the capture resource would have unintended side effects on the payment resource. To encapsulate both of these changes, the 'refund' action is used.","title":"Complex Operation - Composite"},{"location":"unified/controller-resources/#uri-template_1","text":"POST /{version}/{namespace}/{action}","title":"URI Template"},{"location":"unified/controller-resources/#example-request_1","text":"POST /v1/payments/captures/{capture-id}/refund","title":"Example Request:"},{"location":"unified/controller-resources/#example-response_1","text":"{ \"id\": \"REF-0P209507D6694645N\", \"create_time\": \"2013-05-06T22:11:51Z\", \"update_time\": \"2013-05-06T22:11:51Z\", \"state\": \"completed\", \"amount\": { \"total\": \"110.54\", \"currency\": \"USD\" }, \"capture_id\": \"8F148933LY9388354\", \"parent_payment\": \"PAY-8PT597110X687430LKGECATA\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/refund/REF-0P209507D6694645N\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/payments/payment/PAY-8PT597110X687430LKGECATA\", \"rel\": \"parent_payment\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/payments/capture/8F148933LY9388354\", \"rel\": \"capture\", \"method\": \"GET\" } ] }","title":"Example Response:"},{"location":"unified/controller-resources/#complex-operation-transient","text":"This type of complex operation does not maintain state for the client, and creates no resources. This is about as RPC as it gets; other alternatives should be considered first. This is not usually utilized in sub-resources, as a sub-resource action would typically affect the parent resource. HTTP status 200 OK is always appropriate. Response body contains calculated values, which could potentially change if run again. As with all actions, resource-oriented alternatives should be considered first.","title":"Complex Operation - Transient"},{"location":"unified/controller-resources/#uri-template_2","text":"POST /{version}/{namespace}/{action}","title":"URI Template"},{"location":"unified/controller-resources/#example-request_2","text":"POST /v1/risk/evaluate-payment { \"code\": \"h43j5k6iop\" }","title":"Example Request:"},{"location":"unified/controller-resources/#example-response_2","text":"200 OK { \"status\": \"VALID\" }","title":"Example Response"},{"location":"unified/controller-resources/#complex-operation-search","text":"When Collection Resources are used, it is best to use query parameters on the collection to filter the set. However, there are some situations that demand a very complex search syntax, where query parameter filtering on a collection might present usability problems, security / privacy issues, or run up against theoretical query parameter length limitations. In these situations, POST can be utilized with a request object to specify the search parameters.","title":"Complex Operation - Search"},{"location":"unified/controller-resources/#pagination","text":"Assuming pagination will be required with large response quantities, it is important to remember that the consumer will need to use POST on each subsequent page. As such, it's important to maintain paging in the query parameters (one of the rare exceptions where POST body + query parameters are utilized). Paging query parameters should follow the same conventions as in Collection Resources. This allows for hypermedia links to provide next, previous, first, last page relationships with paging specified in the URL.","title":"Pagination"},{"location":"unified/controller-resources/#uri-template_3","text":"POST /{version}/{namespace}/{search-resource}","title":"URI Template"},{"location":"unified/controller-resources/#example-request_3","text":"POST /v1/factory/widgets-search { \"created_before\":\"1975-05-13\", \"status\": \"ACTIVE\", \"vendor\": \"Parts Inc.\" }","title":"Example Request:"},{"location":"unified/controller-resources/#example-response_3","text":"200 OK { \"items\": [ <<lots of part objects here>> ], \"links\": [ { \"href\": \"https://api.sandbox.factory.io/v1/factory/widgets-search?page=2&page_size=10\", \"rel\": \"next\", \"method\": \"POST\" }, { \"href\": \"https://api.sandbox.factory.io/v1/factory/widgets-search?page=124&page_size=10\", \"rel\": \"last\", \"method\": \"POST\" }, ] }","title":"Example Response:"},{"location":"unified/controller-resources/#resource-oriented-alternative","text":"A better pattern is to create a Collection Resource of actions and provide a history of those actions taken in GET /{actions} . This allows for future expansion of use cases around a resource model, instead of a single action-oriented, RPC-style URL. Additionally, for various use cases, filtering the resource collection of historical actions is usually desirable. This also feeds well into event sourcing concepts, where the history of a given event can drive further functionality.","title":"Resource-Oriented Alternative"},{"location":"unified/controller-resources/#file-upload","text":"Certains types of API operations require uploading a file (e.g. jpeg, png, pdf) as part of the API call. Services for such use cases, MUST NOT support or allow encoding the file content within a JSON body using Base64 encoding. For uploading a file, one of the following options SHOULD be used.","title":"File Upload"},{"location":"unified/controller-resources/#standalone-operation","text":"Services supporting such an operation SHOULD provide a separate dedicated URI for uploading and retrieving the files. Clients of such services upload the files using the file upload URI and retrieve the file metadata as part of the response to an upload operation. Format of the file upload request SHOULD conform to multipart/form-data content type ( RFC 2388 ). Example of a multipart/form-data request: The client first uploads the file using a file-upload URI provided by the service. POST /v1/identity/limit-resolution-files Content-Type: multipart/form-data; boundary=--foo_bar_baz Authorization: Bearer YOUR_ACCESS_TOKEN_HERE MIME-Version: 1.0 --foo_bar_baz Content-Type: text/plain Content-Disposition: form-data; name=\"title\" Identity Document --foo_bar_baz Content-Type: image/jpeg Content-Disposition: form-data; name=\"artifact\"; filename=\"passport.jpg\" ...(binary bytes of the image)... --foo_bar_baz--","title":"Standalone Operation"},{"location":"unified/controller-resources/#sample-file-upload-response","text":"If the file upload is successful, the server responds with the metadata of the uploaded file. { \"id\": \"file_egflf465vbk7468mvnb\", \"created_at\": 748557607545, \"size\" : 3457689458369, \"url\" : \"https://api.foo.com/v1/files/file_egflf465vbk7468mvnb\", \"type\" : \"image/jpeg\" } The client can use the uploaded file's URI (received in the above response) for any subsequent operation that requires the uploaded file as shown below.","title":"Sample file upload response:"},{"location":"unified/controller-resources/#example-request_4","text":"POST /v1/identity/limits-resolutions Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token { ... \"identity_document_reference\" : \"https://api.foo.com/v1/files/file_egflf465vbk7468mvnb\" }","title":"Example Request:"},{"location":"unified/controller-resources/#as-attachment","text":"This option SHOULD be used if you have to combine the uploading of a file with an API request body or parameters in one API request. For example, for the purpose of optimization or to process both the file upload and request data in an atomic manner. For such use cases, the request SHOULD either use content-type multipart/mixed or multipart/related ( RFC 2387 ). Following is an example of such a request.","title":"As Attachment"},{"location":"unified/controller-resources/#example-of-a-multipartrelated-request","text":"The first part in the below multipart request is the request metadata, while the second part contains the binary file content POST /v1/identity/limits-resolutions Host: api.foo.com Content-Type: multipart/related; boundary=--foo_bar_baz Authorization: Bearer oauth2_token --foo_bar_baz Content-Type: application/json; charset=UTF-8 { ... } --foo_bar_baz Content-Type: image/jpeg [JPEG_DATA] --foo_bar_baz--","title":"Example of a multipart/related request:"},{"location":"unified/controller-resources/#hateoas-use-cases","text":"This section describes various use cases where HATEOAS could be used. See the Hypermedia section for more detailed guidelines when implementing HATEOAS-style APIs. As a guiding principle, when adopting HATEOAS, every API SHOULD strive for a single entry point. Any response from this entry point will have HATEOAS links using which the client can navigate to all other methods on the same resource or related resources and sub-resources.","title":"HATEOAS Use Cases"},{"location":"unified/controller-resources/#patterns","text":"Following are different patterns for defining such an API entry point.","title":"Patterns"},{"location":"unified/controller-resources/#pattern-1-api-with-a-top-level-entry-point","text":"For most APIs, there's a natural top level object or a collection which can be the resources addressed by the entry point. For example, the API defined in the previous section has a collection resource /users which can be the entry point URI.","title":"Pattern 1: API with a top level entry point"},{"location":"unified/controller-resources/#pattern-2-entry-point-for-complex-controller-style-operations","text":"A complex multi step operation always has a logical entry point. For example, you want to build an API for a credit application process that involves multiple steps- a create application step, consumer consent step (to sign, agree to terms and conditions), an approval step- the last step of a successful credit application. /apply-credit is the API's entry point. All other steps would be guided by the \"application create\" step in the from of links based on the captured data. For example a successful \"create application\" step would return the link to the next state of the application process apply-sign . An unsuccessful (application with incorrect data) MAY return only a link to send only the incorrect/missing data (e.g PATCH link).","title":"Pattern 2: Entry point for complex controller style operations"},{"location":"unified/controller-resources/#pattern-3-api-without-a-top-level-entry-point","text":"Consider an API that provides a set of independent controller style utility methods. For example, you want to build an identity API that provides the following utility methods. generate OTP (one time password) encrypt payload using a particular algorithm decrypt the payload, link tokens For such cases, the API MAY provide a separate resource /actions to return links to all resources that can be served by this API. GET /actions in the above example would return links to other api methods ( /generate-otp , /encrypt , /decrypt , /link-tokens ).","title":"Pattern 3: API without a top level entry point"},{"location":"unified/controller-resources/#navigating-a-collection","text":"For collection resources, a service MAY automatically provide a paginated collection. The Client can also specify its pagination preferences, if the query resultset is quite large. In such cases, the resultset is returned as a paginated collection with appropriate pagination related links. The Client utilizes these links to navigate through the resultset back-and-forth. For more details on this linking pattern, please refer to Pagination and HATEOAS links.","title":"Navigating A Collection"},{"location":"unified/controller-resources/#error-resolution","text":"There are often use cases where an API wants to provide additional context in case of error along with other error details beyond simple HTTP status codes. (See Error Standards for more). An API could return additional resource links to provide more hints on the error in order to resolve it. Consider an example from the /users API where the user wants to update his address details.","title":"Error Resolution"},{"location":"unified/controller-resources/#request","text":"PATCH /v1/users/ALT-JFWXHGUV7VI { \"address\": { ... } } The service, however, finds that the user account is currently not active. It responds with an error explaining that an update of this account is not possible given the current state. It also returns an HATEOAS link in the response to activate the user account.","title":"Request:"},{"location":"unified/controller-resources/#response","text":"HTTP/1.1 422 Unprocessable Entity { \"name\":\"INVALID_OPERATION\", \"debug_id\":\"123456789\", \"message\":\"An update to an inactive account is not supported.\", \"links\": [ { \"href\": \"https://api.foo.com/v1/customer/partner-referrals/ALT-JFWXHGUV7VI/activate\", \"rel\": \"activate\", \"method\": \"POST\" } ] } The client can now prompt the user to first activate his account and then change his address details.","title":"Response:"},{"location":"unified/controller-resources/#service-controlled-flow","text":"In a complex business operation that has one or more sub-business operations and business rules govern the state transitions at run-time, using HATEOAS links to describe or emit the allowed state transitions prevents clients from embedding the service-specific business logic into their code. Loose coupling or no coupling with server's business logic enables better evolution for both client and server. For example, an order can be cancelled when it is in a PENDING state. The order cannot be cancelled once it moves to a COMPLETED state. Following example shows how a service can use HATEOAS links to guide clients about next possible step(s) in business process.","title":"Service-controlled Flow"},{"location":"unified/controller-resources/#example-pending-order","text":"Order is in PENDING state, so the service returns the cancel HATEOAS link.","title":"Example: Pending Order"},{"location":"unified/controller-resources/#request_1","text":"GET v1/checkout/orders/52181732T9513405D HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token","title":"Request:"},{"location":"unified/controller-resources/#response_1","text":"HTTP/1.1 200 OK Content-Type: application/json { \"payment_details\":{ ... }, \"status\":\"PENDING\", \"links\":[ { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A/cancel\", \"rel\": \"cancel\", \"method\": \"POST\" } ] }","title":"Response:"},{"location":"unified/controller-resources/#example-completed-order","text":"Order is in COMPLETED state so the services does not return the cancel link anymore.","title":"Example: Completed Order"},{"location":"unified/controller-resources/#request_2","text":"GET v1/checkout/orders/52181732T9513405D HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token","title":"Request:"},{"location":"unified/controller-resources/#response_2","text":"HTTP/1.1 200 OK Content-Type: application/json { \"payment_details\":{ ... }, \"status\":\"COMPLETED\", \"links\":[ { \"href\": \"https://api.foo.com/v1/checkout/orders/19S86694A9334040A\", \"rel\": \"self\", \"method\": \"GET\" } ] } NOTE: The service MAY decide to support cancellation of orders (for orders with COMPLETED status) in some countries in future but that does not require the client to change anything in its code. All that a client knows or has coded when it first integrated with the service is the request body that is required to cancel an order.","title":"Response:"},{"location":"unified/controller-resources/#asynchronous-operations","text":"When an operation is carried out asynchronously, it is important to provide relevant links to client so that the client can find out more details about the operation such as finding out status or perform get, update and delete operations. Please refer to Asynchronous Operations to find how the HATEOAS links could be used in response of an asynchronous operation.","title":"Asynchronous Operations"},{"location":"unified/controller-resources/#saving-bandwidth","text":"Some services always return very large response because of the nature of the domain they address. APIs of such services are sometimes referred as Composite APIs (they accumulate data from various sources or an aggregate of more than one services). For such APIs, sending the entire response drastically impacts performance of the API consumer, API server and the underlying network. In such cases, the client can ask the service to return partial representation using Prefer: return=minimal HTTP header. A service could send response with relevant HATEOAS links with minimal data to improve the performance.","title":"Saving Bandwidth"},{"location":"unified/documentation/","text":"Documentation Requirements Accessibility (508 Compliance) In an effort to make all communications as accessible as possible please refer to the WCAG 2.0 guidelines for web. When documenting the API, use document structure elements (such as headings) and ensure document accessibility. Ensure that fonts are legible and that contrast ratios are maintained at all times (minimum 4.5:1 for normal text and 3:1 for large text). Contractions should be avoided, plain language is required, and acronyms must be defined prior to use. If an acronym is used three times or less in a document, do not use it, spell out the words.","title":"Documentation Requirements"},{"location":"unified/documentation/#documentation-requirements","text":"","title":"Documentation Requirements"},{"location":"unified/documentation/#accessibility-508-compliance","text":"In an effort to make all communications as accessible as possible please refer to the WCAG 2.0 guidelines for web. When documenting the API, use document structure elements (such as headings) and ensure document accessibility. Ensure that fonts are legible and that contrast ratios are maintained at all times (minimum 4.5:1 for normal text and 3:1 for large text). Contractions should be avoided, plain language is required, and acronyms must be defined prior to use. If an acronym is used three times or less in a document, do not use it, spell out the words.","title":"Accessibility (508 Compliance)"},{"location":"unified/error-handling/","text":"Error Handling As per HTTP specifications, the outcome of a request execution could be specified using an integer and a message. The number is known as the status code and the message as the reason phrase. The reason phrase is a human-readable message used to clarify the outcome of the response. The HTTP status codes in the 4xx range indicate client-side errors (validation or logic errors), while those in the 5xx range indicate server-side errors (usually defect or outage). However, these status codes and human-readable reason phrases are not sufficient to convey enough information about an error in a machine-readable manner. To resolve an error, non-human consumers of RESTful APIs need additional help. Therefore, APIs MUST return a JSON error representation that conforms to the schema defined in RFC 7807 . Zalando have implemented a JSON Schema definition of the RFC 7807 spec which we use by reference. Error Schema An error response following RFC 7807 schema MUST conform to the following structure: { \"type\": \"https://api.example.com/types/<namespace>/errors/<category>/<error>\", \"title\": \"Request data validation error\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"UUID\", \"invalidParams\": [{ \"field\": \"nickname\", \"code\": \"https://api.example.com/types/<namespace>/errors/validations/missing\", \"message\": \"The value for this field needs to be present.\" }] } The error response structure includes the following fields: Field Description type A human-readable, unique URI for the error. The URI MAY be an endpoint which provides more information about the type of error. title A human-readable message, describing the error. This message MUST be a description of the problem NOT a suggestion about how to fix it. status The HTTP Error Code response of this error. detail If present, the detail field SHOULD focus on helping the client correct the problem, rather than giving debugging information. instance A unique error identifier generated on the server-side and logged for correlation purposes. This could be trace / span identifiers. invalidParams An extension to the error payload. An array that contains individual instance(s) of the error with specifics such as the following. This field is required for client side errors (4xx). field JSON Pointer to the field in error if in body, else name of the path parameter or query parameter. code A human-readable, unique name for the error. message A human-readable message, describing the error. This message MUST be a description of the problem NOT a suggestion about how to fix it. errors An array of individual request errors (or successes) when a bulk request fails. NOTE: The domain name for the error types should be reflective of your organization, not example.com . In this instance, it should be twdps.io . Use of JSON Pointer If you have used some other means to identify the field in an already released API, you could continue using your existing approach. However, if you plan to migrate to the approach suggested, you would want to bump up the major version of your API and provide migration assistance to your clients as this could be a potential breaking change for them. The JSON Pointer for the field SHOULD be a JSON string value. Input Validation Errors In validating requests, there are a variety of concerns that should be addressed in the following order: Problem Code Not well-formed JSON 400 Bad Request Contains validation errors that the client can change. 400 Bad Request Cannot be executed due to factors outside of the request body. 422 Unprocessable Entity The request was well-formed but was unable to be followed due to semantic errors. 409 Conflict Error Samples This section provides some samples to describe usage of RFC 7807 in various scenarios. Validation Error Response - Single Field The following sample shows a validation error in one field. Because this is a client error, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" } ] } Validation Error Response - Multiple Fields The following sample shows a validation error of the same type in two fields. Note that invalidParams is an array listing all the instances in the error. Because both these are a client errors, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" }, { \"field\":\"name\", \"message\":\"Name must be < 20 chars\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" } ] } Validation Error Response - Bulk For heterogeneous types of client-side errors shown below resulting from a bulk request, the error payload includes an array named errors . Each error instance is represented as an item in this array. Because these are client validation errors, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/bulk/failed\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more of the bulk requests failed.\", \"instance\": \"123456789\", \"errors\": [ { \"type\": \"error://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"detail\": \"One or more fields failed validation\", \"status\": 400, \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"error://api.example.com/types/profile/errors/validations/missing\" }, { \"field\": \"name\", \"message\": \"Name must be < 20 chars\", \"code\": \"error://api.example.com/types/profile/errors/validations/too-long\" } ] }, { \"type\": \"error://api.example.com/types/profile/errors/bulk/success\", \"title\": \"Individual request within bulk request succeeded\", \"detail\": \"Request succeeded\", \"status\": 200, \"instance\": \"123456789\" }, { ... } ] } Semantic Validation Error Response In cases where client input is well-formed and valid but the request action may require interaction with APIs or processes outside of this URI, an HTTP status code 422 Unprocessable Entity should be returned. { \"type\": \"error://api.example.com/types/profile/errors/account/balance-error\", \"title\": \"Insufficient balance.\", \"status\": 409, \"detail\": \"The account balance is too low. Add balance to your account to proceed.\", \"instance\": \"123456789\" } Error Declaration In API Specification It is important that documentation generation tools and client/server-side binding generation tools recognize RFC 7807. Following section shows how you could refer to the Zalando definition in an API specification confirming to OpenAPI. { \"responses\": { \"200\": { \"title\": \"Address successfully found and returned.\", \"schema\": { \"$ref\": \"address.json\" } }, \"403\": { \"title\": \"Unauthorized request. This error will occur if the SecurityContext header is not provided or does not include a party_id.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } }, \"404\": { \"title\": \"Address does not exist.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } }, \"default\": { \"title\": \"Unexpected error response.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } } } } Documentation Standards Documentation of error conditions is just as important as the documentation of intended use. Since the range of failure modes is typically larger than success, efforts to provide comprehensive error documentation will Samples with Error Scenarios in Documentation The User Guide of an API is a document that is exposed to API consumers. In addition to linking to samples showing successful execution for invocation on various methods exposed by the API, the API developer should also provide links to samples showing error scenarios. It is equally, or perhaps more, important to show the API consumers how an API would propagate errors in a machine-readable form in order to build applications that take necessary actions to handle errors gracefully and in a meaningful manner. In conclusion, we reiterate the message we started with that non-human consumers of RESTful APIs need more help to take necessary actions to resolve an error in a machine-readable manner. Therefore, a representation of errors following the schema described here MUST be returned by APIs for any HTTP status code that falls into the ranges of 4xx and 5xx.","title":"Error Handling"},{"location":"unified/error-handling/#error-handling","text":"As per HTTP specifications, the outcome of a request execution could be specified using an integer and a message. The number is known as the status code and the message as the reason phrase. The reason phrase is a human-readable message used to clarify the outcome of the response. The HTTP status codes in the 4xx range indicate client-side errors (validation or logic errors), while those in the 5xx range indicate server-side errors (usually defect or outage). However, these status codes and human-readable reason phrases are not sufficient to convey enough information about an error in a machine-readable manner. To resolve an error, non-human consumers of RESTful APIs need additional help. Therefore, APIs MUST return a JSON error representation that conforms to the schema defined in RFC 7807 . Zalando have implemented a JSON Schema definition of the RFC 7807 spec which we use by reference.","title":"Error Handling"},{"location":"unified/error-handling/#error-schema","text":"An error response following RFC 7807 schema MUST conform to the following structure: { \"type\": \"https://api.example.com/types/<namespace>/errors/<category>/<error>\", \"title\": \"Request data validation error\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"UUID\", \"invalidParams\": [{ \"field\": \"nickname\", \"code\": \"https://api.example.com/types/<namespace>/errors/validations/missing\", \"message\": \"The value for this field needs to be present.\" }] } The error response structure includes the following fields: Field Description type A human-readable, unique URI for the error. The URI MAY be an endpoint which provides more information about the type of error. title A human-readable message, describing the error. This message MUST be a description of the problem NOT a suggestion about how to fix it. status The HTTP Error Code response of this error. detail If present, the detail field SHOULD focus on helping the client correct the problem, rather than giving debugging information. instance A unique error identifier generated on the server-side and logged for correlation purposes. This could be trace / span identifiers. invalidParams An extension to the error payload. An array that contains individual instance(s) of the error with specifics such as the following. This field is required for client side errors (4xx). field JSON Pointer to the field in error if in body, else name of the path parameter or query parameter. code A human-readable, unique name for the error. message A human-readable message, describing the error. This message MUST be a description of the problem NOT a suggestion about how to fix it. errors An array of individual request errors (or successes) when a bulk request fails. NOTE: The domain name for the error types should be reflective of your organization, not example.com . In this instance, it should be twdps.io .","title":"Error Schema"},{"location":"unified/error-handling/#use-of-json-pointer","text":"If you have used some other means to identify the field in an already released API, you could continue using your existing approach. However, if you plan to migrate to the approach suggested, you would want to bump up the major version of your API and provide migration assistance to your clients as this could be a potential breaking change for them. The JSON Pointer for the field SHOULD be a JSON string value.","title":"Use of JSON Pointer"},{"location":"unified/error-handling/#input-validation-errors","text":"In validating requests, there are a variety of concerns that should be addressed in the following order: Problem Code Not well-formed JSON 400 Bad Request Contains validation errors that the client can change. 400 Bad Request Cannot be executed due to factors outside of the request body. 422 Unprocessable Entity The request was well-formed but was unable to be followed due to semantic errors. 409 Conflict","title":"Input Validation Errors"},{"location":"unified/error-handling/#error-samples","text":"This section provides some samples to describe usage of RFC 7807 in various scenarios.","title":"Error Samples"},{"location":"unified/error-handling/#validation-error-response-single-field","text":"The following sample shows a validation error in one field. Because this is a client error, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" } ] }","title":"Validation Error Response - Single Field"},{"location":"unified/error-handling/#validation-error-response-multiple-fields","text":"The following sample shows a validation error of the same type in two fields. Note that invalidParams is an array listing all the instances in the error. Because both these are a client errors, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more fields failed validation\", \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" }, { \"field\":\"name\", \"message\":\"Name must be < 20 chars\", \"code\": \"https://api.example.com/types/profile/errors/validations/too-long\" } ] }","title":"Validation Error Response - Multiple Fields"},{"location":"unified/error-handling/#validation-error-response-bulk","text":"For heterogeneous types of client-side errors shown below resulting from a bulk request, the error payload includes an array named errors . Each error instance is represented as an item in this array. Because these are client validation errors, a 400 Bad Request HTTP status code should be returned. { \"type\": \"https://api.example.com/types/profile/errors/bulk/failed\", \"title\": \"Invalid data provided\", \"status\": 400, \"detail\": \"One or more of the bulk requests failed.\", \"instance\": \"123456789\", \"errors\": [ { \"type\": \"error://api.example.com/types/profile/errors/validations/invalid-user\", \"title\": \"Invalid data provided\", \"detail\": \"One or more fields failed validation\", \"status\": 400, \"instance\": \"123456789\", \"invalidParams\": [ { \"field\": \"customerId\", \"message\": \"Required field is missing\", \"code\": \"error://api.example.com/types/profile/errors/validations/missing\" }, { \"field\": \"name\", \"message\": \"Name must be < 20 chars\", \"code\": \"error://api.example.com/types/profile/errors/validations/too-long\" } ] }, { \"type\": \"error://api.example.com/types/profile/errors/bulk/success\", \"title\": \"Individual request within bulk request succeeded\", \"detail\": \"Request succeeded\", \"status\": 200, \"instance\": \"123456789\" }, { ... } ] }","title":"Validation Error Response - Bulk"},{"location":"unified/error-handling/#semantic-validation-error-response","text":"In cases where client input is well-formed and valid but the request action may require interaction with APIs or processes outside of this URI, an HTTP status code 422 Unprocessable Entity should be returned. { \"type\": \"error://api.example.com/types/profile/errors/account/balance-error\", \"title\": \"Insufficient balance.\", \"status\": 409, \"detail\": \"The account balance is too low. Add balance to your account to proceed.\", \"instance\": \"123456789\" }","title":"Semantic Validation Error Response"},{"location":"unified/error-handling/#error-declaration-in-api-specification","text":"It is important that documentation generation tools and client/server-side binding generation tools recognize RFC 7807. Following section shows how you could refer to the Zalando definition in an API specification confirming to OpenAPI. { \"responses\": { \"200\": { \"title\": \"Address successfully found and returned.\", \"schema\": { \"$ref\": \"address.json\" } }, \"403\": { \"title\": \"Unauthorized request. This error will occur if the SecurityContext header is not provided or does not include a party_id.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } }, \"404\": { \"title\": \"Address does not exist.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } }, \"default\": { \"title\": \"Unexpected error response.\", \"schema\": { \"$ref\": \"https://opensource.zalando.com/problem/schema.yaml#/Problem\" } } } }","title":"Error Declaration In API Specification"},{"location":"unified/error-handling/#documentation-standards","text":"Documentation of error conditions is just as important as the documentation of intended use. Since the range of failure modes is typically larger than success, efforts to provide comprehensive error documentation will","title":"Documentation Standards"},{"location":"unified/error-handling/#samples-with-error-scenarios-in-documentation","text":"The User Guide of an API is a document that is exposed to API consumers. In addition to linking to samples showing successful execution for invocation on various methods exposed by the API, the API developer should also provide links to samples showing error scenarios. It is equally, or perhaps more, important to show the API consumers how an API would propagate errors in a machine-readable form in order to build applications that take necessary actions to handle errors gracefully and in a meaningful manner. In conclusion, we reiterate the message we started with that non-human consumers of RESTful APIs need more help to take necessary actions to resolve an error in a machine-readable manner. Therefore, a representation of errors following the schema described here MUST be returned by APIs for any HTTP status code that falls into the ranges of 4xx and 5xx.","title":"Samples with Error Scenarios in Documentation"},{"location":"unified/glossary/","text":"Glossary of REST Terms Capability: Capability represents a business-oriented and customer-facing view of an organization\u2019s business logic. Capabilities can be used to organize a portfolio of APIs as a stable, business-driven view of its system.. Examples of capability are: customer enrollment, vendor managed inventory, pricing and service level offer management. Capabilities drive the API interface, while domains are more coarse-grained and closer to the logical capability model. Capability and Domain are seen as orthogonal concerns from a service perspective. Client / Consumer: An entity that invokes an API request and consumes the API response. [1] Domain: A domain model is a system of abstractions that describes selected aspects of a sphere of knowledge, influence, or activity. The concepts include the data involved in a business, and the rules that the business uses in relation to that data. [4] Experiences: \"Experience\" is a generic name for any of a variety of ways a consumer interacts with the business capabilities. An Experience can be delivered to the consumer via a web-based UI, a mobile application, a CLI, or the API endpoints directly. Namespace: Capabilities drive service modeling and namespace concerns in an API portfolio. Namespaces are part of the Business Capability Model. Examples of namespaces are: orders, contacts, customers, pricing. Namespaces should reflect the domain that logically groups a set of business capabilities. This lets consumers map API endpoints to domain concepts and enables a clearer understanding of the business capabilities which are offered by the API. Representation: REST components perform actions on a resource by using a representation to capture the current or intended state of that resource and by transferring that representation between components. A representation is a sequence of bytes, plus representation metadata to describe those bytes. [3] Resource: The key abstraction of information in REST is a resource. According to Fielding's dissertation section 5.2 , any information that can be named can be a resource: a document or image, a temporal service (e.g. \"today's weather forecast in Los Angeles\"), a collection of other resources, a non-virtual object (e.g. a person), and so on. A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time. More precisely, a resource R is a temporally varying membership function MR(t), that for time t maps to a set of entities, or values, that are equivalent. The values in the set may be resource representations and/or resource identifiers. A resource can also map to the empty set, which allows references to be made to a concept before any realization of that concept exists. As an example, the resource \"today's weather forecast in Los Angeles\" does not imply that there is a specific forecastInLA entity in our database that continually gets updated. Instead, the resource maps to the latest in a series of weather model predictions, and that mapping will change tomorrow when data from the next run of the prediction model is received. Historical data related to past actual weather would be a different resource \"weather observations in Los Angeles\" that maps to a different set of data. It would also be natural to include the \"observations\" resource in the \"forecast\" resource results, if that is useful data for consumers of the forecast. Resource Identifier: An identifier used to identify the particular resource instance involved in a RESTful interaction between components. According to Fielding's dissertation section 5.2, the naming authority (an organization providing APIs, for example) that assigned the resource identifier making it possible to reference the resource, is responsible for maintaining the semantic validity of the mapping over time (ensuring that the membership function does not change).","title":"Glossary"},{"location":"unified/glossary/#glossary-of-rest-terms","text":"","title":"Glossary of REST Terms"},{"location":"unified/glossary/#capability","text":"Capability represents a business-oriented and customer-facing view of an organization\u2019s business logic. Capabilities can be used to organize a portfolio of APIs as a stable, business-driven view of its system.. Examples of capability are: customer enrollment, vendor managed inventory, pricing and service level offer management. Capabilities drive the API interface, while domains are more coarse-grained and closer to the logical capability model. Capability and Domain are seen as orthogonal concerns from a service perspective.","title":"Capability:"},{"location":"unified/glossary/#client-consumer","text":"An entity that invokes an API request and consumes the API response. [1]","title":"Client / Consumer:"},{"location":"unified/glossary/#domain","text":"A domain model is a system of abstractions that describes selected aspects of a sphere of knowledge, influence, or activity. The concepts include the data involved in a business, and the rules that the business uses in relation to that data. [4]","title":"Domain:"},{"location":"unified/glossary/#experiences","text":"\"Experience\" is a generic name for any of a variety of ways a consumer interacts with the business capabilities. An Experience can be delivered to the consumer via a web-based UI, a mobile application, a CLI, or the API endpoints directly.","title":"Experiences:"},{"location":"unified/glossary/#namespace","text":"Capabilities drive service modeling and namespace concerns in an API portfolio. Namespaces are part of the Business Capability Model. Examples of namespaces are: orders, contacts, customers, pricing. Namespaces should reflect the domain that logically groups a set of business capabilities. This lets consumers map API endpoints to domain concepts and enables a clearer understanding of the business capabilities which are offered by the API.","title":"Namespace:"},{"location":"unified/glossary/#representation","text":"REST components perform actions on a resource by using a representation to capture the current or intended state of that resource and by transferring that representation between components. A representation is a sequence of bytes, plus representation metadata to describe those bytes. [3]","title":"Representation:"},{"location":"unified/glossary/#resource","text":"The key abstraction of information in REST is a resource. According to Fielding's dissertation section 5.2 , any information that can be named can be a resource: a document or image, a temporal service (e.g. \"today's weather forecast in Los Angeles\"), a collection of other resources, a non-virtual object (e.g. a person), and so on. A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time. More precisely, a resource R is a temporally varying membership function MR(t), that for time t maps to a set of entities, or values, that are equivalent. The values in the set may be resource representations and/or resource identifiers. A resource can also map to the empty set, which allows references to be made to a concept before any realization of that concept exists. As an example, the resource \"today's weather forecast in Los Angeles\" does not imply that there is a specific forecastInLA entity in our database that continually gets updated. Instead, the resource maps to the latest in a series of weather model predictions, and that mapping will change tomorrow when data from the next run of the prediction model is received. Historical data related to past actual weather would be a different resource \"weather observations in Los Angeles\" that maps to a different set of data. It would also be natural to include the \"observations\" resource in the \"forecast\" resource results, if that is useful data for consumers of the forecast.","title":"Resource:"},{"location":"unified/glossary/#resource-identifier","text":"An identifier used to identify the particular resource instance involved in a RESTful interaction between components. According to Fielding's dissertation section 5.2, the naming authority (an organization providing APIs, for example) that assigned the resource identifier making it possible to reference the resource, is responsible for maintaining the semantic validity of the mapping over time (ensuring that the membership function does not change).","title":"Resource Identifier:"},{"location":"unified/guidelines/","text":"General Guidelines Think of the API as a Product The design of the API should be based on the \u201cAPI as a Product\u201d principle. This means that the API Provider should: Act like a product owner Design the API based on the needs of the customer Focus on customer experience by emphasizing simplicity, comprehensibility and usage of the API Provide a self-service experience (i.e. full documentation, examples, how-to/quick start guides, etc.) Provide service level support to the customer Collect and react to customer feedback Define and Design the API First An API first approach means that the design and development of the API comes first before the implementation. In practice this means: Define the API first, before coding its implementation using a standard specification language such as OpenAPI Specification Collect early review feedback from peers and customers Services interact with each other solely through their exposed APIs Taking an API first approach ensures that the API design is: Focused on the needs of the consumers as opposed to how the underlying service is implemented Focused on generalized business capabilities as opposed to specific use-cases Not just a CRUD-style interface on top of persistence entities, i.e. matches usage patterns and provides business capabilities rather than implementation details Describe the API using an API Specification An API Specification is a formal API description language that standardizes how the API is documented and consumed by the clients. Whereas there are various API specification standards such as RAML and API BluePrint, it is recommended to use OpenAPI Specification ( OAS ) since it\u2019s more widely supported and adopted. We strive to be compliant with the latest released version, which at this moment is OASv3.1 . Previous versions can be found on Github in the OpenAPI Specification project.","title":"General Guidelines"},{"location":"unified/guidelines/#general-guidelines","text":"","title":"General Guidelines"},{"location":"unified/guidelines/#think-of-the-api-as-a-product","text":"The design of the API should be based on the \u201cAPI as a Product\u201d principle. This means that the API Provider should: Act like a product owner Design the API based on the needs of the customer Focus on customer experience by emphasizing simplicity, comprehensibility and usage of the API Provide a self-service experience (i.e. full documentation, examples, how-to/quick start guides, etc.) Provide service level support to the customer Collect and react to customer feedback","title":"Think of the API as a Product"},{"location":"unified/guidelines/#define-and-design-the-api-first","text":"An API first approach means that the design and development of the API comes first before the implementation. In practice this means: Define the API first, before coding its implementation using a standard specification language such as OpenAPI Specification Collect early review feedback from peers and customers Services interact with each other solely through their exposed APIs Taking an API first approach ensures that the API design is: Focused on the needs of the consumers as opposed to how the underlying service is implemented Focused on generalized business capabilities as opposed to specific use-cases Not just a CRUD-style interface on top of persistence entities, i.e. matches usage patterns and provides business capabilities rather than implementation details","title":"Define and Design the API First"},{"location":"unified/guidelines/#describe-the-api-using-an-api-specification","text":"An API Specification is a formal API description language that standardizes how the API is documented and consumed by the clients. Whereas there are various API specification standards such as RAML and API BluePrint, it is recommended to use OpenAPI Specification ( OAS ) since it\u2019s more widely supported and adopted. We strive to be compliant with the latest released version, which at this moment is OASv3.1 . Previous versions can be found on Github in the OpenAPI Specification project.","title":"Describe the API using an API Specification"},{"location":"unified/hypermedia/","text":"Hypermedia HATEOAS Hypermedia, an extension of the term hypertext , is a nonlinear medium of information which includes graphics, audio, video, plain text and hyperlinks according to wikipedia . Hypermedia As The Engine Of Application State ( HATEOAS ) is a constraint of the REST application architecture described by Roy Fielding in his dissertation. In the context of RESTful APIs, a client could interact with a service entirely through hypermedia provided dynamically by the service. A hypermedia-driven service provides representation of resource(s) to its clients to navigate the API dynamically by including hypermedia links in the responses. This is different than other form of SOA, where servers and clients interact based on WSDL-based specification defined somewhere on the web or exchanged off-band. Hypermedia Compliant API A hypermedia compliant API exposes a finite state machine of a service. Here, requests such as DELETE and POST typically initiate a transition in state while responses indicate the change in the state. Let's take an example of an API that exposes a set of operations to manage a user account lifecycle and implements the HATEOAS interface constraint. A client starts interaction with a service through a fixed URI /users . This fixed URI supports both GET and POST operations. The client decides to do a POST operation to create a user in the system. Request: POST https://api.example.com/v1/customer/users { \"given_name\": \"James\", \"surname\" : \"Greenwood\", ... } Response: The API creates a new user from the input and returns the following links to the client in the response. A link to retrieve the complete representation of the user (aka self link) (GET). A link to delete the user (DELETE). HTTP/1.1 201 CREATED Content-Type: application/json ... { \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\", }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } A client can store these links in its database for later use. A client may then want to display a set of users and their details before the admin decides to delete one of the users. So the client does a GET to the same fixed URI /users . Request: GET https://api.example.com/v1/customer/users The API returns all the users in the system with respective self links. Response: { \"total_items\": \"166\", \"total_pages\": \"83\", \"users\": [ { \"given_name\": \"James\", \"surname\": \"Greenwood\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\" } ] }, { \"given_name\": \"David\", \"surname\": \"Brown\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-MDFSKFGIFJ86DSF\", \"rel\": \"self\" } ], ... } ] } The client MAY follow the self link of the user and figure out all the possible operations that it can perform on the user resource. Request: GET https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI Response: HTTP/1.1 200 OK Content-Type: application/json { \"given_name\": \"James\", \"surname\": \"Greenwood\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\", }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } To delete the user, the client retrieves the URI of the link relation type delete from its data store and performs a delete operation on the URI. Request: DELETE https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI Summary There is a well defined entry point for an API which a client navigates to in order to access all other resources. The client does not need to build the logic of composing URIs to execute different requests or code any kind of business rule by looking into the response details (more in detail is described in the later sections) that may be associated with the URIs and state changes. The client acknowledges the fact that the process of creating URIs belongs to the server. Client treats URIs as opaque identifiers. There is no semantic meaning to be inferred by the value of the identifier. For example, resources added consecutively do not have consecutive identifiers. APIs using hypermedia in representations could be extended seamlessly. As new methods are introduced, responses could be extended with relevant HATEOAS links. In this way, clients could take advantage of the functionality in incremental fashion. For example, if the API starts supporting a new PATCH operation then clients could use it to do partial updates. The mere presence of links does not decouple a client from having to learn the data required to make requests for a transition and all associated link semantics, particularly for POST/PUT/PATCH operations. An API MUST provide documentation to clearly describe all the links, link relation types and request response formats for each of the URIs. Subsequent sections provide more details about the structure of a link and what different relationship types mean. Link Description Object Links MUST be described using the [Link Description Object (LDO)] [4] schema. An LDO describes a single link relation in the links array. Following is a brief description for properties of Link Description Object. href: A value for the href property MUST be provided. The value of the href property MUST be a [URI template] and used to determine the target URI of the related resource. It SHOULD be resolved as a URI template per RFC 6570. Use ONLY absolute URIs as a value for href property. Clients usually bookmark the absolute URI of a link relation type from the representation to make API requests later. Developers MUST use the URI Component Naming Conventions to construct absolute URIs. The value from the incoming Host header (e.g. api.example.com) MUST be used as the host field of the absolute URI. rel: rel stands for relation as defined in Link Relation Type The value of the rel property indicates the name of the relation to the target resource. A value for the rel property MUST be provided. method: The method property identifies the HTTP verb that MUST be used to make a request to the target of the link. The method property assumes a default value of GET if it is omitted. title: The title property provides a title for the link and is a helpful documentation tool to facilitate understanding by the end clients. This property is NOT REQUIRED. Not Using HTTP Headers For LDO Note that these API guidelines do not recommend using the HTTP Location header to provide a link. Also, they do not recommend using the Link header as described in JAX-RS . The scope of HTTP header is limited to point-to-point interaction between a client and a service. Since responses might be passed around to other layers and components on the client side which may not directly interact with the service, any information that is stored in a header may not be available. Therefore, we recommend returning Link Description Object(s) in HTTP response body. Links Array The links array property of schemas is used to associate a Link Description Objects with a [JSON hyper-schema draft-04] [3] instance. This property MUST be an array. Items in the array MUST be of type Link Description Object. Specifying the Links array Here\u2019s an example of how you would describe links in the schema. A links array similar to the one defined in the sample JSON schema below MUST be provided as part of the API resource schema definition. Please note that the links array needs to be declared within the properties keyword of an object. This is required for code generators to add setter/getter methods for the links array in the generated object. All possible links that an API returns as part of the response MUST be declared in the response schema using a URI template. The links array of URI templates MUST be declared outside the properties keyword. { \"type\": \"object\", \"$schema\": \"http://json-schema.org/draft-04/hyper-schema#\", \"description\": \"A sample resource representing a customer name.\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"Unique ID to identify a customer.\" }, \"first_name\": { \"type\": \"string\", \"description\": \"Customer's first name.\" }, \"last_name\": { \"type\": \"string\", \"description\": \"Customer's last name.\" }, \"links\": { \"type\": \"array\", \"items\": { \"$ref\": \"http://json-schema.org/draft-04/hyper-schema#definitions/linkDescription\" } } }, \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/{id}\", \"rel\": \"self\" }, { \"href\": \"https://api.example.com/v1/customer/users/{id}\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } Below is an example response that is compliant with the above schema. { \"id\": \"ALT-JFWXHGUV7VI\", \"first_name\": \"John\", \"last_name\": \"Doe\", \"links\": [ { \"href\": \"https://api.example.com/v1/cusommer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\" }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } Link Relation Type A Link Relation Type serves as an identifier for a link. An API MUST assign a meaningful link relation type that unambiguously describes the semantics of the link. Clients use the relevant Link Relation Type in order to identify the link to use from a representation. When the semantics of a Link Relation Type defined in [IANA\u2019s list of standardized link relations] matches with the one you want to define, then it MUST be used. The table below describes some of the commonly used link relation types. It also lists some additional lin relation types defined by these guidelines. For all controller style complex operations, the controller action name must be used as the link relation type (e.g. activate,cancel,refund). Link Relation Type Description self Conveys an identifier for the link\u2019s context. Usually a link pointing to the resource itself. create Refers to a link that can be used to create a new resource. edit Refers to editing (or partially updating) the representation identified by the link. Use this to represent a PATCH operation link. delete Refers to deleting a resource identified by the link. Use this Extended link relation type to represent a DELETE operation link. replace Refers to completely update (or replace) the representation identified by the link. Use this Extended link relation type to represent a PUT operation link. first Refers to the first page of the result list. last Refers to the last page of the result list provided total_required is specified as a query parameter. next Refers to the next page of the result list. prev Refers to the previous page of the result list. collection Refers to a collections resource (e.g /v1/users). latest-version Points to a resource containing the latest (e.g. current) version. search Refers to a resource that can be used to search through the link\u2019s context and related resources. up Refers to a parent resource in a hierarchy of resources. Use Cases See HATEOAS Use Cases to find where HATEOAS could be used.","title":"Hypermedia"},{"location":"unified/hypermedia/#hypermedia","text":"","title":"Hypermedia"},{"location":"unified/hypermedia/#hateoas","text":"Hypermedia, an extension of the term hypertext , is a nonlinear medium of information which includes graphics, audio, video, plain text and hyperlinks according to wikipedia . Hypermedia As The Engine Of Application State ( HATEOAS ) is a constraint of the REST application architecture described by Roy Fielding in his dissertation. In the context of RESTful APIs, a client could interact with a service entirely through hypermedia provided dynamically by the service. A hypermedia-driven service provides representation of resource(s) to its clients to navigate the API dynamically by including hypermedia links in the responses. This is different than other form of SOA, where servers and clients interact based on WSDL-based specification defined somewhere on the web or exchanged off-band.","title":"HATEOAS"},{"location":"unified/hypermedia/#hypermedia-compliant-api","text":"A hypermedia compliant API exposes a finite state machine of a service. Here, requests such as DELETE and POST typically initiate a transition in state while responses indicate the change in the state. Let's take an example of an API that exposes a set of operations to manage a user account lifecycle and implements the HATEOAS interface constraint. A client starts interaction with a service through a fixed URI /users . This fixed URI supports both GET and POST operations. The client decides to do a POST operation to create a user in the system.","title":"Hypermedia Compliant API"},{"location":"unified/hypermedia/#request","text":"POST https://api.example.com/v1/customer/users { \"given_name\": \"James\", \"surname\" : \"Greenwood\", ... }","title":"Request:"},{"location":"unified/hypermedia/#response","text":"The API creates a new user from the input and returns the following links to the client in the response. A link to retrieve the complete representation of the user (aka self link) (GET). A link to delete the user (DELETE). HTTP/1.1 201 CREATED Content-Type: application/json ... { \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\", }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } A client can store these links in its database for later use. A client may then want to display a set of users and their details before the admin decides to delete one of the users. So the client does a GET to the same fixed URI /users .","title":"Response:"},{"location":"unified/hypermedia/#request_1","text":"GET https://api.example.com/v1/customer/users The API returns all the users in the system with respective self links.","title":"Request:"},{"location":"unified/hypermedia/#response_1","text":"{ \"total_items\": \"166\", \"total_pages\": \"83\", \"users\": [ { \"given_name\": \"James\", \"surname\": \"Greenwood\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\" } ] }, { \"given_name\": \"David\", \"surname\": \"Brown\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-MDFSKFGIFJ86DSF\", \"rel\": \"self\" } ], ... } ] } The client MAY follow the self link of the user and figure out all the possible operations that it can perform on the user resource.","title":"Response:"},{"location":"unified/hypermedia/#request_2","text":"GET https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI Response: HTTP/1.1 200 OK Content-Type: application/json { \"given_name\": \"James\", \"surname\": \"Greenwood\", ... \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\", }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } To delete the user, the client retrieves the URI of the link relation type delete from its data store and performs a delete operation on the URI.","title":"Request:"},{"location":"unified/hypermedia/#request_3","text":"DELETE https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI Summary There is a well defined entry point for an API which a client navigates to in order to access all other resources. The client does not need to build the logic of composing URIs to execute different requests or code any kind of business rule by looking into the response details (more in detail is described in the later sections) that may be associated with the URIs and state changes. The client acknowledges the fact that the process of creating URIs belongs to the server. Client treats URIs as opaque identifiers. There is no semantic meaning to be inferred by the value of the identifier. For example, resources added consecutively do not have consecutive identifiers. APIs using hypermedia in representations could be extended seamlessly. As new methods are introduced, responses could be extended with relevant HATEOAS links. In this way, clients could take advantage of the functionality in incremental fashion. For example, if the API starts supporting a new PATCH operation then clients could use it to do partial updates. The mere presence of links does not decouple a client from having to learn the data required to make requests for a transition and all associated link semantics, particularly for POST/PUT/PATCH operations. An API MUST provide documentation to clearly describe all the links, link relation types and request response formats for each of the URIs. Subsequent sections provide more details about the structure of a link and what different relationship types mean.","title":"Request:"},{"location":"unified/hypermedia/#link-description-object","text":"Links MUST be described using the [Link Description Object (LDO)] [4] schema. An LDO describes a single link relation in the links array. Following is a brief description for properties of Link Description Object.","title":"Link Description Object"},{"location":"unified/hypermedia/#href","text":"A value for the href property MUST be provided. The value of the href property MUST be a [URI template] and used to determine the target URI of the related resource. It SHOULD be resolved as a URI template per RFC 6570. Use ONLY absolute URIs as a value for href property. Clients usually bookmark the absolute URI of a link relation type from the representation to make API requests later. Developers MUST use the URI Component Naming Conventions to construct absolute URIs. The value from the incoming Host header (e.g. api.example.com) MUST be used as the host field of the absolute URI.","title":"href:"},{"location":"unified/hypermedia/#rel","text":"rel stands for relation as defined in Link Relation Type The value of the rel property indicates the name of the relation to the target resource. A value for the rel property MUST be provided.","title":"rel:"},{"location":"unified/hypermedia/#method","text":"The method property identifies the HTTP verb that MUST be used to make a request to the target of the link. The method property assumes a default value of GET if it is omitted.","title":"method:"},{"location":"unified/hypermedia/#title","text":"The title property provides a title for the link and is a helpful documentation tool to facilitate understanding by the end clients. This property is NOT REQUIRED.","title":"title:"},{"location":"unified/hypermedia/#not-using-http-headers-for-ldo","text":"Note that these API guidelines do not recommend using the HTTP Location header to provide a link. Also, they do not recommend using the Link header as described in JAX-RS . The scope of HTTP header is limited to point-to-point interaction between a client and a service. Since responses might be passed around to other layers and components on the client side which may not directly interact with the service, any information that is stored in a header may not be available. Therefore, we recommend returning Link Description Object(s) in HTTP response body.","title":"Not Using HTTP Headers For LDO"},{"location":"unified/hypermedia/#links-array","text":"The links array property of schemas is used to associate a Link Description Objects with a [JSON hyper-schema draft-04] [3] instance. This property MUST be an array. Items in the array MUST be of type Link Description Object.","title":"Links Array"},{"location":"unified/hypermedia/#specifying-the-links-array","text":"Here\u2019s an example of how you would describe links in the schema. A links array similar to the one defined in the sample JSON schema below MUST be provided as part of the API resource schema definition. Please note that the links array needs to be declared within the properties keyword of an object. This is required for code generators to add setter/getter methods for the links array in the generated object. All possible links that an API returns as part of the response MUST be declared in the response schema using a URI template. The links array of URI templates MUST be declared outside the properties keyword. { \"type\": \"object\", \"$schema\": \"http://json-schema.org/draft-04/hyper-schema#\", \"description\": \"A sample resource representing a customer name.\", \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"Unique ID to identify a customer.\" }, \"first_name\": { \"type\": \"string\", \"description\": \"Customer's first name.\" }, \"last_name\": { \"type\": \"string\", \"description\": \"Customer's last name.\" }, \"links\": { \"type\": \"array\", \"items\": { \"$ref\": \"http://json-schema.org/draft-04/hyper-schema#definitions/linkDescription\" } } }, \"links\": [ { \"href\": \"https://api.example.com/v1/customer/users/{id}\", \"rel\": \"self\" }, { \"href\": \"https://api.example.com/v1/customer/users/{id}\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } Below is an example response that is compliant with the above schema. { \"id\": \"ALT-JFWXHGUV7VI\", \"first_name\": \"John\", \"last_name\": \"Doe\", \"links\": [ { \"href\": \"https://api.example.com/v1/cusommer/users/ALT-JFWXHGUV7VI\", \"rel\": \"self\" }, { \"href\": \"https://api.example.com/v1/customer/users/ALT-JFWXHGUV7VI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] }","title":"Specifying the Links array"},{"location":"unified/hypermedia/#link-relation-type","text":"A Link Relation Type serves as an identifier for a link. An API MUST assign a meaningful link relation type that unambiguously describes the semantics of the link. Clients use the relevant Link Relation Type in order to identify the link to use from a representation. When the semantics of a Link Relation Type defined in [IANA\u2019s list of standardized link relations] matches with the one you want to define, then it MUST be used. The table below describes some of the commonly used link relation types. It also lists some additional lin relation types defined by these guidelines. For all controller style complex operations, the controller action name must be used as the link relation type (e.g. activate,cancel,refund). Link Relation Type Description self Conveys an identifier for the link\u2019s context. Usually a link pointing to the resource itself. create Refers to a link that can be used to create a new resource. edit Refers to editing (or partially updating) the representation identified by the link. Use this to represent a PATCH operation link. delete Refers to deleting a resource identified by the link. Use this Extended link relation type to represent a DELETE operation link. replace Refers to completely update (or replace) the representation identified by the link. Use this Extended link relation type to represent a PUT operation link. first Refers to the first page of the result list. last Refers to the last page of the result list provided total_required is specified as a query parameter. next Refers to the next page of the result list. prev Refers to the previous page of the result list. collection Refers to a collections resource (e.g /v1/users). latest-version Points to a resource containing the latest (e.g. current) version. search Refers to a resource that can be used to search through the link\u2019s context and related resources. up Refers to a parent resource in a hierarchy of resources.","title":"Link Relation Type"},{"location":"unified/hypermedia/#use-cases","text":"See HATEOAS Use Cases to find where HATEOAS could be used.","title":"Use Cases"},{"location":"unified/intro/","text":"Introduction Abstract The typical microservices platform is a collection of reusable services that encapsulate well-defined business capabilities. Developers are encouraged to access these capabilities through Application Programming Interfaces (APIs) that enable consistent design patterns and principles. This facilitates a great developer experience and the ability to quickly compose complex business processes by combining multiple, complementary capabilities as building blocks Purpose APIs follow the RESTful architectural style wherever possible. This is largely driven by the API readability and mature tooling available for REST API development. Some APIs will benefit from the advantages of an RPC-style interface, such as gRPC. To support our objectives, we have developed a set of rules, standards, and conventions that apply to the design of RESTful APIs. These have been used to help design and maintain hundreds of APIs and have evolved over several years to meet the needs of a wide variety of use cases. This document is based on the incredible work done at PayPal and Zalando on their API style guide. Document Semantics, Formatting, and Naming The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The words \u201cREST\u201d and \u201cRESTful\u201d MUST be written as presented here, representing the acronym as all upper-case letters. This is also true of \u201cJSON,\u201d \u201cXML,\u201d and other acronyms. Machine-readable text, such as URLs, HTTP verbs, and source code, are represented using a fixed-width font. URIs containing variable blocks are specified according to URI Template RFC 6570 . For example, a URL containing a variable called accountId would be shown as https://api.example.com/v1/accounts/{accountId}/ . HTTP headers are written in PascalCase + hyphenated syntax, e.g. Idempotency-Key . Interpreting The Guidelines To aid understanding, we define key terms used within this standards document: Resource The key abstraction of information in REST is a resource. According to Fielding\u2019s dissertation section 5.2 , any information that can be named can be a resource: a document or image, a temporal service (e.g. \u201ctoday\u2019s weather in Los Angeles\u201d), a collection of other resources, a non-virtual object (e.g. a person), and so on. A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time. The values in the set may be resource representations and/or resource identifiers. A resource can also map to the empty set, which allows references to be made to a concept before any realization of that concept exists. Resource Identifier REST uses a resource identifier to identify the particular resource instance involved in an interaction between components. The naming authority (an organization providing APIs, for example) that assigned the resource identifier making it possible to reference the resource, is responsible for maintaining the semantic validity of the mapping over time (ensuring that the membership function does not change). Representation REST components perform actions on a resource by using a representation to capture the current or intended state of that resource and by transferring that representation between components. A representation is a sequence of bytes, plus representation metadata to describe those bytes. Domain According to Wikipedia, a domain model is a system of abstractions that describes selected aspects of a sphere of knowledge, influence, or activity. The concepts include the data involved in a business, and the rules that the business uses in relation to that data. Domain definition should reflect the customer\u2019s perspective on how platform capabilities are organized. Note that these may not necessarily reflect the company\u2019s hierarchy, organization, or (existing) code structure. In some cases, domain definitions are aspirational, in the sense that these reflect the target, customer-oriented platform organization model. Underlying service implementations and organization structures may need to migrate to reflect these boundaries over time. As an example, a domain model may include domains such as Customer, Order, Invoice, Payment, Customer Support, etc. Capability Capability represents a business-oriented and customer-facing view of an organization\u2019s business logic. Capabilities can be used to organize a portfolio of APIs as a stable, business-driven view of its system.. Examples of capability are: customer enrollment, vendor managed inventory, pricing and service level offer management. Capabilities drive the API interface, while domains are more coarse-grained and closer to the logical capability model. Capability and Domain are seen as orthogonal concerns from a service perspective. Experiences \"Experience\" is a generic name for any of a variety of ways a consumer interacts with the business capabilities. An Experience can be delivered to the consumer via a web-based UI, a mobile application, a CLI, or the API endpoints directly. Namespace Capabilities drive service modeling and namespace concerns in an API portfolio. Namespaces are part of the Business Capability Model. Examples of namespaces are: orders, contacts, customers, pricing. Namespaces should reflect the domain that logically groups a set of business capabilities. This lets consumers map API endpoints to domain concepts and enables a clearer understanding of the business capabilities which are offered by the API. Service Services provide a generic API for accessing and manipulating the value set of a resource, regardless of how the membership function is defined or the type of software that is handling the request. Services are generic pieces of software that can perform any number of functions. It is, therefore, instructive to think about the different types of services that exist. Logically, we can segment the services and the APIs that they expose into two categories: Capability APIs Experience-specific APIs Capability Services and APIs Capability APIs are public APIs exposed by services implementing generic, reusable business capabilities. Public implies that these APIs are limited only to the interfaces meant for consumption by front-end experiences, external consumers, or internal consumers from a different domain. Experience-specific Services and APIs Experience-specific APIs are built on top of capability APIs. They expose functionality which may be either specific to an interaction mode, or optimized for a context-specific specialization of a generic capability. Contextual information could be related to time, location, device, channel, identity, user, role, or privilege level among other things. Experience-specific services provide minimal additional business logic over core capabilities, and mainly provide transformation and lightweight orchestration to tailor an interaction to the needs of a specific experience, channel or device. Their input/output functionality is limited to service calls. Client, API Client, API Consumer An entity that invokes an API request and consumes the API response.","title":"Introduction"},{"location":"unified/intro/#introduction","text":"","title":"Introduction"},{"location":"unified/intro/#abstract","text":"The typical microservices platform is a collection of reusable services that encapsulate well-defined business capabilities. Developers are encouraged to access these capabilities through Application Programming Interfaces (APIs) that enable consistent design patterns and principles. This facilitates a great developer experience and the ability to quickly compose complex business processes by combining multiple, complementary capabilities as building blocks","title":"Abstract"},{"location":"unified/intro/#purpose","text":"APIs follow the RESTful architectural style wherever possible. This is largely driven by the API readability and mature tooling available for REST API development. Some APIs will benefit from the advantages of an RPC-style interface, such as gRPC. To support our objectives, we have developed a set of rules, standards, and conventions that apply to the design of RESTful APIs. These have been used to help design and maintain hundreds of APIs and have evolved over several years to meet the needs of a wide variety of use cases. This document is based on the incredible work done at PayPal and Zalando on their API style guide.","title":"Purpose"},{"location":"unified/intro/#document-semantics-formatting-and-naming","text":"The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The words \u201cREST\u201d and \u201cRESTful\u201d MUST be written as presented here, representing the acronym as all upper-case letters. This is also true of \u201cJSON,\u201d \u201cXML,\u201d and other acronyms. Machine-readable text, such as URLs, HTTP verbs, and source code, are represented using a fixed-width font. URIs containing variable blocks are specified according to URI Template RFC 6570 . For example, a URL containing a variable called accountId would be shown as https://api.example.com/v1/accounts/{accountId}/ . HTTP headers are written in PascalCase + hyphenated syntax, e.g. Idempotency-Key .","title":"Document Semantics, Formatting, and Naming"},{"location":"unified/intro/#interpreting-the-guidelines","text":"To aid understanding, we define key terms used within this standards document:","title":"Interpreting The Guidelines"},{"location":"unified/intro/#resource","text":"The key abstraction of information in REST is a resource. According to Fielding\u2019s dissertation section 5.2 , any information that can be named can be a resource: a document or image, a temporal service (e.g. \u201ctoday\u2019s weather in Los Angeles\u201d), a collection of other resources, a non-virtual object (e.g. a person), and so on. A resource is a conceptual mapping to a set of entities, not the entity that corresponds to the mapping at any particular point in time. The values in the set may be resource representations and/or resource identifiers. A resource can also map to the empty set, which allows references to be made to a concept before any realization of that concept exists.","title":"Resource"},{"location":"unified/intro/#resource-identifier","text":"REST uses a resource identifier to identify the particular resource instance involved in an interaction between components. The naming authority (an organization providing APIs, for example) that assigned the resource identifier making it possible to reference the resource, is responsible for maintaining the semantic validity of the mapping over time (ensuring that the membership function does not change).","title":"Resource Identifier"},{"location":"unified/intro/#representation","text":"REST components perform actions on a resource by using a representation to capture the current or intended state of that resource and by transferring that representation between components. A representation is a sequence of bytes, plus representation metadata to describe those bytes.","title":"Representation"},{"location":"unified/intro/#domain","text":"According to Wikipedia, a domain model is a system of abstractions that describes selected aspects of a sphere of knowledge, influence, or activity. The concepts include the data involved in a business, and the rules that the business uses in relation to that data. Domain definition should reflect the customer\u2019s perspective on how platform capabilities are organized. Note that these may not necessarily reflect the company\u2019s hierarchy, organization, or (existing) code structure. In some cases, domain definitions are aspirational, in the sense that these reflect the target, customer-oriented platform organization model. Underlying service implementations and organization structures may need to migrate to reflect these boundaries over time. As an example, a domain model may include domains such as Customer, Order, Invoice, Payment, Customer Support, etc.","title":"Domain"},{"location":"unified/intro/#capability","text":"Capability represents a business-oriented and customer-facing view of an organization\u2019s business logic. Capabilities can be used to organize a portfolio of APIs as a stable, business-driven view of its system.. Examples of capability are: customer enrollment, vendor managed inventory, pricing and service level offer management. Capabilities drive the API interface, while domains are more coarse-grained and closer to the logical capability model. Capability and Domain are seen as orthogonal concerns from a service perspective.","title":"Capability"},{"location":"unified/intro/#experiences","text":"\"Experience\" is a generic name for any of a variety of ways a consumer interacts with the business capabilities. An Experience can be delivered to the consumer via a web-based UI, a mobile application, a CLI, or the API endpoints directly.","title":"Experiences"},{"location":"unified/intro/#namespace","text":"Capabilities drive service modeling and namespace concerns in an API portfolio. Namespaces are part of the Business Capability Model. Examples of namespaces are: orders, contacts, customers, pricing. Namespaces should reflect the domain that logically groups a set of business capabilities. This lets consumers map API endpoints to domain concepts and enables a clearer understanding of the business capabilities which are offered by the API.","title":"Namespace"},{"location":"unified/intro/#service","text":"Services provide a generic API for accessing and manipulating the value set of a resource, regardless of how the membership function is defined or the type of software that is handling the request. Services are generic pieces of software that can perform any number of functions. It is, therefore, instructive to think about the different types of services that exist. Logically, we can segment the services and the APIs that they expose into two categories: Capability APIs Experience-specific APIs","title":"Service"},{"location":"unified/intro/#capability-services-and-apis","text":"Capability APIs are public APIs exposed by services implementing generic, reusable business capabilities. Public implies that these APIs are limited only to the interfaces meant for consumption by front-end experiences, external consumers, or internal consumers from a different domain.","title":"Capability Services and APIs"},{"location":"unified/intro/#experience-specific-services-and-apis","text":"Experience-specific APIs are built on top of capability APIs. They expose functionality which may be either specific to an interaction mode, or optimized for a context-specific specialization of a generic capability. Contextual information could be related to time, location, device, channel, identity, user, role, or privilege level among other things. Experience-specific services provide minimal additional business logic over core capabilities, and mainly provide transformation and lightweight orchestration to tailor an interaction to the needs of a specific experience, channel or device. Their input/output functionality is limited to service calls.","title":"Experience-specific Services and APIs"},{"location":"unified/intro/#client-api-client-api-consumer","text":"An entity that invokes an API request and consumes the API response.","title":"Client, API Client, API Consumer"},{"location":"unified/methods/","text":"HTTP Methods, Headers, and Statuses Data Resources And HTTP Methods Various business capabilities of an organization are exposed through APIs as a set of resources. Business Capabilities and Resource Modeling Functionality MUST NOT be duplicated across APIs. Resources (e.g. user account, credit card, etc.) are expected to be re-used as needed across use-cases. HTTP Methods Most services will fall easily into the standard data resource model where primary operations can be represented by the acronym CRUD (Create, Read, Update, and Delete). These map very well to standard HTTP verbs. HTTP Method Description GET To retrieve a resource. POST To create a resource, or to execute a complex operation on a resource. DELETE To delete a resource. PATCH* To perform a partial update to a resource. PUT To update a resource. NOTE: We recommend against using PATCH because of the potential complications arising from the semantics and race conditions of a partial record update. In general, we prefer using PUT to ensure atomic updates to a resource, and matching version numbers or last-updated timestamps to avoid race conditions. Processing The actual operation invoked MUST match the HTTP method semantics as defined in the table above. The GET method MUST NOT have side effects. It MUST NOT change the state of an underlying resource. The POST method SHOULD be used to create a new resource in a collection. Example: To add a credit card on file, POST https://api.example.com/v1/vault/credit-cards Idempotency semantics: If this is a subsequent execution of the same invocation (including the Idempotency-Key header) and the resource was already created, then the request SHOULD be idempotent. The POST method SHOULD be used to create a new sub-resource and establish its relationship with the main resource. Example: To refund a payment with transaction ID 12345: POST https://api.example.com/v1/payments/12345/refund The POST method MAY be used in complex operations, along with the name of the operation. This is also known as the controller pattern and is considered an exception to the RESTful model. It is more applicable in cases when resources represent a business process, and operations are the steps or actions to be performed as part of it. For more information, please refer to section 2.6 of the RESTful Web Services Cookbook . The PUT method SHOULD be used to update resource attributes or to establish a relationship from a resource to an existing sub-resource; it updates the main resource with a reference to the sub-resource. Unless otherwise noted, request and response bodies MUST be sent using JavaScript Object Notation (JSON) . JSON is a light-weight data representation for an object composed of unordered key-value pairs. JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). When processing an API method call, the following guidelines SHOULD be followed. Data Model The data model for representation MUST conform to the JSON Data Interchange Format as described in RFC 7159 . Serialization Resource endpoints MUST support application/json as content type. If an Accept header is sent and application/json is not an acceptable response, a 406 Not Acceptable error MUST be returned. Input and Output Strictness APIs MUST be strict in the information they produce, and they SHOULD be strict in what they consume as well. Since we are dealing with programming interfaces, we need to avoid guessing the meaning of what is being sent to us as much as possible. Given that integration is typically a one-time task for a developer and we provide good documentation, we need to be strict with using the data that is being received. Postel\u2019s law must be weighed against the many dangers of permissive parsing. In order to improve developer experience, the APIs SHOULD provide feedback if we don\u2019t understand the fields that the user is sending us. HTTP Header Policies The purpose of HTTP headers is to provide metadata information about the body or the sender of the message in a uniform, standardized, and isolated way. Assumptions Service Consumers and Service Providers: SHOULD NOT expect that a particular HTTP header is available. It is possible that an intermediary component in the call chain can drop an HTTP header. This is the reason business logic SHOULD NOT be based on HTTP headers. SHOULD NOT assume the value of a header has not been changed as part of HTTP message transmission. Infrastructure Components (Web-services framework, Client invocation library, Enterprise Service Bus (ESB), Load Balancers (LB), etc. involved in HTTP message delivery): MAY return an error based on availability and validity of a particular header without transmitting the message forward. For example, an authentication or authorization error for a request based on client identity and credentials. MAY add, remove, or change a value of an HTTP header. Policies The guidelines below should be applied when adding HTTP headers to client requests or server responses. If available, HTTP standard headers MUST be used instead of creating a custom header. HTTP header names are NOT case sensitive. HTTP headers SHOULD only be used for the purpose of handling cross-cutting concerns such as Authorization. API implementations SHOULD NOT introduce or depend on headers. API implementations MUST NOT use headers in a way that changes the behaviour of HTTP methods API implementations MUST NOT use headers to communicate business logic or service logic (e.g. paging response info, PII query parameters) HTTP Standard Headers These are headers defined or referenced from HTTP/1.1 specification ( RFC 7231 ). Their purpose, syntax, values, and semantics are well-defined and understood by many infrastructure components. Accept This request header specifies the media types that the API client is capable of handling in the response. Systems issuing the HTTP request SHOULD send this header. Systems handling the request SHOULD NOT assume it is available. It is assumed throughout these API guidelines that APIs accept application/json . Accept-Charset This request header specifies what character sets the API client is capable of handling in the response. The value of Accept-Charset SHOULD include utf-8. Content-Language This request/response header is used to specify the language of the content. The default locale is en-US. API clients SHOULD identify the language of the data using Content-Language header. APIs MUST provide this header in the response. Example: Content-Language: en-US Content-Type This request/response header indicates the media type of the request or response body. API client MUST include with request if the request contains a body, e.g. it is a POST request. API developer MUST include it with response if a response body is included (not used with 204 responses). If the content is a text-based type, such as JSON, the Content-Type MUST include a character-set parameter. The character-set MUST be UTF-8 . The only supported media type for now is application/json. Example: (in HTTP request) Accept: application/json; Accept-Charset: utf-8 (in HTTP response) Content-Type: application/json; charset=utf-8 Link According to Web Linking RFC 5988 , a link is a typed connection between two resources that are identified by Internationalised Resource Identifiers (IRIs). The Link entity-header field provides a means for serializing one or more links in HTTP headers. APIs SHOULD be built with a design assumption that neither an API, nor an API client\u2019s business logic should depend on information provided in the headers. Headers must only be used to carry cross-cutting concern information such as security, traceability, monitoring, etc. Therefore, usage of the Link header is prohibited with response codes 201 or 3xx. Consider using HATEOAS links in the response body instead. Location This response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. APIs SHOULD be built with a design assumption that neither an API, nor an API client\u2019s business logic should depend on information provided in the headers. Headers must only be used to carry cross-cutting concern information such as security, traceability, monitoring, etc. Therefore, usage of the Location header is prohibited with response codes 201 or 3xx. Consider using HATEOAS links in the response body instead. Prefer The Prefer request header field is used to indicate that a particular server behavior(s) is preferred by the client but is not required for successful completion of the request. It is an end to end field and MUST be forwarded by a proxy if the request is forwarded unless Prefer is explicitly identified as being hop by hop using the Connection header field. Following token values are possible to use for APIs provided an API documentation explicitly indicates support for Prefer . Prefer: respond-async : API client prefers that API server processes its request asynchronously. Server returns a 202 Accepted response and processes the request asynchronously. API server could use a webhook to inform the client subsequently, or the client may call GET to get the response at a later time. Refer to Asynchronous Operations for more details. Prefer: read-consistent : API client prefers that API server returns response from a durable store with consistent data. For APIs that are not offering any optimization preferences for their clients, this behavior would be the default and it would not require the client to set this token. Prefer: read-eventual-consistent : API client prefers that API server returns response from either cache or presumably eventually consistent datastore if applicable. If there is a miss in finding the data from either of these two types of sources, the API server might return response from a consistent, durable datastore. Prefer: read-cache : API client prefers that API server returns response from cache if available. If the cache hit is a miss, the server could return response from other sources such as eventual consistent datastore or a consistent, durable datastore. Prefer: return=representation : API client prefers that API server include an entity representing the current state of the resource in the response to a successful request. This preference is intended to provide a means of optimizing communication between the client and server by eliminating the need for a subsequent GET request to retrieve the current representation of the resource following a creation (POST) modification operation (PUT or PATCH). Prefer: return=minimal : API client indicates that the server returns only a minimal response to a successful request. The determination of what constitutes an appropriate \u201cminimal\u201d response is solely at the discretion of the server. ETag Entity tags (ETag) is a good approach to make update requests idempotent. ETags are generated by the server based on the current resource representation. If-Match Using the If-Match header with the current ETag value representing the current resource state allows the server to provide idempotent operations and avoid race conditions. The server would only execute the update if the If-Match value matches current ETag for the resource. HTTP Custom Headers There are instances where custom headers may be required to send additional information such as a Correlation Id or Request Id to the server/client. With respect to HTTP custom header naming conventions, the X- prefix has been deprecated (see RFC 6648 ) and it is now recommended to simply name custom headers with something of relevance without the X- prefix, for example; Idempotency-Key: cf172aa2-fddf-11ea-adc1-0242ac120002 Idempotency-Key API consumers MAY choose to send this header with a unique ID identifying the request header for tracking purpose. Such a header can be used internally for logging and tracking purpose too. It is RECOMMENDED to send this header back as a response header if response is asynchronous or as request header of a webhook as applicable. HTTP Header Propagation When services receive request headers, they MUST pass on relevant custom headers in addition to the HTTP standard headers in requests/messages dispatched to secondary systems.","title":"Methods, Headers, and Statuses"},{"location":"unified/methods/#http-methods-headers-and-statuses","text":"","title":"HTTP Methods, Headers, and Statuses"},{"location":"unified/methods/#data-resources-and-http-methods","text":"Various business capabilities of an organization are exposed through APIs as a set of resources.","title":"Data Resources And HTTP Methods"},{"location":"unified/methods/#business-capabilities-and-resource-modeling","text":"Functionality MUST NOT be duplicated across APIs. Resources (e.g. user account, credit card, etc.) are expected to be re-used as needed across use-cases.","title":"Business Capabilities and Resource Modeling"},{"location":"unified/methods/#http-methods","text":"Most services will fall easily into the standard data resource model where primary operations can be represented by the acronym CRUD (Create, Read, Update, and Delete). These map very well to standard HTTP verbs. HTTP Method Description GET To retrieve a resource. POST To create a resource, or to execute a complex operation on a resource. DELETE To delete a resource. PATCH* To perform a partial update to a resource. PUT To update a resource. NOTE: We recommend against using PATCH because of the potential complications arising from the semantics and race conditions of a partial record update. In general, we prefer using PUT to ensure atomic updates to a resource, and matching version numbers or last-updated timestamps to avoid race conditions.","title":"HTTP Methods"},{"location":"unified/methods/#processing","text":"The actual operation invoked MUST match the HTTP method semantics as defined in the table above. The GET method MUST NOT have side effects. It MUST NOT change the state of an underlying resource. The POST method SHOULD be used to create a new resource in a collection. Example: To add a credit card on file, POST https://api.example.com/v1/vault/credit-cards Idempotency semantics: If this is a subsequent execution of the same invocation (including the Idempotency-Key header) and the resource was already created, then the request SHOULD be idempotent. The POST method SHOULD be used to create a new sub-resource and establish its relationship with the main resource. Example: To refund a payment with transaction ID 12345: POST https://api.example.com/v1/payments/12345/refund The POST method MAY be used in complex operations, along with the name of the operation. This is also known as the controller pattern and is considered an exception to the RESTful model. It is more applicable in cases when resources represent a business process, and operations are the steps or actions to be performed as part of it. For more information, please refer to section 2.6 of the RESTful Web Services Cookbook . The PUT method SHOULD be used to update resource attributes or to establish a relationship from a resource to an existing sub-resource; it updates the main resource with a reference to the sub-resource. Unless otherwise noted, request and response bodies MUST be sent using JavaScript Object Notation (JSON) . JSON is a light-weight data representation for an object composed of unordered key-value pairs. JSON can represent four primitive types (strings, numbers, booleans, and null) and two structured types (objects and arrays). When processing an API method call, the following guidelines SHOULD be followed.","title":"Processing"},{"location":"unified/methods/#data-model","text":"The data model for representation MUST conform to the JSON Data Interchange Format as described in RFC 7159 .","title":"Data Model"},{"location":"unified/methods/#serialization","text":"Resource endpoints MUST support application/json as content type. If an Accept header is sent and application/json is not an acceptable response, a 406 Not Acceptable error MUST be returned.","title":"Serialization"},{"location":"unified/methods/#input-and-output-strictness","text":"APIs MUST be strict in the information they produce, and they SHOULD be strict in what they consume as well. Since we are dealing with programming interfaces, we need to avoid guessing the meaning of what is being sent to us as much as possible. Given that integration is typically a one-time task for a developer and we provide good documentation, we need to be strict with using the data that is being received. Postel\u2019s law must be weighed against the many dangers of permissive parsing. In order to improve developer experience, the APIs SHOULD provide feedback if we don\u2019t understand the fields that the user is sending us.","title":"Input and Output Strictness"},{"location":"unified/methods/#http-header-policies","text":"The purpose of HTTP headers is to provide metadata information about the body or the sender of the message in a uniform, standardized, and isolated way.","title":"HTTP Header Policies"},{"location":"unified/methods/#assumptions","text":"Service Consumers and Service Providers: SHOULD NOT expect that a particular HTTP header is available. It is possible that an intermediary component in the call chain can drop an HTTP header. This is the reason business logic SHOULD NOT be based on HTTP headers. SHOULD NOT assume the value of a header has not been changed as part of HTTP message transmission. Infrastructure Components (Web-services framework, Client invocation library, Enterprise Service Bus (ESB), Load Balancers (LB), etc. involved in HTTP message delivery): MAY return an error based on availability and validity of a particular header without transmitting the message forward. For example, an authentication or authorization error for a request based on client identity and credentials. MAY add, remove, or change a value of an HTTP header.","title":"Assumptions"},{"location":"unified/methods/#policies","text":"The guidelines below should be applied when adding HTTP headers to client requests or server responses. If available, HTTP standard headers MUST be used instead of creating a custom header. HTTP header names are NOT case sensitive. HTTP headers SHOULD only be used for the purpose of handling cross-cutting concerns such as Authorization. API implementations SHOULD NOT introduce or depend on headers. API implementations MUST NOT use headers in a way that changes the behaviour of HTTP methods API implementations MUST NOT use headers to communicate business logic or service logic (e.g. paging response info, PII query parameters)","title":"Policies"},{"location":"unified/methods/#http-standard-headers","text":"These are headers defined or referenced from HTTP/1.1 specification ( RFC 7231 ). Their purpose, syntax, values, and semantics are well-defined and understood by many infrastructure components.","title":"HTTP Standard Headers"},{"location":"unified/methods/#accept","text":"This request header specifies the media types that the API client is capable of handling in the response. Systems issuing the HTTP request SHOULD send this header. Systems handling the request SHOULD NOT assume it is available. It is assumed throughout these API guidelines that APIs accept application/json .","title":"Accept"},{"location":"unified/methods/#accept-charset","text":"This request header specifies what character sets the API client is capable of handling in the response. The value of Accept-Charset SHOULD include utf-8.","title":"Accept-Charset"},{"location":"unified/methods/#content-language","text":"This request/response header is used to specify the language of the content. The default locale is en-US. API clients SHOULD identify the language of the data using Content-Language header. APIs MUST provide this header in the response. Example: Content-Language: en-US","title":"Content-Language"},{"location":"unified/methods/#content-type","text":"This request/response header indicates the media type of the request or response body. API client MUST include with request if the request contains a body, e.g. it is a POST request. API developer MUST include it with response if a response body is included (not used with 204 responses). If the content is a text-based type, such as JSON, the Content-Type MUST include a character-set parameter. The character-set MUST be UTF-8 . The only supported media type for now is application/json. Example: (in HTTP request) Accept: application/json; Accept-Charset: utf-8 (in HTTP response) Content-Type: application/json; charset=utf-8","title":"Content-Type"},{"location":"unified/methods/#link","text":"According to Web Linking RFC 5988 , a link is a typed connection between two resources that are identified by Internationalised Resource Identifiers (IRIs). The Link entity-header field provides a means for serializing one or more links in HTTP headers. APIs SHOULD be built with a design assumption that neither an API, nor an API client\u2019s business logic should depend on information provided in the headers. Headers must only be used to carry cross-cutting concern information such as security, traceability, monitoring, etc. Therefore, usage of the Link header is prohibited with response codes 201 or 3xx. Consider using HATEOAS links in the response body instead.","title":"Link"},{"location":"unified/methods/#location","text":"This response-header field is used to redirect the recipient to a location other than the Request-URI for completion of the request or identification of a new resource. APIs SHOULD be built with a design assumption that neither an API, nor an API client\u2019s business logic should depend on information provided in the headers. Headers must only be used to carry cross-cutting concern information such as security, traceability, monitoring, etc. Therefore, usage of the Location header is prohibited with response codes 201 or 3xx. Consider using HATEOAS links in the response body instead.","title":"Location"},{"location":"unified/methods/#prefer","text":"The Prefer request header field is used to indicate that a particular server behavior(s) is preferred by the client but is not required for successful completion of the request. It is an end to end field and MUST be forwarded by a proxy if the request is forwarded unless Prefer is explicitly identified as being hop by hop using the Connection header field. Following token values are possible to use for APIs provided an API documentation explicitly indicates support for Prefer . Prefer: respond-async : API client prefers that API server processes its request asynchronously. Server returns a 202 Accepted response and processes the request asynchronously. API server could use a webhook to inform the client subsequently, or the client may call GET to get the response at a later time. Refer to Asynchronous Operations for more details. Prefer: read-consistent : API client prefers that API server returns response from a durable store with consistent data. For APIs that are not offering any optimization preferences for their clients, this behavior would be the default and it would not require the client to set this token. Prefer: read-eventual-consistent : API client prefers that API server returns response from either cache or presumably eventually consistent datastore if applicable. If there is a miss in finding the data from either of these two types of sources, the API server might return response from a consistent, durable datastore. Prefer: read-cache : API client prefers that API server returns response from cache if available. If the cache hit is a miss, the server could return response from other sources such as eventual consistent datastore or a consistent, durable datastore. Prefer: return=representation : API client prefers that API server include an entity representing the current state of the resource in the response to a successful request. This preference is intended to provide a means of optimizing communication between the client and server by eliminating the need for a subsequent GET request to retrieve the current representation of the resource following a creation (POST) modification operation (PUT or PATCH). Prefer: return=minimal : API client indicates that the server returns only a minimal response to a successful request. The determination of what constitutes an appropriate \u201cminimal\u201d response is solely at the discretion of the server.","title":"Prefer"},{"location":"unified/methods/#etag","text":"Entity tags (ETag) is a good approach to make update requests idempotent. ETags are generated by the server based on the current resource representation.","title":"ETag"},{"location":"unified/methods/#if-match","text":"Using the If-Match header with the current ETag value representing the current resource state allows the server to provide idempotent operations and avoid race conditions. The server would only execute the update if the If-Match value matches current ETag for the resource.","title":"If-Match"},{"location":"unified/methods/#http-custom-headers","text":"There are instances where custom headers may be required to send additional information such as a Correlation Id or Request Id to the server/client. With respect to HTTP custom header naming conventions, the X- prefix has been deprecated (see RFC 6648 ) and it is now recommended to simply name custom headers with something of relevance without the X- prefix, for example; Idempotency-Key: cf172aa2-fddf-11ea-adc1-0242ac120002","title":"HTTP Custom Headers"},{"location":"unified/methods/#idempotency-key","text":"API consumers MAY choose to send this header with a unique ID identifying the request header for tracking purpose. Such a header can be used internally for logging and tracking purpose too. It is RECOMMENDED to send this header back as a response header if response is asynchronous or as request header of a webhook as applicable.","title":"Idempotency-Key"},{"location":"unified/methods/#http-header-propagation","text":"When services receive request headers, they MUST pass on relevant custom headers in addition to the HTTP standard headers in requests/messages dispatched to secondary systems.","title":"HTTP Header Propagation"},{"location":"unified/naming-conventions/","text":"Naming Conventions Naming conventions for URIs, query parameters, resources, fields and enums are described in this section. Let us emphasize here that these guidelines are less about following the conventions exactly as described here but they are more about defining some naming conventions and sticking to them in a consistent manner while designing APIs. Adhering to a defined convention across APIs provides the best consumer experience. Payload Naming Conventions The data model for the representation MUST conform to JSON. The values may themselves be objects, strings, numbers, booleans, or arrays of objects. Case Conventions We have followed camelCase for field property names, based on research . We have followed kebab-case for components of the URL path as that seems to be the predominant style. It is possible to use other forms such as snake_case or something else that you have devised yourself. However, as noted above, any deviations from consistent API style erode the usability and effectiveness of the APIs as a whole. Use Case Case Convention URI kebab-case Query parameters camelCase JSON properties camelCase Enumerated values SNAKE_CASE_IN_CAPS Field Names Key names MUST be lower-case words. If compound words, MUST follow camelCase. foo barBaz Prefix such as is* or has_ SHOULD NOT be used for keys of type boolean. Fields that represent arrays SHOULD be named using plural nouns products - contains one or more products. Enum Names Entries (values) of an enum SHOULD be composed of only upper-case alphanumeric characters and the underscore character, ( _ ). FIELD_10 NOT_EQUAL If there is an industry standard that requires us to do otherwise, enums MAY contain other characters. Link Relation Names A link relation type represented by rel must be in lower-case. Example: { \"links\": [ { \"href\": \"https://uri.example.com/v1/customer/partner-referrals/ALT-JFWXHGUV7VI/activate\", \"rel\": \"activate\", \"method\": \"POST\" } ] } File Names JSON schema for various types used by API SHOULD each be contained in separate files, referenced using the $ref syntax (e.g. \"$ref\":\"object.json\" ). JSON Schema files SHOULD use underscore naming syntax, e.g. transaction_history.json . URI Naming Conventions URIs follow RFC 3986 specification. This specification simplifies REST API service development and consumption. The guidelines in this section govern your URI structure and semantics following the RFC 3986 constraints. URI Components According to RFC 3986 , the generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment as shown in example below. An API\u2019s resource path consists of URI\u2019s path, query and fragment components. It would include API\u2019s major version followed by namespace, resource name and optionally one or more sub-resources. For example, consider the following URI. https://api.example.com/v1/vault/credit-cards/7LT50814996/charges?merchantId=8FW3C1AB \\___/\\________________/\\________________________________________/\\__________________/ | | | | scheme authority path query \\_/\\____/\\___________/\\__________/\\______/\\_________/\\_______/ | | | | | | | version | resource {id} | parameter {value} namespace subresource Following table lists various pieces of the above URI: Component Path Piece Description Definition scheme https Request protocol The protocol defines how the client and server communicate the request / reply. authority api.example.com Server The domain name of the server offering the service. path v1/..../charges Resource Path The location of the resource being queried. query merchantId=8F33C1AB Query filter The filter criteria we wish to use as the criteria for filtering results from the collection. Following table lists various pieces of the above URI's resource path (including the query): Component Path Piece Description Definition version v1 Specifies major version 1 of the API The API major version is used to distinguish between two backward-incompatible versions of the same API. The API major version is an integer value which MUST be included as part of the URI. namespace vault Business Domain Namespace identifiers are used to provide a context and scope for resources. They are determined by logical boundaries in the business capability model implemented by the API platform. resource credit-cards Resource name If the resource name represents a collection of resources, then the GET method on the resource should retrieve the list of resources. Query parameters should be used to specify the search criteria. {id} 7LT50814996 Resource ID To retrieve a particular resource out of the collection, a resource ID MUST be specified as part of the URI. Sub-resources are discussed below. subresource charges Sub-Resource name If the sub-resource name represents a collection of resources, then the GET method on the resource should retrieve the list of resources. Query parameters should be used to specify the search criteria. parameter merchantId Property Name The property we wish to use as the criteria for filtering results from the collection. {value} 8FW3C1AB Filter value To retrieve a particular set of resources out of the collection, a filter value MUST be specified as part of the URI to restrict the data included in the collection. Formal Definition Term Definition URI [end-point] \u2018/\u2019 resource-path [\u2019?'query] end-point [scheme \u201c://\u201d] host [\u2019:\u2019 port]] scheme http or https resource-path \u201c/v\u201d version \u2018/\u2019 namespace-name \u2018/\u2019 resource (\u2019/\u2019 resource) resource resource-name [\u2019/\u2019 resource-id] resource-name Alpha (Alpha | Digit | \u2018-\u2019)* resource-id value query name \u2018=\u2019 value (\u2019&\u2019 name = value)* name Alpha (Alpha | Digit | \u2018_\u2019)* value URI Percent encoded value Legend: ' Surround a special character with single quotes \" Surround strings with double quotes () Use parentheses for grouping [] Use brackets to specify optional expressions An expression can be repeated zero or more times URI Component Names Following is a brief description of the URI specific naming convention guidelines for APIs. This specification uses the following notation to denote special meaning: parentheses \u201c( )\u201d to group an asterisk \" * \" to specify zero or more occurrences brackets \u201c[ ]\u201d for optional fields. [scheme]://[host][':'port]]\"v{major-version}/{namespace}/{resource}(/{sub-resource})* ?{query} URIs MUST start with a letter and use only lower-case letters. Literals/expressions in URI paths SHOULD be separated using a hyphen ( - ). Literals/expressions in query strings SHOULD be expressed in camelCase. URI paths and query strings MUST percent encode data into UTF-8 octets. Plural nouns SHOULD be used in the URI where appropriate to identify collections of data resources. /invoices /statements An individual resource in a collection of resources MAY exist directly beneath the collection URI. /invoices/{invoiceId} Sub-resource collections MAY exist directly beneath an individual resource. This should convey a relationship to another collection of resources (invoice-items, in this example). /invoices/{invoiceId}/items Sub-resource individual resources MAY exist, but should be avoided in favor of top-level resources. /invoices/{invoiceId}/items/{itemId} Better: /invoice-items/{invoiceItemId} Resource identifiers SHOULD follow recommendations described in the subsequent section. Examples: https://api.example.com/v1/vault/credit-cards https://api.example.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA https://api.example.com/v1/payments/billing-agreements/I-V8SSE9WLJGY6/re-activate Resource Names When modeling a service as a set of resources, developers MUST follow these principles: Nouns MUST be used, not verbs. Resource names MUST be singular for singletons; collections\u2019 names MUST be plural. Given a description of the automatic payments configuration on a user\u2019s account GET /autopay returns the full representation Given a collection of hypothetical charges: GET /charges returns a list of charges that have been made POST /charges creates a new charge resource, /charges/1234 GET /charges/1234 returns a full representation of a single charge Resource names MUST be lower-case and use only alphanumeric characters and hyphens. The hyphen character, ( - ), MUST be used as a word separator in URI path literals. Note that this is the only place where hyphens are used as a word separator. In nearly all other situations, camelCase formatting, MUST be used. Query Parameter Names Literals/expressions in query strings SHOULD be formatted using camelCase. Query parameters values MUST be percent-encoded. Query parameters MUST start with a letter. Only alpha characters and digits character SHALL be used. Query parameters SHOULD be optional. Some query parameter names are reserved, as indicated in Resource Collections. For more specific info on the query parameter usage, see URI Standards. Sub-Resources Sub-resources represent a relationship from one resource to another. The sub-resource name provides a meaning for the relationship. If cardinality is 1:1, then no additional information is required. Otherwise, the sub-resource SHOULD provide a sub-resource ID for unique identification. If cardinality is 1:many, then all the sub-resources will be returned. No more than two levels of sub-resources SHOULD be supported. Example Description GET https://api.example.com/v1/customer-support/disputes/ABCD1234/documents This call should return all the documents associated with dispute ABCD1234. GET https://api.example.com/v1/customer-support/disputes/ABCD1234/documents/102030 This call should return only the details for a particular document associated with this dispute. Keep in mind that this is only an illustrative example to show how to use sub-resource IDs. In practice, two step invocations SHOULD be avoided. If the second identifier is unique, top-level resource (e.g. /v1/customer-support/documents/102030 ) is preferred. GET https://api.example.com/v1/customer-support/disputes/ABCD1234/transactions The following example should return all the transactions associated with this dispute and their details, so there SHOULD NOT be a need to specify a particular transaction ID. If specific transaction ID retrieval is needed, /v1/customer-support/transactions/ABCD1234 is preferred (assuming IDs are unique). Resource Identifiers Resource identifiers identify a resource or a sub-resource. These MUST conform to the following guidelines. The lifecycle of a resource identifier MUST be owned by the resource\u2019s domain model, where they can be guaranteed to uniquely identify a single resource. APIs MUST NOT use the database sequence number as the resource identifier. A UUID, Hashed Id (HMAC based) is preferred as a resource identifier. For security and data integrity reasons all sub-resource IDs MUST be scoped within the parent resource only. Example: /users/1234/linked-accounts/ABCD Even if account \u201cABCD\u201d exists, it MUST NOT be returned unless it is linked to user: 1234. Enumeration values can be used as sub-resource IDs. String representation of the enumeration value SHOULD be used. There MUST NOT be two resource identifiers one after the other. Example: https://api.example.com/v1/transactions/payments/12345/102030 Resource IDs SHOULD try to use either Resource Identifier Characters or ASCII characters. There SHOULD NOT be any ID using UTF-8 characters. Resource IDs and query parameter values MUST perform URI percent-encoding for any character other than URI unreserved characters. Query parameter values using UTF-8 characters MUST be encoded. Query Parameters Query parameters are name/value pairs specified after the resource path, as prescribed in RFC 3986. Naming Conventions should also be followed when applying the following section. Filter a resource collection Query parameters SHOULD be used only for the purpose of restricting the resource collection or as search or filtering criteria. The resource identifier in a collection SHOULD NOT be used to filter collection results, resource identifier should be in the URI. Parameters for pagination SHOULD follow standard naming convention guidelines. Default sort order SHOULD be considered as undefined and non-deterministic. If an explicit sort order is desired, the query parameter sort SHOULD be used with the following general syntax: {fieldName}|{asc|desc},{fieldName}|{asc|desc} . For instance: /accounts?sort=dateOfBirth|asc,zipCode|desc Query parameters on a single resource In typical cases where one resource is utilized (e.g. /v1/payments/billing-plans/P-94458432VR012762KRWBZEUA ), query parameters SHOULD NOT be used. Cache-friendly APIs In rare cases where a resource needs to be highly cacheable (usually data with minimal change), query parameters MAY be utilized as opposed to POST + request body. As POST would make the response uncacheable, GET is preferred in these situations. This is the only scenario in which query parameters MAY be required. Query parameters with POST When POST is utilized for an operation, query parameters are usually NOT RECOMMENDED in favor of request body fields. In cases where POST provides paged results (typically in complex search APIs where GET is not appropriate), query parameters MAY be used in order to provide hypermedia links to the next page of results. Passing multiple values for the same query parameter When using query parameters for search functionality, it is often necessary to pass multiple values. For instance, it might be the case that a resource could have many states, such as OPEN, CLOSED, and INVALID. What if an API client wants to find all items that are either CLOSED or INVALID? It is RECOMMENDED that APIs implement this functionality by repeating the query parameter. This is inherently supported by HTTP standards and already built in to most client libraries. The query above would be implemented as ?status=CLOSED&status=INVALID . The parameter MUST be marked as repeatable in API specifications using \"repeated\": true in the parameter\u2019s definition section. The parameter\u2019s name SHOULD be singular. URIs have practical length limits that are quite low - most conservatively, about 2,000 characters . Therefore, there are situations where API designers MAY choose to use a single query parameter that accepts comma-separated values in order to accommodate more values in the query-string . Keep in mind that server and client libraries don\u2019t consistently provide this functionality, which means that implementers will need to write additional string parsing code. Due to the additional complexity and divergence from HTTP standards, this solution is NOT RECOMMENDED unless justified. The query above would be implemented as ?statuses=CLOSED,INVALID . The parameter MUST NOT be marked as repeatable in API specifications. The parameter MUST be marked as \"type\": \"string\" in API specifications in order to accommodate comma-separated values. Any other type value MUST NOT be used. The parameter description SHOULD indicate that comma separated values are accepted. The query-parameter name SHOULD be plural, to provide a hint that this pattern is being employed. The comma character (Unicode U+002C) SHOULD be used as the separator between values. The API documentation MUST define how to escape the separator character, if necessary. Complex Queries The syntax defined above is sufficient to provide simple filter capabilities within the URL path. At a certain point, the complexity of desired queries grows beyond our ability to reasonably express within the URL. This complexity could be driven by a variety of domain, design, or organizational dynamics. No matter the cause, re-examine your API before embarking on the creation of a complex query model to include as a request payload. It may be possible to refactor the API, or provide more specialized endpoints suited to the use-case. It may also be possible to refactor the domain context, either splitting the domain, or identifying a higher-level concept better suited to the use-case. NOTE: The one exception to this rule is when considering the inclusion of PII in query parameters. For these cases, it is recommended to provide a simple query payload for use in a POST request. This provides a mechanism to avoid including PII in the URL (and the associated dangers of logging or otherwise accidentally exposing PII).","title":"Naming Conventions"},{"location":"unified/naming-conventions/#naming-conventions","text":"Naming conventions for URIs, query parameters, resources, fields and enums are described in this section. Let us emphasize here that these guidelines are less about following the conventions exactly as described here but they are more about defining some naming conventions and sticking to them in a consistent manner while designing APIs. Adhering to a defined convention across APIs provides the best consumer experience.","title":"Naming Conventions"},{"location":"unified/naming-conventions/#payload-naming-conventions","text":"The data model for the representation MUST conform to JSON. The values may themselves be objects, strings, numbers, booleans, or arrays of objects.","title":"Payload Naming Conventions"},{"location":"unified/naming-conventions/#case-conventions","text":"We have followed camelCase for field property names, based on research . We have followed kebab-case for components of the URL path as that seems to be the predominant style. It is possible to use other forms such as snake_case or something else that you have devised yourself. However, as noted above, any deviations from consistent API style erode the usability and effectiveness of the APIs as a whole. Use Case Case Convention URI kebab-case Query parameters camelCase JSON properties camelCase Enumerated values SNAKE_CASE_IN_CAPS","title":"Case Conventions"},{"location":"unified/naming-conventions/#field-names","text":"Key names MUST be lower-case words. If compound words, MUST follow camelCase. foo barBaz Prefix such as is* or has_ SHOULD NOT be used for keys of type boolean. Fields that represent arrays SHOULD be named using plural nouns products - contains one or more products.","title":"Field Names"},{"location":"unified/naming-conventions/#enum-names","text":"Entries (values) of an enum SHOULD be composed of only upper-case alphanumeric characters and the underscore character, ( _ ). FIELD_10 NOT_EQUAL If there is an industry standard that requires us to do otherwise, enums MAY contain other characters.","title":"Enum Names"},{"location":"unified/naming-conventions/#link-relation-names","text":"A link relation type represented by rel must be in lower-case.","title":"Link Relation Names"},{"location":"unified/naming-conventions/#example","text":"{ \"links\": [ { \"href\": \"https://uri.example.com/v1/customer/partner-referrals/ALT-JFWXHGUV7VI/activate\", \"rel\": \"activate\", \"method\": \"POST\" } ] }","title":"Example:"},{"location":"unified/naming-conventions/#file-names","text":"JSON schema for various types used by API SHOULD each be contained in separate files, referenced using the $ref syntax (e.g. \"$ref\":\"object.json\" ). JSON Schema files SHOULD use underscore naming syntax, e.g. transaction_history.json .","title":"File Names"},{"location":"unified/naming-conventions/#uri-naming-conventions","text":"URIs follow RFC 3986 specification. This specification simplifies REST API service development and consumption. The guidelines in this section govern your URI structure and semantics following the RFC 3986 constraints.","title":"URI Naming Conventions"},{"location":"unified/naming-conventions/#uri-components","text":"According to RFC 3986 , the generic URI syntax consists of a hierarchical sequence of components referred to as the scheme, authority, path, query, and fragment as shown in example below. An API\u2019s resource path consists of URI\u2019s path, query and fragment components. It would include API\u2019s major version followed by namespace, resource name and optionally one or more sub-resources. For example, consider the following URI. https://api.example.com/v1/vault/credit-cards/7LT50814996/charges?merchantId=8FW3C1AB \\___/\\________________/\\________________________________________/\\__________________/ | | | | scheme authority path query \\_/\\____/\\___________/\\__________/\\______/\\_________/\\_______/ | | | | | | | version | resource {id} | parameter {value} namespace subresource Following table lists various pieces of the above URI: Component Path Piece Description Definition scheme https Request protocol The protocol defines how the client and server communicate the request / reply. authority api.example.com Server The domain name of the server offering the service. path v1/..../charges Resource Path The location of the resource being queried. query merchantId=8F33C1AB Query filter The filter criteria we wish to use as the criteria for filtering results from the collection. Following table lists various pieces of the above URI's resource path (including the query): Component Path Piece Description Definition version v1 Specifies major version 1 of the API The API major version is used to distinguish between two backward-incompatible versions of the same API. The API major version is an integer value which MUST be included as part of the URI. namespace vault Business Domain Namespace identifiers are used to provide a context and scope for resources. They are determined by logical boundaries in the business capability model implemented by the API platform. resource credit-cards Resource name If the resource name represents a collection of resources, then the GET method on the resource should retrieve the list of resources. Query parameters should be used to specify the search criteria. {id} 7LT50814996 Resource ID To retrieve a particular resource out of the collection, a resource ID MUST be specified as part of the URI. Sub-resources are discussed below. subresource charges Sub-Resource name If the sub-resource name represents a collection of resources, then the GET method on the resource should retrieve the list of resources. Query parameters should be used to specify the search criteria. parameter merchantId Property Name The property we wish to use as the criteria for filtering results from the collection. {value} 8FW3C1AB Filter value To retrieve a particular set of resources out of the collection, a filter value MUST be specified as part of the URI to restrict the data included in the collection.","title":"URI Components"},{"location":"unified/naming-conventions/#formal-definition","text":"Term Definition URI [end-point] \u2018/\u2019 resource-path [\u2019?'query] end-point [scheme \u201c://\u201d] host [\u2019:\u2019 port]] scheme http or https resource-path \u201c/v\u201d version \u2018/\u2019 namespace-name \u2018/\u2019 resource (\u2019/\u2019 resource) resource resource-name [\u2019/\u2019 resource-id] resource-name Alpha (Alpha | Digit | \u2018-\u2019)* resource-id value query name \u2018=\u2019 value (\u2019&\u2019 name = value)* name Alpha (Alpha | Digit | \u2018_\u2019)* value URI Percent encoded value Legend: ' Surround a special character with single quotes \" Surround strings with double quotes () Use parentheses for grouping [] Use brackets to specify optional expressions An expression can be repeated zero or more times","title":"Formal Definition"},{"location":"unified/naming-conventions/#uri-component-names","text":"Following is a brief description of the URI specific naming convention guidelines for APIs. This specification uses the following notation to denote special meaning: parentheses \u201c( )\u201d to group an asterisk \" * \" to specify zero or more occurrences brackets \u201c[ ]\u201d for optional fields. [scheme]://[host][':'port]]\"v{major-version}/{namespace}/{resource}(/{sub-resource})* ?{query} URIs MUST start with a letter and use only lower-case letters. Literals/expressions in URI paths SHOULD be separated using a hyphen ( - ). Literals/expressions in query strings SHOULD be expressed in camelCase. URI paths and query strings MUST percent encode data into UTF-8 octets. Plural nouns SHOULD be used in the URI where appropriate to identify collections of data resources. /invoices /statements An individual resource in a collection of resources MAY exist directly beneath the collection URI. /invoices/{invoiceId} Sub-resource collections MAY exist directly beneath an individual resource. This should convey a relationship to another collection of resources (invoice-items, in this example). /invoices/{invoiceId}/items Sub-resource individual resources MAY exist, but should be avoided in favor of top-level resources. /invoices/{invoiceId}/items/{itemId} Better: /invoice-items/{invoiceItemId} Resource identifiers SHOULD follow recommendations described in the subsequent section.","title":"URI Component Names"},{"location":"unified/naming-conventions/#examples","text":"https://api.example.com/v1/vault/credit-cards https://api.example.com/v1/vault/credit-cards/CARD-7LT50814996943336KESEVWA https://api.example.com/v1/payments/billing-agreements/I-V8SSE9WLJGY6/re-activate","title":"Examples:"},{"location":"unified/naming-conventions/#resource-names","text":"When modeling a service as a set of resources, developers MUST follow these principles: Nouns MUST be used, not verbs. Resource names MUST be singular for singletons; collections\u2019 names MUST be plural. Given a description of the automatic payments configuration on a user\u2019s account GET /autopay returns the full representation Given a collection of hypothetical charges: GET /charges returns a list of charges that have been made POST /charges creates a new charge resource, /charges/1234 GET /charges/1234 returns a full representation of a single charge Resource names MUST be lower-case and use only alphanumeric characters and hyphens. The hyphen character, ( - ), MUST be used as a word separator in URI path literals. Note that this is the only place where hyphens are used as a word separator. In nearly all other situations, camelCase formatting, MUST be used.","title":"Resource Names"},{"location":"unified/naming-conventions/#query-parameter-names","text":"Literals/expressions in query strings SHOULD be formatted using camelCase. Query parameters values MUST be percent-encoded. Query parameters MUST start with a letter. Only alpha characters and digits character SHALL be used. Query parameters SHOULD be optional. Some query parameter names are reserved, as indicated in Resource Collections. For more specific info on the query parameter usage, see URI Standards.","title":"Query Parameter Names"},{"location":"unified/naming-conventions/#sub-resources","text":"Sub-resources represent a relationship from one resource to another. The sub-resource name provides a meaning for the relationship. If cardinality is 1:1, then no additional information is required. Otherwise, the sub-resource SHOULD provide a sub-resource ID for unique identification. If cardinality is 1:many, then all the sub-resources will be returned. No more than two levels of sub-resources SHOULD be supported. Example Description GET https://api.example.com/v1/customer-support/disputes/ABCD1234/documents This call should return all the documents associated with dispute ABCD1234. GET https://api.example.com/v1/customer-support/disputes/ABCD1234/documents/102030 This call should return only the details for a particular document associated with this dispute. Keep in mind that this is only an illustrative example to show how to use sub-resource IDs. In practice, two step invocations SHOULD be avoided. If the second identifier is unique, top-level resource (e.g. /v1/customer-support/documents/102030 ) is preferred. GET https://api.example.com/v1/customer-support/disputes/ABCD1234/transactions The following example should return all the transactions associated with this dispute and their details, so there SHOULD NOT be a need to specify a particular transaction ID. If specific transaction ID retrieval is needed, /v1/customer-support/transactions/ABCD1234 is preferred (assuming IDs are unique).","title":"Sub-Resources"},{"location":"unified/naming-conventions/#resource-identifiers","text":"Resource identifiers identify a resource or a sub-resource. These MUST conform to the following guidelines. The lifecycle of a resource identifier MUST be owned by the resource\u2019s domain model, where they can be guaranteed to uniquely identify a single resource. APIs MUST NOT use the database sequence number as the resource identifier. A UUID, Hashed Id (HMAC based) is preferred as a resource identifier. For security and data integrity reasons all sub-resource IDs MUST be scoped within the parent resource only.","title":"Resource Identifiers"},{"location":"unified/naming-conventions/#example_1","text":"/users/1234/linked-accounts/ABCD Even if account \u201cABCD\u201d exists, it MUST NOT be returned unless it is linked to user: 1234. Enumeration values can be used as sub-resource IDs. String representation of the enumeration value SHOULD be used. There MUST NOT be two resource identifiers one after the other. Example: https://api.example.com/v1/transactions/payments/12345/102030 Resource IDs SHOULD try to use either Resource Identifier Characters or ASCII characters. There SHOULD NOT be any ID using UTF-8 characters. Resource IDs and query parameter values MUST perform URI percent-encoding for any character other than URI unreserved characters. Query parameter values using UTF-8 characters MUST be encoded.","title":"Example:"},{"location":"unified/naming-conventions/#query-parameters","text":"Query parameters are name/value pairs specified after the resource path, as prescribed in RFC 3986. Naming Conventions should also be followed when applying the following section.","title":"Query Parameters"},{"location":"unified/naming-conventions/#filter-a-resource-collection","text":"Query parameters SHOULD be used only for the purpose of restricting the resource collection or as search or filtering criteria. The resource identifier in a collection SHOULD NOT be used to filter collection results, resource identifier should be in the URI. Parameters for pagination SHOULD follow standard naming convention guidelines. Default sort order SHOULD be considered as undefined and non-deterministic. If an explicit sort order is desired, the query parameter sort SHOULD be used with the following general syntax: {fieldName}|{asc|desc},{fieldName}|{asc|desc} . For instance: /accounts?sort=dateOfBirth|asc,zipCode|desc","title":"Filter a resource collection"},{"location":"unified/naming-conventions/#query-parameters-on-a-single-resource","text":"In typical cases where one resource is utilized (e.g. /v1/payments/billing-plans/P-94458432VR012762KRWBZEUA ), query parameters SHOULD NOT be used.","title":"Query parameters on a single resource"},{"location":"unified/naming-conventions/#cache-friendly-apis","text":"In rare cases where a resource needs to be highly cacheable (usually data with minimal change), query parameters MAY be utilized as opposed to POST + request body. As POST would make the response uncacheable, GET is preferred in these situations. This is the only scenario in which query parameters MAY be required.","title":"Cache-friendly APIs"},{"location":"unified/naming-conventions/#query-parameters-with-post","text":"When POST is utilized for an operation, query parameters are usually NOT RECOMMENDED in favor of request body fields. In cases where POST provides paged results (typically in complex search APIs where GET is not appropriate), query parameters MAY be used in order to provide hypermedia links to the next page of results.","title":"Query parameters with POST"},{"location":"unified/naming-conventions/#passing-multiple-values-for-the-same-query-parameter","text":"When using query parameters for search functionality, it is often necessary to pass multiple values. For instance, it might be the case that a resource could have many states, such as OPEN, CLOSED, and INVALID. What if an API client wants to find all items that are either CLOSED or INVALID? It is RECOMMENDED that APIs implement this functionality by repeating the query parameter. This is inherently supported by HTTP standards and already built in to most client libraries. The query above would be implemented as ?status=CLOSED&status=INVALID . The parameter MUST be marked as repeatable in API specifications using \"repeated\": true in the parameter\u2019s definition section. The parameter\u2019s name SHOULD be singular. URIs have practical length limits that are quite low - most conservatively, about 2,000 characters . Therefore, there are situations where API designers MAY choose to use a single query parameter that accepts comma-separated values in order to accommodate more values in the query-string . Keep in mind that server and client libraries don\u2019t consistently provide this functionality, which means that implementers will need to write additional string parsing code. Due to the additional complexity and divergence from HTTP standards, this solution is NOT RECOMMENDED unless justified. The query above would be implemented as ?statuses=CLOSED,INVALID . The parameter MUST NOT be marked as repeatable in API specifications. The parameter MUST be marked as \"type\": \"string\" in API specifications in order to accommodate comma-separated values. Any other type value MUST NOT be used. The parameter description SHOULD indicate that comma separated values are accepted. The query-parameter name SHOULD be plural, to provide a hint that this pattern is being employed. The comma character (Unicode U+002C) SHOULD be used as the separator between values. The API documentation MUST define how to escape the separator character, if necessary.","title":"Passing multiple values for the same query parameter"},{"location":"unified/naming-conventions/#complex-queries","text":"The syntax defined above is sufficient to provide simple filter capabilities within the URL path. At a certain point, the complexity of desired queries grows beyond our ability to reasonably express within the URL. This complexity could be driven by a variety of domain, design, or organizational dynamics. No matter the cause, re-examine your API before embarking on the creation of a complex query model to include as a request payload. It may be possible to refactor the API, or provide more specialized endpoints suited to the use-case. It may also be possible to refactor the domain context, either splitting the domain, or identifying a higher-level concept better suited to the use-case. NOTE: The one exception to this rule is when considering the inclusion of PII in query parameters. For these cases, it is recommended to provide a simple query payload for use in a POST request. This provides a mechanism to avoid including PII in the URL (and the associated dangers of logging or otherwise accidentally exposing PII).","title":"Complex Queries"},{"location":"unified/payloads/","text":"HTTP Payload Standards Request / Response Body All request and response bodies across any REST resource operation are expected to serialize data according to the JSON Data Interchange Format described in RFC 7159 and JavaScript Object Notation (JSON) . JSON is built upon four primitive types ( string , number , boolean , and null ) and on two structures [5]: Object - A collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array. Array - An ordered list of values. In most languages, this is realized as an array, vector, list, or sequence. JSON responses must always return a JSON object (and not e.g. an array) as a top level data structure to support future extensibility [2]. Potential extensibility might include metadata such as paging, as an example. JSON Schema JSON Schema is a vocabulary that allows you to annotate and validate JSON documents. As of the writing of this style guide, the latest JSON Schema is version 2020-12 . OpenAPI spec defines an API\u2019s contract interface and the OpenAPI Schema Object is based on the JSON Schema. This enables the API provider to communicate JSON schema validation rules via OpenAPI spec. Refer to both of these specifications when documenting the contract interface for consumers. NOTE: json-schema.org seems to have dropped the Hypermedia specification from the 2012-12 version of the spec. This document continues to refer to the 2019-09 version . YMMV. API Contract Description There are various options available to define the API\u2019s contract interface (API specification or API description). Examples are: OpenAPI (fka Swagger), Google Discovery Document , RAML , API BluePrint and so on. OpenAPI is a vendor neutral API description format. The OpenAPI Schema Object (or OpenAPI JSON) is an extended subset of the JSON Schema Specification . In addition, there are extensions provided by the specification to allow for more complete documentation. It is RECOMMENDED to use the latest version of the OpenAPI specification. At the time of this writing, the latest version is v3.1. We have used OpenAPI to describe the API specification throughout this document. $schema Use $schema to indicate the version of JSON schema used by each JSON type you define as shown below. { \"type\": \"object\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema#\", \"name\": \"Order\", \"description\": \"An order transaction.\", \"properties\": { ... } } In case your JSON type uses links, media and other such keywords or schemas such as for linkDescription that are defined in http://json-schema.org/draft/2019-09/json-schema-hypermedia.html , you should provide the value for $schema accordingly as shown below. { \"type\": \"object\", \"$schema\": \"https://json-schema.org/draft/2019-09/hyper-schema#\", \"name\": \"Linked-Order\", \"description\": \"An order transaction using HATEOAS links.\", \"properties\": { ... } } If you are unsure about the specific schema version to refer to, it would be safe to refer https://json-schema.org/draft/2019-09/hyper-schema# schema since it would cover the hypermedia aspects of any JSON schema. readOnly: When resources contain immutable fields, PUT/PATCH operations can still be utilized to update that resource. To indicate immutable fields in the resource, the readOnly field can be specified on the immutable fields. Example: \"properties\": { \"id\": { \"type\": \"string\", \"description\": \"Identifier of the resource.\", \"readOnly\": true } } Advanced Syntax Guidance Be aware that anyOf/allOf/oneOf syntax can cause issues with tooling, as code generators, documentation tools and validation of these keywords is often not implemented. allOf The allOf keyword MUST only be used for the purposes listed here. Extend object The allOf keyword in JSON Schema SHOULD be used for extending objects. In draft-03, this was implemented with the extends keyword, which has been deprecated in draft-04. Example: A common need is to extend a common type with additional fields. In this example, we will extend the address with a typefield. \"shipping_address\": { \"\\$ref\": \"v1/schema/address.json\" } Using the allOf keyword, we can combine both the common type address schema and an extra schema snippet for the address type: \"shipping_address\": { \"allOf\": [ // Here, we include our \"core\" address schema... { \"\\$ref\": \"v1/schema/address.json\" }, // ...and then extend it with stuff specific to a shipping // address { \"properties\": { \"type\": { \"enum\": [ \"residential\", \"business\" ] } }, \"required\": [\"type\"] } ] } anyOf/oneOf The anyOf and oneOf keywords SHOULD NOT be used to design APIs. A variety of problems occur from these keywords: Codegen tools do not have an accurate way to generate models/objects from these definitions. Developer portals would have significant difficulty in clearly explaining to API consumers the meaning of these relationships. Consumers using statically typed languages (e.g. C#, Java) have a more complex experience trying to conditionally deserialize objects which change based on some element. Custom deserialization code is required to represent objects based on the response, standard libraries do not accommodate this out of the box. Flat structures which combine all possible fields in an object are automatically deserialized properly. anyOf/oneOf Problems: Example: { \"activityType\": { \"description\": \"The entity type of the item. One of 'PAYMENT', 'MONEY-REQUEST', 'RECURRING-PAYMENT-PROFILE', 'ORDER', 'PAYOUT', 'SUBSCRIPTION', 'INVOICE'\", \"type\": \"string\", \"enum\": [ \"PAYMENT\", \"MONEY-REQUEST\" ] }, \"extensions\": { \"type\": \"object\", \"description\": \"Extension to core activity fields\", \"oneOf\": [ { \"$ref\": \"v1/schema/extended_properties.json#/definitions/payment_properties\" }, { \"$ref\": \"v1/schema/extended_properties.json#/definitions/money_request_properties\" } ] } } In order for an API consumer to deserialize this response (where POJO/POCO objects are used), standard mechanisms would not work. Because the extensions field can change on any given response, the consumer is forced to create a composite object to represent both payment_properties.json and money_request_properties.json . A better approach: { \"activityType\": { \"description\": \"The entity type of the item. One of 'PAYMENT', 'MONEY-REQUEST', 'RECURRING-PAYMENT-PROFILE', 'ORDER', 'PAYOUT', 'SUBSCRIPTION', 'INVOICE'\", \"type\": \"string\", \"enum\": [ \"PAYMENT\", \"MONEY-REQUEST\" ] }, \"payment\": { \"type\": \"object\", \"description\": \"Payment-specific activity.\", \"$ref\": \"v1/schema/payment.json\" }, \"moneyRequest\": { \"type\": \"object\", \"description\": \"Money request-specific activity.\", \"$ref\": \"v1/schema/money_request.json\" } } In this scenario, both payment and moneyRequest are in the definition. However, in practice, only one field would be serialized based on the activityType . For API consumers, this is a very predictable response, and allows for easy deserialization through standard libraries, without writing custom deserializers. JSON Types This section provides guidelines related to usage of JSON primitive types as well as commonly useful JSON types for address, name, currency, money, country, phone, among other things. JSON Primitive Types JSON Schema 2020-12 SHOULD be used to define all fields in APIs. As such, the following notes about the JSON Schema primitive types SHOULD be respected. Following are the guidelines governing use of JSON primitive type representations. String At a minimum, strings SHOULD always explicitly define a minLength and maxLength . There are several reasons for doing so. Without a maximum length, it is impossible to reliably define a database column to store a given string. Without a maximum and minimum, it is also impossible to predict whether a change in length will break backwards-compatibility with existing clients. Finally, without a minimum length, it is often possible for clients to send an empty string when they should not be allowed to do so. APIs MAY avoid defining minLength and maxLength only if the string value is from another system of record that has refused to provide any information on these values. This decision must be documented in the schema. API authors SHOULD consider practical limitations when defining maxLength . For example, when using the VARCHAR2 type, modern versions of Oracle can safely store a Unicode string of no more than 1,000 characters. (The size limit is 4,000 bytes and each Unicode character may take up to four bytes for storage). string SHOULD utilize the pattern property as appropriate, especially when defining enumerated values or numbers. However, it is RECOMMENDED not to overly constrain fields without a valid technical reason. Enumeration The JSON Schema enum keyword is difficult to use safely. It is not possible to add new values to an enum in a schema that describes a service response without breaking backwards compatibility. In that scenario, clients will often reject responses with values that are not in the older copy of the schema that they possess. This is usually not the desired behavior. Clients should usually handle unknown values more gracefully, but since you can\u2019t control nor verify their behavior, it is not safe to add new enum values. For the reasons stated above, the schema author MUST comply with the following guidelines while using an enum with the JSON type string. The keyword enum SHOULD be used only when the set of values are fixed and would never change in future. If you anticipate adding new values to the enum array in future, avoid using the keyword enum. You SHOULD instead use a string type and document all acceptable values for the string. When using a string type to express enumerated values, you SHOULD enforce naming conventions through a pattern field. If there is no technical reason to do otherwise \u2013 for instance, a pre-existing database column of smaller size \u2013 maxLength should be set to 255. minLength should be set to 1 to prevent clients sending the empty string. All possible values of an enum field SHOULD be precisely defined in the documentation. If there is not enough space in the description field to do so, you SHOULD use the API\u2019s user guide to define them. Given below is the JSON snippet for enforcing naming conventions and length constraints. { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255, \"pattern\": \"^[0-9A-Z_]+\\$\", \"description\": \"A description of the field. The possible values are OPTION_ONE and OPTION_TWO.\" } Number There are a number of difficulties associated with number type in JSON. JSON itself defines a number very simply: it is an unbounded, fixed-point value. This is illustrated well by the railroad diagram for number at JSON . There is only one number type in JSON; there is no separate integer type. JSON Schema diverges from JSON and defines two number types: number and integer. This is purely a convenience for schema validation; the JSON number type is used to implement both. Just as in JSON, both types are unbounded unless the schema author provides explicit minimum and maximum values. Many programming languages do not safely handle unbounded values in JSON. JavaScript is an excellent example. A JSON deserializer is provided as part of the ECMAScript specification. However, it requires that all JSON numbers are deserialized into the only number type supported by JavaScript \u2013 64-bit floating point. This means that attempting to deserialize any JSON number larger than about 2 53 in a JavaScript client will result in an exception. To ensure the greatest degree of cross-client compatibility possible, schema authors SHOULD : Never use the JSON Schema number type. Some languages may interpret it as a fixed-point value, and some as floating-point. Always use string to represent a decimal value. Only define integer types for values that can be represented in a 32-bit signed integer, that is to say, values between ((2 31 ) - 1) and -(2 31 ). This ensures compatibility across a wide range of programming languages and circumstances. For example, array indices in JavaScript are signed 32-bit integers. When using an integer type, always provide an explicit minimum and a maximum. This not only allows backwards-incompatible changes to be detected, it also guarantees that all values can fit in a 32-bit signed integer. If there are no technical reasons to do otherwise, the maximum and minimum should be defined as 2147483647 (((2 31 ) - 1)) and -2147483648 (-(2 31 )) or 0 respectively. Common sense should be used to determine whether to allow negative values. Business logic that could change in the future generally SHOULD NOT be used to determine boundaries; business rules can easily change and break backwards compatibility. If there is any possibility that the value could not be represented by a signed 32-bit integer, now or in the future, not use the JSON Schema integer type. Use a string instead. Examples: This integer type might be used to define an array index or page count, or perhaps the number of months an account has been open. { \"type\": \"integer\", \"minimum\": 0, \"maximum\": 2147483647 } When using a string type to represent a number, authors MUST provide boundaries on size using minLength and maxLength , and constrain the definition of the string to only represent numbers using pattern. For example, this definition only allows positive integers and zero, with a maximum value of 999999: { \"type\": \"string\", \"pattern\": \"^[0-9]+\\$\", \"minLength\": 1, \"maxLength\": 6 } The following definition allows the representation of fixed-point decimal values both positive or negative, with a maximum length of 32 and no requirements on scale: { \"type\": \"string\", \"pattern\": \"^(-?[0-9]+|-?([0-9]+)?[.][0-9]+)$\", \"maxLength\": 32, \"minLength\": 1, } Array JSON defines an array as unbounded. Although practical limits are often much lower due to memory constraints, many programming languages do place maximum theoretical limits on the size of arrays. For example, JavaScript is limited to the length of a 32-bit unsigned integer by the ECMA-262 specification. Java is limited to about Integer.MAX_VALUE - 8 , which is less than half of JavaScript. To ensure maximum compatibility across languages and encourage paginated APIs, maxItems SHOULD always be defined by schema authors. maxItems SHOULD NOT have a value greater than can be represented by a 16-bit signed integer, in other words, 32767 or (2 15 ) - 1). Note that developers MAY choose to set a smaller value; the value 32767 is a default choice to be used when no better choice is available. However, developers SHOULD design their API for growth. For example, although a paginated API may only support a maximum of 100 results per page today, performance improvements may allow developers to improve that to 1,000 results next year. Therefore, maxItems SHOULD NOT be used to communicate maximum page size. minItems SHOULD also be defined. In most situations, its value will be either 0 or 1. Null APIs MUST NOT produce or consume null values. null is a primitive type in JSON. When validating a JSON document against JSON Schema, a property\u2019s value can be nullonly when it is explicitly allowed by the schema, using the type keyword (e.g. {\"type\": \"null\"} ). Since in an API type will always need to be defined to some other value such as object or string, and these standards prohibit using schema composition keywords such as anyOf or oneOf that allow multiple types, if an API produces or consumes null values, it is unlikely that, according to the API\u2019s own schemas, this is actually valid data. In addition, in JSON, a property that doesn\u2019t exist or is missing in the object is considered to be undefined; this is conceptually separate from a property that is defined with a value of null, but many programming languages have difficulty drawing this distinction. For example, a property my_property defined as {\"type\": \"null\"} is represented as { \"myProperty\": null } While a property that is undefined would not be present in the object: { } In most strongly typed languages, such as Java, there is no concept of an undefined type, which means that for all undefined fields in a JSON object, a deserializer would return the value of such types as null when you try to retrieve them. Similarly, some Java-based JSON serializers serialize fields to JSON null by default, even though it is not possible for the serializer to determine whether the author of the Java object intended for that property to be defined with a value of null, or simply undefined. In Jackson, for example, this behavior is moderated through use of the JsonInclude annotation. On the other hand, the org.json library defines an object called NULL to distinguish between null and undefined. Eschewing JSON null completely helps avoid many of these subtle cross-language compatibility traps. Additional Properties Setting of additionalProperties to false in schema objects breaks backward compatibility in those clients that use an API\u2019s JSON schemas (defined by its contract) to validate the API requests and responses. For the same reason, the schema author MUST not explicitly set the additionalProperties to false. The API implementation SHOULD instead enforce the conformance of requests and responses to an API contract by hard validating the requests and responses against the defined API contract at run-time. Common Types Resource representations in API MUST reuse the common data type definitions where possible. The following sections provide some details about some of these common types. Quantity Future-proof quantities by including a unit-of-measure (UOM). It is recommended to adopt a standard set of measurement unit representations, for example UCUM . { \"amount\": \"4.093\", \"uom\": \"lbs\" } Address We recommend using address for all requirements related to address. The address is backward compatible with hCard address microformats, forward compatible with Google open-source address validation metadata (i18n-api) and W3 HTML5.1 autofill fields, allows mapping to and from many address normalization services (ANS) such as AddressDoctor. Please refer to README for Address for more details about the address type, guidance on how to map it to i18n-api\u2019s address and W3 HTML5.1\u2019s autofill fields. Money Money is a standard type to represent amounts. The Common Type MonetaryAmount provides common definition of money. Data-type integrity rules: Both currency and value MUST exist for this type to be valid. Some currencies such as \u201cJPY\u201d do not have sub-currency, which means the decimal portion of the value should be \u201c.0\u201d. An amount MUST NOT be negative. For example a $5 bill is never negative. Negative or positive is an internal notion in association with a particular account/transaction and in respect of the type of the transaction performed. { \"value\": \"210.93\", \"currency\": \"USD\" } Percentage, Interest rate, or APR Percentages and interest rates are very common when dealing with money. One of the most common examples is annual percentage rate, or APR. These interest rates SHOULD always be represented according to the following rules: The Common Type annualPercentageRate MUST be used. This ensures that the rate is represented as a fixed-point decimal. All validation rules defined in the type MUST be followed. The value MUST be represented as a percentage. Example: if the interest rate is 19.99%, the value returned by the API MUST be 19.99. The field\u2019s JSON schema description field SHOULD inform clients how the representation works. Example: \u201cThe interest rate is represented as a percentage. For example, an interest rate of 19.99% would be serialized as 19.99.\u201d It is the responsibility of the client to transform this value into a format suitable for display to the end-user. For example, some countries use the comma ( , ) as a decimal separator instead of the period ( . ). Services MUST NOT vary the format of values passed to or from a service based on end-user display concerns. Internationalization The following common types MUST be used with regard to global country, currency, language and locale. Country code - All APIs and services MUST use the ISO 3166-1 alpha-2 two letter country code standard. Currency code - Currency type MUST use the three letter currency code as defined in ISO 4217 . For quick reference on currency codes, see http://en.wikipedia.org/wiki/ISO_4217. Language code - Language type uses BCP-47 language tag. Locale code - Locale type defines the concept of locale, which is composed of country_code and language. Optionally, IANA timezone can be included to further define the locale. Province code - Province type provides detailed definition of province or state, based on ISO-3166-2 country subdivisions, with room for variant local, international, and abbreviated representations of province names. Useful for logistics, statistics, and building state pull-downs for on-boarding. Date, Time and Timezone When dealing with date and time, all APIs MUST conform to the following guidelines. The date and time string MUST conform to the date-time universal format defined in section 5.6 of RFC3339 . In use cases where you would require only a subset of the fields (e.g full-date or full-time) from the RFC3339 date-timeformat, you SHOULD use the Date Time Common Types to express these. All APIs MUST only emit UTC time (aka Zulu time or GMT ) in the responses. When processing requests, an API SHOULD accept date-time or time fields that contain an offset from UTC. For example, 2016-09-28T18:30:41.000+05:00 SHOULD be accepted as equivalent to 2016-09-28T13:30:41.000Z. This helps ensure compatibility with third parties who may not be capable of normalizing values to UTC before sending requests. In such cases the offset SHOULD only be used to calculate the equivalent UTC time before it is persisted in the system (because of known platform/language/DB interoperability issues). A UTC offset MUST NOT be used to derive anything else. If the business logic requires expressing the timezone of an event, it is RECOMMENDED that you capture the timezone explicitly by using a separate request/response field. You SHOULD NOT use offset to derive the timezone information. The offset alone is insufficient to accurately transform the stored UTC time back to a local time later. The reason is that a UTC offset might be same for many geographical regions and based on the time of the year there may be additional factors such as daylight savings. For example, an offset UTC-05:00 represents Eastern Standard Time during winter, Central Dayight Time during summer, and year-round offset for Panama, Columbia, and Peru. The timezone string MUST be per IANA timezone database (aka Olson database or tzdata or zoneinfo database), for example America/Los_Angeles for Pacific Time, or Europe/Berlin for Central European Time. When expressing floating time values that are not tied to specific time zones such as user\u2019s date of birth, expiry date, publication date etc. in requests or responses, an API SHOULD NOT associate it with a timezone. The reason is that a UTC offset changes the meaning of a floating time value. For example, all countries with timezones west of prime meridian would consider a floating time value to be the previous day. Date Time Common Types The following common formats MUST be used to express various date-time formats in ISO 8601 standard formats: YYYY-MM-DD'T'hh:mm:ss.nnnZ SHOULD be used to express an RFC3339 date-time. YYYY-MM-DD SHOULD be used to express full-date from RFC 3339. hh:mm:ss.nnnZ SHOULD be used to express full-time from RFC3339. YYYY-MM SHOULD be used to express a floating date that contains only the month and year. For example, card expiry date (2016-09). Time zone code MUST be used for expressing timezone of a RFC3339 date-time or a full-time field. Enumerated Codes Provide human-readable descriptions, as well as machine-readable codes. { \"shippingMethod\": { \"code\": \"02\", \"description\": \"Road Del Unmtr/Pkg \u9001\u8d27\" } } I18n Enumerated Codes Provide internationalized human-readable descriptions, as well as machine-readable codes { \"shippingMethod\": { \"code\": \"02\", \"description\": { \"en\": \"Road Del Unmtr/Pkg\", \"jp\": \"\u9001\u8d27\" } } }","title":"HTTP Payload Standards"},{"location":"unified/payloads/#http-payload-standards","text":"","title":"HTTP Payload Standards"},{"location":"unified/payloads/#request-response-body","text":"All request and response bodies across any REST resource operation are expected to serialize data according to the JSON Data Interchange Format described in RFC 7159 and JavaScript Object Notation (JSON) . JSON is built upon four primitive types ( string , number , boolean , and null ) and on two structures [5]: Object - A collection of name/value pairs. In various languages, this is realized as an object, record, struct, dictionary, hash table, keyed list, or associative array. Array - An ordered list of values. In most languages, this is realized as an array, vector, list, or sequence. JSON responses must always return a JSON object (and not e.g. an array) as a top level data structure to support future extensibility [2]. Potential extensibility might include metadata such as paging, as an example.","title":"Request / Response Body"},{"location":"unified/payloads/#json-schema","text":"JSON Schema is a vocabulary that allows you to annotate and validate JSON documents. As of the writing of this style guide, the latest JSON Schema is version 2020-12 . OpenAPI spec defines an API\u2019s contract interface and the OpenAPI Schema Object is based on the JSON Schema. This enables the API provider to communicate JSON schema validation rules via OpenAPI spec. Refer to both of these specifications when documenting the contract interface for consumers. NOTE: json-schema.org seems to have dropped the Hypermedia specification from the 2012-12 version of the spec. This document continues to refer to the 2019-09 version . YMMV.","title":"JSON Schema"},{"location":"unified/payloads/#api-contract-description","text":"There are various options available to define the API\u2019s contract interface (API specification or API description). Examples are: OpenAPI (fka Swagger), Google Discovery Document , RAML , API BluePrint and so on. OpenAPI is a vendor neutral API description format. The OpenAPI Schema Object (or OpenAPI JSON) is an extended subset of the JSON Schema Specification . In addition, there are extensions provided by the specification to allow for more complete documentation. It is RECOMMENDED to use the latest version of the OpenAPI specification. At the time of this writing, the latest version is v3.1. We have used OpenAPI to describe the API specification throughout this document.","title":"API Contract Description"},{"location":"unified/payloads/#schema","text":"Use $schema to indicate the version of JSON schema used by each JSON type you define as shown below. { \"type\": \"object\", \"$schema\": \"https://json-schema.org/draft/2020-12/schema#\", \"name\": \"Order\", \"description\": \"An order transaction.\", \"properties\": { ... } } In case your JSON type uses links, media and other such keywords or schemas such as for linkDescription that are defined in http://json-schema.org/draft/2019-09/json-schema-hypermedia.html , you should provide the value for $schema accordingly as shown below. { \"type\": \"object\", \"$schema\": \"https://json-schema.org/draft/2019-09/hyper-schema#\", \"name\": \"Linked-Order\", \"description\": \"An order transaction using HATEOAS links.\", \"properties\": { ... } } If you are unsure about the specific schema version to refer to, it would be safe to refer https://json-schema.org/draft/2019-09/hyper-schema# schema since it would cover the hypermedia aspects of any JSON schema.","title":"$schema"},{"location":"unified/payloads/#readonly","text":"When resources contain immutable fields, PUT/PATCH operations can still be utilized to update that resource. To indicate immutable fields in the resource, the readOnly field can be specified on the immutable fields.","title":"readOnly:"},{"location":"unified/payloads/#example","text":"\"properties\": { \"id\": { \"type\": \"string\", \"description\": \"Identifier of the resource.\", \"readOnly\": true } }","title":"Example:"},{"location":"unified/payloads/#advanced-syntax-guidance","text":"Be aware that anyOf/allOf/oneOf syntax can cause issues with tooling, as code generators, documentation tools and validation of these keywords is often not implemented.","title":"Advanced Syntax Guidance"},{"location":"unified/payloads/#allof","text":"The allOf keyword MUST only be used for the purposes listed here.","title":"allOf"},{"location":"unified/payloads/#extend-object","text":"The allOf keyword in JSON Schema SHOULD be used for extending objects. In draft-03, this was implemented with the extends keyword, which has been deprecated in draft-04. Example: A common need is to extend a common type with additional fields. In this example, we will extend the address with a typefield. \"shipping_address\": { \"\\$ref\": \"v1/schema/address.json\" } Using the allOf keyword, we can combine both the common type address schema and an extra schema snippet for the address type: \"shipping_address\": { \"allOf\": [ // Here, we include our \"core\" address schema... { \"\\$ref\": \"v1/schema/address.json\" }, // ...and then extend it with stuff specific to a shipping // address { \"properties\": { \"type\": { \"enum\": [ \"residential\", \"business\" ] } }, \"required\": [\"type\"] } ] }","title":"Extend object"},{"location":"unified/payloads/#anyofoneof","text":"The anyOf and oneOf keywords SHOULD NOT be used to design APIs. A variety of problems occur from these keywords: Codegen tools do not have an accurate way to generate models/objects from these definitions. Developer portals would have significant difficulty in clearly explaining to API consumers the meaning of these relationships. Consumers using statically typed languages (e.g. C#, Java) have a more complex experience trying to conditionally deserialize objects which change based on some element. Custom deserialization code is required to represent objects based on the response, standard libraries do not accommodate this out of the box. Flat structures which combine all possible fields in an object are automatically deserialized properly.","title":"anyOf/oneOf"},{"location":"unified/payloads/#anyofoneof-problems-example","text":"{ \"activityType\": { \"description\": \"The entity type of the item. One of 'PAYMENT', 'MONEY-REQUEST', 'RECURRING-PAYMENT-PROFILE', 'ORDER', 'PAYOUT', 'SUBSCRIPTION', 'INVOICE'\", \"type\": \"string\", \"enum\": [ \"PAYMENT\", \"MONEY-REQUEST\" ] }, \"extensions\": { \"type\": \"object\", \"description\": \"Extension to core activity fields\", \"oneOf\": [ { \"$ref\": \"v1/schema/extended_properties.json#/definitions/payment_properties\" }, { \"$ref\": \"v1/schema/extended_properties.json#/definitions/money_request_properties\" } ] } } In order for an API consumer to deserialize this response (where POJO/POCO objects are used), standard mechanisms would not work. Because the extensions field can change on any given response, the consumer is forced to create a composite object to represent both payment_properties.json and money_request_properties.json . A better approach: { \"activityType\": { \"description\": \"The entity type of the item. One of 'PAYMENT', 'MONEY-REQUEST', 'RECURRING-PAYMENT-PROFILE', 'ORDER', 'PAYOUT', 'SUBSCRIPTION', 'INVOICE'\", \"type\": \"string\", \"enum\": [ \"PAYMENT\", \"MONEY-REQUEST\" ] }, \"payment\": { \"type\": \"object\", \"description\": \"Payment-specific activity.\", \"$ref\": \"v1/schema/payment.json\" }, \"moneyRequest\": { \"type\": \"object\", \"description\": \"Money request-specific activity.\", \"$ref\": \"v1/schema/money_request.json\" } } In this scenario, both payment and moneyRequest are in the definition. However, in practice, only one field would be serialized based on the activityType . For API consumers, this is a very predictable response, and allows for easy deserialization through standard libraries, without writing custom deserializers.","title":"anyOf/oneOf Problems: Example:"},{"location":"unified/payloads/#json-types","text":"This section provides guidelines related to usage of JSON primitive types as well as commonly useful JSON types for address, name, currency, money, country, phone, among other things.","title":"JSON Types"},{"location":"unified/payloads/#json-primitive-types","text":"JSON Schema 2020-12 SHOULD be used to define all fields in APIs. As such, the following notes about the JSON Schema primitive types SHOULD be respected. Following are the guidelines governing use of JSON primitive type representations.","title":"JSON Primitive Types"},{"location":"unified/payloads/#string","text":"At a minimum, strings SHOULD always explicitly define a minLength and maxLength . There are several reasons for doing so. Without a maximum length, it is impossible to reliably define a database column to store a given string. Without a maximum and minimum, it is also impossible to predict whether a change in length will break backwards-compatibility with existing clients. Finally, without a minimum length, it is often possible for clients to send an empty string when they should not be allowed to do so. APIs MAY avoid defining minLength and maxLength only if the string value is from another system of record that has refused to provide any information on these values. This decision must be documented in the schema. API authors SHOULD consider practical limitations when defining maxLength . For example, when using the VARCHAR2 type, modern versions of Oracle can safely store a Unicode string of no more than 1,000 characters. (The size limit is 4,000 bytes and each Unicode character may take up to four bytes for storage). string SHOULD utilize the pattern property as appropriate, especially when defining enumerated values or numbers. However, it is RECOMMENDED not to overly constrain fields without a valid technical reason.","title":"String"},{"location":"unified/payloads/#enumeration","text":"The JSON Schema enum keyword is difficult to use safely. It is not possible to add new values to an enum in a schema that describes a service response without breaking backwards compatibility. In that scenario, clients will often reject responses with values that are not in the older copy of the schema that they possess. This is usually not the desired behavior. Clients should usually handle unknown values more gracefully, but since you can\u2019t control nor verify their behavior, it is not safe to add new enum values. For the reasons stated above, the schema author MUST comply with the following guidelines while using an enum with the JSON type string. The keyword enum SHOULD be used only when the set of values are fixed and would never change in future. If you anticipate adding new values to the enum array in future, avoid using the keyword enum. You SHOULD instead use a string type and document all acceptable values for the string. When using a string type to express enumerated values, you SHOULD enforce naming conventions through a pattern field. If there is no technical reason to do otherwise \u2013 for instance, a pre-existing database column of smaller size \u2013 maxLength should be set to 255. minLength should be set to 1 to prevent clients sending the empty string. All possible values of an enum field SHOULD be precisely defined in the documentation. If there is not enough space in the description field to do so, you SHOULD use the API\u2019s user guide to define them. Given below is the JSON snippet for enforcing naming conventions and length constraints. { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255, \"pattern\": \"^[0-9A-Z_]+\\$\", \"description\": \"A description of the field. The possible values are OPTION_ONE and OPTION_TWO.\" }","title":"Enumeration"},{"location":"unified/payloads/#number","text":"There are a number of difficulties associated with number type in JSON. JSON itself defines a number very simply: it is an unbounded, fixed-point value. This is illustrated well by the railroad diagram for number at JSON . There is only one number type in JSON; there is no separate integer type. JSON Schema diverges from JSON and defines two number types: number and integer. This is purely a convenience for schema validation; the JSON number type is used to implement both. Just as in JSON, both types are unbounded unless the schema author provides explicit minimum and maximum values. Many programming languages do not safely handle unbounded values in JSON. JavaScript is an excellent example. A JSON deserializer is provided as part of the ECMAScript specification. However, it requires that all JSON numbers are deserialized into the only number type supported by JavaScript \u2013 64-bit floating point. This means that attempting to deserialize any JSON number larger than about 2 53 in a JavaScript client will result in an exception. To ensure the greatest degree of cross-client compatibility possible, schema authors SHOULD : Never use the JSON Schema number type. Some languages may interpret it as a fixed-point value, and some as floating-point. Always use string to represent a decimal value. Only define integer types for values that can be represented in a 32-bit signed integer, that is to say, values between ((2 31 ) - 1) and -(2 31 ). This ensures compatibility across a wide range of programming languages and circumstances. For example, array indices in JavaScript are signed 32-bit integers. When using an integer type, always provide an explicit minimum and a maximum. This not only allows backwards-incompatible changes to be detected, it also guarantees that all values can fit in a 32-bit signed integer. If there are no technical reasons to do otherwise, the maximum and minimum should be defined as 2147483647 (((2 31 ) - 1)) and -2147483648 (-(2 31 )) or 0 respectively. Common sense should be used to determine whether to allow negative values. Business logic that could change in the future generally SHOULD NOT be used to determine boundaries; business rules can easily change and break backwards compatibility. If there is any possibility that the value could not be represented by a signed 32-bit integer, now or in the future, not use the JSON Schema integer type. Use a string instead.","title":"Number"},{"location":"unified/payloads/#examples","text":"This integer type might be used to define an array index or page count, or perhaps the number of months an account has been open. { \"type\": \"integer\", \"minimum\": 0, \"maximum\": 2147483647 } When using a string type to represent a number, authors MUST provide boundaries on size using minLength and maxLength , and constrain the definition of the string to only represent numbers using pattern. For example, this definition only allows positive integers and zero, with a maximum value of 999999: { \"type\": \"string\", \"pattern\": \"^[0-9]+\\$\", \"minLength\": 1, \"maxLength\": 6 } The following definition allows the representation of fixed-point decimal values both positive or negative, with a maximum length of 32 and no requirements on scale: { \"type\": \"string\", \"pattern\": \"^(-?[0-9]+|-?([0-9]+)?[.][0-9]+)$\", \"maxLength\": 32, \"minLength\": 1, }","title":"Examples:"},{"location":"unified/payloads/#array","text":"JSON defines an array as unbounded. Although practical limits are often much lower due to memory constraints, many programming languages do place maximum theoretical limits on the size of arrays. For example, JavaScript is limited to the length of a 32-bit unsigned integer by the ECMA-262 specification. Java is limited to about Integer.MAX_VALUE - 8 , which is less than half of JavaScript. To ensure maximum compatibility across languages and encourage paginated APIs, maxItems SHOULD always be defined by schema authors. maxItems SHOULD NOT have a value greater than can be represented by a 16-bit signed integer, in other words, 32767 or (2 15 ) - 1). Note that developers MAY choose to set a smaller value; the value 32767 is a default choice to be used when no better choice is available. However, developers SHOULD design their API for growth. For example, although a paginated API may only support a maximum of 100 results per page today, performance improvements may allow developers to improve that to 1,000 results next year. Therefore, maxItems SHOULD NOT be used to communicate maximum page size. minItems SHOULD also be defined. In most situations, its value will be either 0 or 1.","title":"Array"},{"location":"unified/payloads/#null","text":"APIs MUST NOT produce or consume null values. null is a primitive type in JSON. When validating a JSON document against JSON Schema, a property\u2019s value can be nullonly when it is explicitly allowed by the schema, using the type keyword (e.g. {\"type\": \"null\"} ). Since in an API type will always need to be defined to some other value such as object or string, and these standards prohibit using schema composition keywords such as anyOf or oneOf that allow multiple types, if an API produces or consumes null values, it is unlikely that, according to the API\u2019s own schemas, this is actually valid data. In addition, in JSON, a property that doesn\u2019t exist or is missing in the object is considered to be undefined; this is conceptually separate from a property that is defined with a value of null, but many programming languages have difficulty drawing this distinction. For example, a property my_property defined as {\"type\": \"null\"} is represented as { \"myProperty\": null } While a property that is undefined would not be present in the object: { } In most strongly typed languages, such as Java, there is no concept of an undefined type, which means that for all undefined fields in a JSON object, a deserializer would return the value of such types as null when you try to retrieve them. Similarly, some Java-based JSON serializers serialize fields to JSON null by default, even though it is not possible for the serializer to determine whether the author of the Java object intended for that property to be defined with a value of null, or simply undefined. In Jackson, for example, this behavior is moderated through use of the JsonInclude annotation. On the other hand, the org.json library defines an object called NULL to distinguish between null and undefined. Eschewing JSON null completely helps avoid many of these subtle cross-language compatibility traps.","title":"Null"},{"location":"unified/payloads/#additional-properties","text":"Setting of additionalProperties to false in schema objects breaks backward compatibility in those clients that use an API\u2019s JSON schemas (defined by its contract) to validate the API requests and responses. For the same reason, the schema author MUST not explicitly set the additionalProperties to false. The API implementation SHOULD instead enforce the conformance of requests and responses to an API contract by hard validating the requests and responses against the defined API contract at run-time.","title":"Additional Properties"},{"location":"unified/payloads/#common-types","text":"Resource representations in API MUST reuse the common data type definitions where possible. The following sections provide some details about some of these common types.","title":"Common Types"},{"location":"unified/payloads/#quantity","text":"Future-proof quantities by including a unit-of-measure (UOM). It is recommended to adopt a standard set of measurement unit representations, for example UCUM . { \"amount\": \"4.093\", \"uom\": \"lbs\" }","title":"Quantity"},{"location":"unified/payloads/#address","text":"We recommend using address for all requirements related to address. The address is backward compatible with hCard address microformats, forward compatible with Google open-source address validation metadata (i18n-api) and W3 HTML5.1 autofill fields, allows mapping to and from many address normalization services (ANS) such as AddressDoctor. Please refer to README for Address for more details about the address type, guidance on how to map it to i18n-api\u2019s address and W3 HTML5.1\u2019s autofill fields.","title":"Address"},{"location":"unified/payloads/#money","text":"Money is a standard type to represent amounts. The Common Type MonetaryAmount provides common definition of money. Data-type integrity rules: Both currency and value MUST exist for this type to be valid. Some currencies such as \u201cJPY\u201d do not have sub-currency, which means the decimal portion of the value should be \u201c.0\u201d. An amount MUST NOT be negative. For example a $5 bill is never negative. Negative or positive is an internal notion in association with a particular account/transaction and in respect of the type of the transaction performed. { \"value\": \"210.93\", \"currency\": \"USD\" }","title":"Money"},{"location":"unified/payloads/#percentage-interest-rate-or-apr","text":"Percentages and interest rates are very common when dealing with money. One of the most common examples is annual percentage rate, or APR. These interest rates SHOULD always be represented according to the following rules: The Common Type annualPercentageRate MUST be used. This ensures that the rate is represented as a fixed-point decimal. All validation rules defined in the type MUST be followed. The value MUST be represented as a percentage. Example: if the interest rate is 19.99%, the value returned by the API MUST be 19.99. The field\u2019s JSON schema description field SHOULD inform clients how the representation works. Example: \u201cThe interest rate is represented as a percentage. For example, an interest rate of 19.99% would be serialized as 19.99.\u201d It is the responsibility of the client to transform this value into a format suitable for display to the end-user. For example, some countries use the comma ( , ) as a decimal separator instead of the period ( . ). Services MUST NOT vary the format of values passed to or from a service based on end-user display concerns.","title":"Percentage, Interest rate, or APR"},{"location":"unified/payloads/#internationalization","text":"The following common types MUST be used with regard to global country, currency, language and locale. Country code - All APIs and services MUST use the ISO 3166-1 alpha-2 two letter country code standard. Currency code - Currency type MUST use the three letter currency code as defined in ISO 4217 . For quick reference on currency codes, see http://en.wikipedia.org/wiki/ISO_4217. Language code - Language type uses BCP-47 language tag. Locale code - Locale type defines the concept of locale, which is composed of country_code and language. Optionally, IANA timezone can be included to further define the locale. Province code - Province type provides detailed definition of province or state, based on ISO-3166-2 country subdivisions, with room for variant local, international, and abbreviated representations of province names. Useful for logistics, statistics, and building state pull-downs for on-boarding.","title":"Internationalization"},{"location":"unified/payloads/#date-time-and-timezone","text":"When dealing with date and time, all APIs MUST conform to the following guidelines. The date and time string MUST conform to the date-time universal format defined in section 5.6 of RFC3339 . In use cases where you would require only a subset of the fields (e.g full-date or full-time) from the RFC3339 date-timeformat, you SHOULD use the Date Time Common Types to express these. All APIs MUST only emit UTC time (aka Zulu time or GMT ) in the responses. When processing requests, an API SHOULD accept date-time or time fields that contain an offset from UTC. For example, 2016-09-28T18:30:41.000+05:00 SHOULD be accepted as equivalent to 2016-09-28T13:30:41.000Z. This helps ensure compatibility with third parties who may not be capable of normalizing values to UTC before sending requests. In such cases the offset SHOULD only be used to calculate the equivalent UTC time before it is persisted in the system (because of known platform/language/DB interoperability issues). A UTC offset MUST NOT be used to derive anything else. If the business logic requires expressing the timezone of an event, it is RECOMMENDED that you capture the timezone explicitly by using a separate request/response field. You SHOULD NOT use offset to derive the timezone information. The offset alone is insufficient to accurately transform the stored UTC time back to a local time later. The reason is that a UTC offset might be same for many geographical regions and based on the time of the year there may be additional factors such as daylight savings. For example, an offset UTC-05:00 represents Eastern Standard Time during winter, Central Dayight Time during summer, and year-round offset for Panama, Columbia, and Peru. The timezone string MUST be per IANA timezone database (aka Olson database or tzdata or zoneinfo database), for example America/Los_Angeles for Pacific Time, or Europe/Berlin for Central European Time. When expressing floating time values that are not tied to specific time zones such as user\u2019s date of birth, expiry date, publication date etc. in requests or responses, an API SHOULD NOT associate it with a timezone. The reason is that a UTC offset changes the meaning of a floating time value. For example, all countries with timezones west of prime meridian would consider a floating time value to be the previous day.","title":"Date, Time and Timezone"},{"location":"unified/payloads/#date-time-common-types","text":"The following common formats MUST be used to express various date-time formats in ISO 8601 standard formats: YYYY-MM-DD'T'hh:mm:ss.nnnZ SHOULD be used to express an RFC3339 date-time. YYYY-MM-DD SHOULD be used to express full-date from RFC 3339. hh:mm:ss.nnnZ SHOULD be used to express full-time from RFC3339. YYYY-MM SHOULD be used to express a floating date that contains only the month and year. For example, card expiry date (2016-09). Time zone code MUST be used for expressing timezone of a RFC3339 date-time or a full-time field.","title":"Date Time Common Types"},{"location":"unified/payloads/#enumerated-codes","text":"Provide human-readable descriptions, as well as machine-readable codes. { \"shippingMethod\": { \"code\": \"02\", \"description\": \"Road Del Unmtr/Pkg \u9001\u8d27\" } }","title":"Enumerated Codes"},{"location":"unified/payloads/#i18n-enumerated-codes","text":"Provide internationalized human-readable descriptions, as well as machine-readable codes { \"shippingMethod\": { \"code\": \"02\", \"description\": { \"en\": \"Road Del Unmtr/Pkg\", \"jp\": \"\u9001\u8d27\" } } }","title":"I18n Enumerated Codes"},{"location":"unified/requests/","text":"HTTP Request Standards This section defines how HTTP Requests should be constructed. It includes definitions and examples for each of the HTTP verbs. It also defines how URLs are constructed, and how the URL structure communicates request semantics to the server. HTTP Verb Semantics API calls may fail for a number of reasons, and the client may not always know if the server failed or if the client simply didn\u2019t get notified of success. For example, there may be a temporary network failure preventing the server\u2019s response from getting back to the client, or the server may have responded but the client HTTP connection already timed out before receiving the response. The following two characteristics help us think about these failure conditions: Safety - Safe calls have no client-visible side effects (in other words, writing to a server-side log file is fine, but changing resource state is not). Read-only APIs should be safe. Idempotency - Idempotent APIs are those where the end result of two or more (identical) successful API calls is the same as the end result of one successful call. Idempotent APIs are therefore retry-able when the client does not know if the call succeeded on the server or not. Safety and Idempotency These two characteristics allow us to reason about failure scenarios with HTTP verb semantics: HTTP Verb Safe? Idempotent? GET Yes Yes POST No Maybe - sending multiple POST requests will result in multiple resources unless both client and server implement idempotency logic via the value of the Idempotency-Key HTTP header property. PUT No Maybe - overwriting a resource with the same state twice is fine, provided there is a way to fail the retry if the resource has been further modified by another actor in the meantime PATCH No No - updating a few fields twice may not result in the same resource state as other fields may change between the two updates DELETE No Yes - deleting a resource that\u2019s already deleted is fine Note: The above analysis is true only for the resource in question. If the service triggers other workflows as a result of an API call, then the service must implement logic to maintain the safety and/or idempotency of the API request. For example, in the case where changing a resource triggers a workflow, systems of record should only be notified if a PUT actually changes the resource . Resource Operations - HTTP Verbs and URL Paths The HTTP verbs to support endpoint requests should follow standard HTTP semantics. Verb Collection Singular Reified Non-resourceful GET Search Read Status of workflow request Not applicable POST Create (server returns new resource id) Tunnel Create Tunnel PUT Overwrite all Overwrite (or create with client provided id) Not applicable Not applicable PATCH Bulk update Partial update Not applicable Not applicable DELETE Delete all Delete Cancel a workflow request Not applicable \"Tunnel\" refers to taking any action not otherwise represented in the table. It is a way of bypassing the Uniform Interface of REST to take some action that requires more than standard HTTP semantics. HTTP supports two standard ways of updating a resource through the PUT and PATCH verbs. PUT is more common, but expects the client to pass all fields back. PATCH supports partial updates, allowing the client to only send changed fields back. Our recommendation is to use PUT wherever possible, as it\u2019s easier to understand and generally provides a better client experience. PATCH has complicated semantics and is more prone to errors and race conditions. Prefer POST over PUT-with-id for creation of resources. Supporting PUT-with-id requires extra overhead for synchronization and ensuring an id is unique. This can have an impact on performance and reliability. It also adds complexity on the client-side implementation in the form of handling an additional set of error conditions. This style guide does not dictate whether DELETEs are hard deletes or soft. Those semantics will be defined within each API as appropriate to the business. Standard Querystring Operations Where a standard operation isn\u2019t listed below, prefer JSON API format where feasible. Create Resource For creating a new resource, use POST method. The request body for POST may be somewhat different than for GET/PUT response/request (typically fewer fields as the server will generate some values). In most cases, the service produces an identifier for the resource. In cases where identifier is supplied by the API consumer, use Create New Resource - Client Supplied ID Once the POST has successfully completed, a new resource will be created. Hypermedia links provide an easy way to get the URL of the newly created resource, using the rel: self, in addition to other links for operations that are allowed on the newly created resource. You may provide complete representation of the resource or partial with just HATEOAS links to retrieve the complete representation. URI Template POST /{version}/{namespace}/{resource} Example Request: Note that server-generated values are not provided in the request. POST /v1/vault/credit-cards { \"payer_id\": \"user12345\", \"type\": \"visa\", \"number\": \"4417119669820331\", \"expire_month\": \"11\", \"expire_year\": \"2018\", \"first_name\": \"Betsy\", \"last_name\": \"Buyer\", \"billing_address\": { \"line1\": \"111 First Street\", \"city\": \"Saratoga\", \"country_code\": \"US\", \"state\": \"CA\", \"postal_code\": \"95070\" } } Example Response On successful execution, the method returns with status code 201. 201 Created { \"id\": \"CARD-1MD19612EW4364010KGFNJQI\", \"valid_until\": \"2016-05-07T00:00:00Z\", \"state\": \"ok\", \"payer_id\": \"user12345\", \"type\": \"visa\", \"number\": \"xxxxxxxxxxxx0331\", \"expire_month\": \"11\", \"expire_year\": \"2018\", \"first_name\": \"Betsy\", \"last_name\": \"Buyer\", \"links\": [ { \"href\": \"https://api.sandbox.example.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.sandbox.example.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] } Create New Resource - Consumer Supplied Identifier When an API consumer provides the resource identifier, PUT method SHOULD be utilized, as the operation is idempotent, even during creation. The same interaction as Create Resource is used here. 201 Created + response body on resource creation, and 204 No Content + no response body when an existing resource is updated. Collection Resource A collection resource should return a list of representation of all of the given resources (instances), including any related metadata. An array of resources should be in the items field. Consistent naming of collection resource fields allows API clients to create generic handling for using the provided data across various resource collections. The GET verb should not affect the system, and should not change the response on subsequent requests (unless the underlying data changes), i.e. it should be idempotent. Exceptions to 'changing the system' are typically instrumentation/logging-related. The list of data is presumed to be filtered based on the privileges available to the API client. In other words, it should not be a list of all resources in the domain. It should only be resources for which the client has authorization to view within its current context. Providing a summarized, or minimized version of the data representation can reduce the bandwidth footprint, in cases where individual resources contain a large object. If the service allows partial retrieval of the set, the following patterns MUST be followed. Resource Filtering Often it is desired to be able to filter the set of resources based on a resource property. The filter is defined based on the following conventions and behaviors: filter query argument: ?filter=<filter-def> filter-def: <filter-spec>,...,<filter-spec> filter-spec: <property><operator><value> property: the name of a property within the resource. value: the value to use in the comparison operation operator: a character which indicates the type of operations equals: : less than: < less than or equal: <: greater than: > greater than or equal: >: like: ~ NOTE: there must be leading and/or trailing * character(s) in the value string negation: ! added before the operator Ensure that query definitions are URL-encoded properly Resources matching the filter MUST match all of the <filter-spec> definitions. Except: specifying the same property to be equal to two values is an implicit 'IN' operation. For example: GET /v1/movies?filter=genre:Comedy,genre:RomCom will provide a list of all Comedy or RomCom movies. Examples: GET /v1/movies?filter=gross>=1000000 would get all movies grossing $1M or more GET /v1/movies?filter=genre!~*edy would get all movies not Comedy or Romantic Comedy or Dramedy GET /v1/movies?filter=genre:Comedy,gross>=500000,origin!:us would get all successful (over $500K) foreign comedies This is not meant to be an exhaustive API, but rather a set of simple rules which are generally useful for all APIs. APIs supporting any type of filtering on Collection resources MUST support the above conventions. APIs which need additional capabilities MAY augment the above definitions provided the consumer expectations are not violated, and the meaning of the basic filter definition is not changed. For example, an API may choose to support a more complicated method of filtering based on properties of related resources, as in the following example: GET /v1/movies?filter=actor.name:Kevin%20DBacon might get all movies in which Kevin Bacon played a role. Time Selection Query parameters with regard to time range could be used to select a subset of items in the following manner: startTime or {propertyName}After A timestamp (in either Unix time or ISO-8601 format) indicating the non-inclusive start of a temporal range. startTime may be used when there is only one unambiguous time dimension; otherwise, the property name should be used (e.g., processedAfter, updatedAfter). The property SHOULD map to a time field in the representation. endTime or {propertyName}Before A timestamp (in either Unix time or ISO-8601 format) indicating the non-inclusive end of a temporal range. endTime may be used when there is only one unambiguous time dimension; otherwise, the property name should be used (e.g., processed_before, updated_before). The property SHOULD map to a time field in the representation. Sorting Results could be ordered according to sorting related instructions given by the client. This includes sorting by a specific field's value and sorting order as described in the query parameters below. sortBy A dimension by which items should be sorted; the dimensions SHOULD be an attribute in the item's representation; the default (ascending or descending) is left to the implementation and MUST be specified in the documentation. sortOrder The order, one of asc or desc , indicating ascending or descending order. Pagination Any resource that could return a large, potentially unbounded list of resources in its GET response MUST implement pagination using the patterns described here. Sample URI path: /accounts?pageSize={pageSize}&page={page} Clients MUST assume no inherent ordering of results unless a default sort order has been specified for this collection. It is RECOMMENDED that service implementers specify a default sort order whenever it would be useful. Query Parameters pageSize : A non-negative, non-zero integer indicating the maximum number of results to return at one time. This parameter: MUST be optional for the client to provide. MUST have a default value, for when the client does not provide a value. page : A non-zero integer representing the page of the results. This parameter: MUST be optional for the client to provide. MUST have a default value of 1 for when the client does not provide a value. MUST respond to a semantically invalid page count, such as zero, with the HTTP status code 400 Bad Request . If a page number is too large -- for instance, if there are only 50 results, but the client requests pageSize=100&page=3 -- the resource MUST respond with the HTTP status code 200 OK and an empty result list. pageToken : In certain cases such as querying on a large data set, in order to optimize the query execution while paginating, querying and retrieving the data based on result set of previous page migh be appropriate. Such a pageToken could be an encrypted value of primary keys to navigate next and previous page along with the directions. totalRequired : A boolean indicating total number of items ( totalItems ) and pages ( totalPages ) are expected to be returned in the response. This parameter: SHOULD be optional for the client to provide. SHOULD have a default value of false. MAY be used by the client in the very first request. The client MAY then cache the values returned in the response to help build subsequent requests. SHOULD only be implemented when it will improve API performance and/or it is necessary for front-end pagination display. Response Properties JSON response to a request of this type SHOULD be an object containing the following properties: items MUST be an array containing the current page of the result list. Unless there are performance or implementation limitations: totalItems SHOULD be used to indicate the total number of items in the full result list, not just this page. If totalRequired has been implemented by an API, then the value SHOULD only be returned when totalRequired is set to true. If totalRequired has not been implemented by an API, then the value MAY be returned in every response if necessary, useful, and performant. If present, this parameter MUST be a non-negative integer. Clients MUST NOT assume that the value of totalItems is constant. The value MAY change from one request to the next. totalPages SHOULD be used to indicate how many pages are available, in total. If totalRequired has been implemented by an API, then the value SHOULD only be returned when totalRequired is set to true. If totalRequired has not been implemented by an API, then the value MAY be returned in every response if necessary, useful, and performant. If present, this parameter MUST be a non-negative, non-zero integer. Clients MUST NOT assume that the value of totalPages is constant. The value MAY change from one request to the next. links SHOULD be an array containing one or more HATEOAS link relations that are relevant for traversing the result list. Page Navigation Relationship Description self Refers to the current page of the result list. first Refers to the first page of the result list. If you are using pageToken , you may not return this link. last Refers to the last page of the result list. Returning of this link is optional. You need to return this link only if totalRequired is specified as a query parameter. If you are using pageToken , you may not return this link. next Refers to the next page of the result list. prev Refers to the previous page of the result list. This is a sample JSON schema that returns a collection of resources with pagination: { \"id\": \"plan_list:v1\", \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"description\": \"Resource representing a list of billing plans with basic information.\", \"name\": \"plan_list Resource\", \"type\": \"object\", \"required\": true, \"properties\": { \"plans\": { \"type\": \"array\", \"description\": \"Array of billing plans.\", \"items\": { \"type\": \"object\", \"description\": \"Billing plan details.\", \"$ref\": \"plan.json\" } }, \"totalItems\": { \"type\": \"string\", \"readonly\": true, \"description\": \"Total number of items.\" }, \"totalPages\": { \"type\": \"string\", \"readonly\": true, \"description\": \"Total number of pages.\" }, \"links\": { \"type\": \"array\", \"items\": { \"$ref\": \"http://json-schema.org/draft-04/hyper-schema#\" } } }, \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page}&status={status}\", \"rel\": \"self\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page}&start={start_id}&status={status}\", \"rel\": \"first\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page+1}&status={status}\", \"rel\": \"next\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page-1}&status={status}\", \"rel\": \"prev\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={last}&status={status}\", \"rel\": \"last\" } ] } This is a sample JSON response that returns a collection of resources with pagination: { \"totalItems\": \"166\", \"totalPages\": \"83\", \"plans\": [ { \"id\": \"P-6EM196669U062173D7QCVDRA\", \"state\": \"ACTIVE\", \"name\": \"Testing1-Regular3\", \"description\": \"Create Plan for Regular\", \"type\": \"FIXED\", \"create_time\": \"2014-08-22T04:41:52.836Z\", \"update_time\": \"2014-08-22T04:41:53.169Z\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans/P-6EM196669U062173D7QCVDRA\", \"rel\": \"self\" } ] }, { \"id\": \"P-83567698LH138572V7QCVZJY\", \"state\": \"ACTIVE\", \"name\": \"Testing1-Regular4\", \"description\": \"Create Plan for Regular\", \"type\": \"INFINITE\", \"create_time\": \"2014-08-22T04:41:55.623Z\", \"update_time\": \"2014-08-22T04:41:56.055Z\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans/P-83567698LH138572V7QCVZJY\", \"rel\": \"self\" } ] } ], \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=3&status=active\", \"rel\": \"self\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=1&first=3&status=active\", \"rel\": \"first\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=2&status=active\", \"rel\": \"prev\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=4&status=active\", \"rel\": \"next\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=82&status=active\", \"rel\": \"last\" } ] } Read Single Resource A single resource is typically derived from the parent collection of resources, often more detailed than an item in the representation of a collection resource. Executing GET should never affect the system, and should not change response on subsequent requests, i.e. it should be idempotent. All identifiers for sensitive data should be non-sequential, and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers should be utilized for easier readability and debugging (i.e. NAME_OF_VALUE vs 1421321 ). URI Template GET /{version}/{namespace}/{resource}/{resourceId} Example Request: GET /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY Example Response: { \"merchant_customer_id\": \"merchant-1\", \"merchant_id\": \"target\", \"create_time\": \"2014-10-10T16:10:55Z\", \"update_time\": \"2014-10-10T16:10:55Z\", \"first_name\": \"Kartik\", \"last_name\": \"Hattangadi\" } HTTP Status: If the provided resource identifier is not found, the response 404 Not Found HTTP status should be returned (even with \u2019soft deleted\u2019 records in data sources). Otherwise, 200 OK HTTP status should be utilized when data is found. Delete Single Resource In order to enable retries (e.g., poor connectivity), DELETE is treated as idempotent, so it should always respond with a 204 No Content HTTP status. 404 Not Found HTTP status should not be utilized here, as on a second retry a client might mistakenly think the resource never existed at all. GET can be utilized to verify the resources exists prior to DELETE. For a number of reasons, some data exposed as a resource MAY disappear: because it has been specifically deleted, because it expired, because of a policy (e.g., only transactions less than 2 years old are available), etc. Services MAY return a 410 Gone error to a request related to a resource that no longer exists. However, there may be significant costs associated with doing so. Service designers are advised to weigh in those costs and ways to reduce them (e.g., using resource identifiers that can be validated without access to a data store), and MAY return a 404 Not Found instead if those costs are prohibitive. URI Template DELETE /{version}/{namespace}/{resource}/{resourceId} Example Request: DELETE /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY 204 No Content Update Single Resource To perform an update to an entire resource, PUT method MUST be utilized. The same response body supplied in the resource's GET should be provided in the resource's PUT request body. If the update is successful, a 204 No Content HTTP status code (with no response body) is appropriate. Where there is a justifying use case (typically to optimize some client interaction), a 200 OK HTTP status code with a response body can be utilized. While the entire resource's representation must be supplied with the PUT method, the APIs validation logic can enforce constraints regarding fields that are allowed to be updated. These fields can be specified as readOnly in the JSON schema. Fields in the request body can be optional or ignored during deserialization, such as create_time or other system-calculated values. Typical error handling, utilizing the 400 Bad Request status code, should be applied in cases where the client attempts to update fields which are not allowed or if the resource is in a non-updateable state. See Sample Input Validation Error Response for examples of error handling. URI Template PUT /{version}/{namespace}/{resource}/{resourceId} Example Request: PUT /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY { \"merchant_customer_id\": \"merchant-1\", \"merchant_id\": \"target\", \"create_time\": \"2014-10-10T16:10:55Z\", \"update_time\": \"2014-10-10T16:10:55Z\", \"first_name\": \"Kartik\", \"last_name\": \"Hattangadi\" } HTTP Status: Any failed request validation MUST respond with 400 Bad Request HTTP status. If clients attempt to modify read-only fields, this MUST also result in a 400 Bad Request . If there are business rules (more than simple data-type or length constraints), the system SHOULD provide a specific error code and message (in addition to the 400 Bad Request ) for that validation. For situations which require interaction with APIs or processes outside of the current request, the 422 Unprocessable Entity status code is appropriate. After successful update, PUT operations SHOULD respond with 204 No Content status, with no response body. Partially Update Single Resource Often, previously created resources need to be updated based on customer or facilitator-initiated interactions (like adding items to a cart). In such cases, APIs SHOULD provide an RFC 6902 JSON Patch compatible solution. JSON patch uses the HTTP PATCH method defined in RFC 5789 to enable partial updates to resources. A JSON patch expresses a sequence of operations to apply to a target JSON document. The operations defined by the JSON patch specification include add, remove, replace, move, copy, and test. To support partial updates to resources, APIs SHOULD support add, remove and replace operations. Support for the other operations (move, copy, and test) is left to the individual API owner based on needs. Below is a sample PATCH request to do partial updates to a resource: PATCH /v1/namespace/resources/:id HTTP/1.1 Host: api.foo.com Content-Length: 326 Content-Type: application/json-patch+json If-Match: \"etag-value\" [ { \"op\": \"remove\", \"path\": \"/a/b/c\" }, { \"op\": \"add\", \"path\": \"/a/b/c\", \"value\": [ \"foo\", \"bar\" ] }, { \"op\": \"replace\", \"path\": \"/a/b/c\", \"value\": 42 } ] The value of path is a string containing a RFC 6901 JSON Pointer that references a location within the target document where the operation is performed. For example, the value /a/b/c refers to the element c in the sample JSON below: { \"a\": { \"b\": { \"c\": \"\", \"d\": \"\" }, \"e\": \"\" } } path Parameter When JSON Pointer is used with arrays, concurrency protection is best implemented with ETags. In many cases, ETags are not an option: It is expensive to calculate ETags because the API collates data from multiple data sources or has very large response objects. The response data are frequently modified. JSON Pointer Expression In cases where ETags are not available to provide concurrency protection when updating arrays, it is recommended to use an extension to RFC 6901 which provides expressions of the following form. \"path\": \"/object-name/@filter-expression/attribute-name\" object-name is the name of the collection.The symbol \u201c@\u201d refers to the current object. It also signals the beginning of a filter-expression. The filter-expression SHOULD only contain the following operators: a comparison operator (== for equality) or a Logical AND (&&) operator or both. For example: /address/@id==123/streetName , address/@id==123 && primary==true are valid filter expressions. The right hand side operand for the operator \u201c==\u201d MUST have a value that matches the type of the left hand side operand. For example: addresss/@integer_id == 123 , /address/@string_name == \u2018james\u2019 , /address/@boolean_primary == true , /address/@decimal_number == 12.1 are valid expressions. If the right hand operand of \"==\" is a string then it SHOULD NOT contain any of the following escape sequences: a Line Continuation or a Unicode Escape Sequence. attribute-name is the name of the attribute to which a PATCH operation is applied if the filter condition is met. PATCH Array Examples Example 1: \"op\": \"replace\",\"path\": \u201c/address/@id==12345/primary\u201d,\"value\": true This would set the array element \"primary\" to true if the element \"id\" has a value \"12345\". Example 2: \"op\": \"replace\",\"path\": \u201c/address/@countryCode==\u2019GB\u2019 && type==\u2019office\u2019/active\u201d,\"value\": true This would set the array element \"active\" to true if the element \"countryCode\" equals to \"GB\" and type equals to \"office\". Other Implementation Considerations For PATCH It is not necessary that an API support the updating of all attributes via a PATCH operation. An API implementer SHOULD make an informed decision to support PATCH updates only for a subset of attributes through a specific resource operation. Responses to a PATCH request Note that the operations are applied sequentially in the order they appear in the payload. If the update is successful, a 204 No Content HTTP status code (with no response body) is appropriate. Where there is a justifying use case (typically to optimize some client interaction) and the request has the header Prefer:return=representation , a 200 OK HTTP status code with a response body can be utilized. Responses body with 200 OK SHOULD return the entire resource representation unless the client uses the fields parameter to reduce the response size. If a PATCH request results in a new resource state that is invalid, the API SHOULD return a 400 Bad Request or 422 Unprocessable Entity. See Sample Input Validation Error Response for examples of error handling. PATCH Examples PATCH examples for modifying objects can be found in RFC 6902 . Projected Response An API typically responds with full representation of a resource after processing requests for methods such as GET. For efficiency, the client can ask the service to return partial representation using Prefer: return=minimal HTTP header. Here, The determination of what constitutes an appropriate \"minimal\" response is solely at the discretion of the service. To request partial representation with specific field(s), a client can use the fields query parameter. For selecting multiple fields, a comma-separated list of fields SHOULD be used. The following example shows the use of the fields parameter with users API. Request: HTTP GET without fields parameter GET https://api.foo.com/v1/users/dbrown Authorization: Bearer your_auth_token Response: The complete resource representation is returned in the response. { \"uid\": \"dbrown\", \"given_name\": \"David\", \"sn\": \"Brown\", \"location\": \"Austin\", \"department\": \"RISK\", \"title\": \"Manager\", \"manager\": \"ipivin\", \"email\": \"dbrown@foo.com\", \"employeeId\": \"234167\" } Request: HTTP GET request specifies a subset of the fields. GET https://api.foo.com/v1/users/dbrown?fields=department,title,location Authorization: Bearer your_auth_token Response: The response has only fields specified by the fields query parameter as well as mandatory fields. 200 OK { \"uid\": \"dbrown\", \"department\": \"RISK\", \"title\": \"Manager\", \"location\": \"Austin\" } You could use the same pattern for Collection Resource as well as following. GET https://api.foo.com/v1/users?fields=department,title,location The response will have entries with the fields specified in request as well as mandatory fields. Sub-Resource Collection Sometimes, multiple identifiers are required ('composite keys', in the database lexicon) to identify a given resource. In these scenarios, all behaviors of a Collection Resource are implemented, as a subordinate of another resource. It is always implied that the resourceId in the URL must be the parent of the sub-resources. Cautions The need to maintain multiple identifiers can create a burden on client developers. Look for opportunities to promote resources with unique identifiers (i.e. there is no need to identify the parent resource) to a first-level resource. Caution should be used in identifying the name of the sub-resource, as to not interfere with the identifier naming conventions of the base resource. In other words, /{version}/{namespace}/{resource}/{resourceId}/{subResourceId} is not appropriate, as the subResourceId has ambiguous meaning. Two levels is a practical limit for resource identifiers API client usability suffers, as the need for clients to maintain state about identifier hierarchy increases complexity. Server developers must validate each level of identifiers in order to verify that they are allowed access, and that they relate to each other, thus increasing risk and complexity. Note these templates/examples are brief: for more detail on the Collection Resource style, see above. Although this section explains the sub-resource collection, all interactions should be the same, simply with the addition of a parent identifier. URI Templates POST /{version}/{namespace}/{resource}/{resourceId}/{sub-resource} GET /{version}/{namespace}/{resource}/{resourceId}/{sub-resource} GET /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId} PUT /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId} DELETE /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId} Examples: GET /v1/notifications/webhooks/{webhook-id}/event-types POST /v1/factory/widgets/PART-4312/sub-assemblies GET /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG PUT /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG DELETE /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG Sub-Resource Singleton When a sub-resource has a one-to-one relationship with the parent resource, it could be modeled as a singleton sub-resource . This approach is usually used as a means to reduce the size of a resource, when use cases support segmenting a large resource into smaller resources. For a singleton sub-resource , the name should be a singular noun. As often as possible, that single resource should always be present (i.e. does not respond with 404). The sub-resource should be owned by the parent resource; otherwise this sub-resource should probably be promoted to its own collection resource, and relationships represented with sub-resource collections in the other direction. Sub-resource singletons should not duplicate a resource from another collection. If the singleton sub-resource needs to be created, PUT should be used, as the operation is idempotent, on creation or update. PATCH can be used for partial updates, but should not be available on creation (in part because it is not idempotent). This should not be used as a mechanism to update single or subsets of fields with PUT. The resource should remain intact, and PATCH should be utilized for partial update. Creating sub-resource singletons for each use case of updates is not a scalable design approach, as many endpoints could result long-term. URI Template GET/PUT /{version}/{namespace}/{resource}/{resourceId}/{sub-resource} Examples: GET /v1/customers/devices/DEV-FDU233FDSE213f)/vendor-information Idempotency Idempotency is an important aspect of building a fault-tolerant API. Idempotent APIs enable clients to safely retry an operation without worrying about the side-effects that the operation can cause. For example, a client can safely retry an idempotent request in the event of a request failing due to a network connection error. Per HTTP Specification , a method is idempotent if the side-effects of more than one identical requests are the same as those for a single request. Methods GET, HEAD, PUT and DELETE (additionally, TRACE and OPTIONS) are defined idempotent. POST operations by definition are neither safe nor idempotent. All service implementations MUST ensure that safe and idempotent behaviour of HTTP methods is implemented as per HTTP specifications. Services that require idempotency for POST operations MUST be implemented as per the following guidelines. Idempotency For POST Requests POST operations by definition are not idempotent which means that executing POST more than once with the same input creates as many resources. To avoid creation of duplicate resources, an API SHOULD implement the protocol defined in the section below. This guarantees that only one record is created for the same input payload. For many use cases that require idempotency for POST requests, creation of a duplicate record is a severe problem. For example, duplicate records for the use cases that create or execute a payment on an account are not allowed by definition. To track an idempotent request, a unique idempotency key is used and sent in every request. By convention, the API Styleguide defines a header Idempotency-Key for use as an idempotency key for any request that supports idempotency. For the very first request from the client: On the client side: The API client sends a new POST request with the Idempotency-Key header that contains the idempotency key. POST /v1/payments/referenced-payouts-items HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Idempotency-Key: 123e4567-e89b-12d3-a456-426655440000 { \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\" } On the server side: If the call is successful and leads to a resource creation, the service MUST return a 201 Created response to indicate both success and a change of state. Sample response: HTTP/1.1 201 CREATED Content-Type: application/json { \"item_id\": \"CDZEC5MJ8R5HY\", \"links\": [{ \"href\": \"https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY\", \"rel\": \"self\", \"method\": \"GET\" }] } The service MAY send back the idempotency key as part of Idempotency-Key header in the response. For subsequent requests from the client with same input payload: On the client side: The API client sends a POST request with the same idempotency key and input body as before. POST /v1/payments/referenced-payouts-items HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Idempotency-Key: 123e4567-e89b-12d3-a456-426655440000 { \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\" } On the server side: The server, after checking that the call is identical to the first execution, MUST return a 200 OK response with a representation of the resource to indicate that the request has already been processed successfully. Sample response: HTTP/1.1 200 OK Content-Type: application/json { \"item_id\": \"CDZEC5MJ8R5HY\", \"processing_state\": { \"status\": \"PROCESSING\" }, \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\", \"payout_amount\": { \"currency_code\": \"USD\", \"value\": \"2.0\" }, \"payout_destination\": \"9C8SEAESMWFKA\", \"payout_transaction_id\": \"35257aef-54f7-43cf-a258-3b45caf3293\", \"links\": [{ \"href\": \"https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY\", \"rel\": \"self\", \"method\": \"GET\" }] } Uniqueness of Idempotency Key The idempotency key that is supplied as part of every POST request MUST be unique and can not be reused with another request with a different input payload. See error scenarios described below to understand the server behavior for repeating idempotency keys in requests. How to make the key unique is up to the client and its agreed protocol with the server. It is recommended that a UUID or a similar random identifier be used as the idempotency key. It is also recommended that the server implements the idempotency keys to be time-based and, thus, be able to purge or delete a key upon its expiry. Error Scenarios If the Idempotency-Key header is missing for an idempotent request, the service MUST reply with a 400 Bad Request error with a link pointing to the public documentation about this pattern. If there is an attempt to reuse an idempotency key with a different request payload, the service MUST reply with a 422 Unprocessable Entity error with a link pointing to the public documentation about this pattern. For other errors, the service MUST return the appropriate error message. Asynchronous Operations Certain types of operations might require processing of the request in an asynchronous manner (e.g. validating a bank account, processing an image, etc.) in order to avoid long delays on the client side and prevent long-standing open client connections waiting for the operations to complete. For such use cases, APIs MUST employ the following pattern: For POST requests: Return the 202 Accepted HTTP response code. In the response body, include one or more URIs as hypermedia links, which could include: The final URI of the resource where it will be available in future if the ID and path are already known. Clients can then make an HTTP GET request to that URI in order to obtain the completed resource. Until the resource is ready, the final URI SHOULD return the HTTP status code 404 Not Found . { \"href\": \"/v1/namespace/resources/{resourceId}\", \"rel\": \"self\", \"method\": \"GET\" } A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. Implementations MAY provide additional functionality in the form of job control (via PUT / DELETE) if such capabilities are useful to consumers. { \"href\": \"/v1/queue/requests/{requestId}\", \"rel\": \"self\", \"method\": \"GET\" } For PUT/PATCH/DELETE/GET requests: Like POST, you can support PUT/PATCH/DELETE/GET to be asynchronous. The behaviour would be as follows: Return the 202 Accepted HTTP response code. In the response body, include one or more URIs as hypermedia links, which could include: A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. Implementations MAY provide additional functionality in the form of job control (via PUT / DELETE) if such capabilities are useful to consumers. { \"href\": \"/v1/queue/requests/{requestId}\", \"rel\": \"self\", \"method\": \"GET\" } APIs that support both synchronous and asynchronous operations for a particular URI and an HTTP method combination, MUST recognize the Prefer header and exhibit following behavior: If the request contains a Prefer=respond-async header, the service MUST switch the processing to asynchronous mode. If the request doesn't contain a Prefer=respond-async header, the service MUST process the request synchronously. It is desirable that all APIs that implement asynchronous processing, also support webhooks as a mechanism of pushing the processing status to the client.","title":"HTTP Request Standards"},{"location":"unified/requests/#http-request-standards","text":"This section defines how HTTP Requests should be constructed. It includes definitions and examples for each of the HTTP verbs. It also defines how URLs are constructed, and how the URL structure communicates request semantics to the server.","title":"HTTP Request Standards"},{"location":"unified/requests/#http-verb-semantics","text":"API calls may fail for a number of reasons, and the client may not always know if the server failed or if the client simply didn\u2019t get notified of success. For example, there may be a temporary network failure preventing the server\u2019s response from getting back to the client, or the server may have responded but the client HTTP connection already timed out before receiving the response. The following two characteristics help us think about these failure conditions: Safety - Safe calls have no client-visible side effects (in other words, writing to a server-side log file is fine, but changing resource state is not). Read-only APIs should be safe. Idempotency - Idempotent APIs are those where the end result of two or more (identical) successful API calls is the same as the end result of one successful call. Idempotent APIs are therefore retry-able when the client does not know if the call succeeded on the server or not.","title":"HTTP Verb Semantics"},{"location":"unified/requests/#safety-and-idempotency","text":"These two characteristics allow us to reason about failure scenarios with HTTP verb semantics: HTTP Verb Safe? Idempotent? GET Yes Yes POST No Maybe - sending multiple POST requests will result in multiple resources unless both client and server implement idempotency logic via the value of the Idempotency-Key HTTP header property. PUT No Maybe - overwriting a resource with the same state twice is fine, provided there is a way to fail the retry if the resource has been further modified by another actor in the meantime PATCH No No - updating a few fields twice may not result in the same resource state as other fields may change between the two updates DELETE No Yes - deleting a resource that\u2019s already deleted is fine Note: The above analysis is true only for the resource in question. If the service triggers other workflows as a result of an API call, then the service must implement logic to maintain the safety and/or idempotency of the API request. For example, in the case where changing a resource triggers a workflow, systems of record should only be notified if a PUT actually changes the resource .","title":"Safety and Idempotency"},{"location":"unified/requests/#resource-operations-http-verbs-and-url-paths","text":"The HTTP verbs to support endpoint requests should follow standard HTTP semantics. Verb Collection Singular Reified Non-resourceful GET Search Read Status of workflow request Not applicable POST Create (server returns new resource id) Tunnel Create Tunnel PUT Overwrite all Overwrite (or create with client provided id) Not applicable Not applicable PATCH Bulk update Partial update Not applicable Not applicable DELETE Delete all Delete Cancel a workflow request Not applicable \"Tunnel\" refers to taking any action not otherwise represented in the table. It is a way of bypassing the Uniform Interface of REST to take some action that requires more than standard HTTP semantics. HTTP supports two standard ways of updating a resource through the PUT and PATCH verbs. PUT is more common, but expects the client to pass all fields back. PATCH supports partial updates, allowing the client to only send changed fields back. Our recommendation is to use PUT wherever possible, as it\u2019s easier to understand and generally provides a better client experience. PATCH has complicated semantics and is more prone to errors and race conditions. Prefer POST over PUT-with-id for creation of resources. Supporting PUT-with-id requires extra overhead for synchronization and ensuring an id is unique. This can have an impact on performance and reliability. It also adds complexity on the client-side implementation in the form of handling an additional set of error conditions. This style guide does not dictate whether DELETEs are hard deletes or soft. Those semantics will be defined within each API as appropriate to the business.","title":"Resource Operations - HTTP Verbs and URL Paths"},{"location":"unified/requests/#standard-querystring-operations","text":"Where a standard operation isn\u2019t listed below, prefer JSON API format where feasible.","title":"Standard Querystring Operations"},{"location":"unified/requests/#create-resource","text":"For creating a new resource, use POST method. The request body for POST may be somewhat different than for GET/PUT response/request (typically fewer fields as the server will generate some values). In most cases, the service produces an identifier for the resource. In cases where identifier is supplied by the API consumer, use Create New Resource - Client Supplied ID Once the POST has successfully completed, a new resource will be created. Hypermedia links provide an easy way to get the URL of the newly created resource, using the rel: self, in addition to other links for operations that are allowed on the newly created resource. You may provide complete representation of the resource or partial with just HATEOAS links to retrieve the complete representation.","title":"Create Resource"},{"location":"unified/requests/#uri-template","text":"POST /{version}/{namespace}/{resource}","title":"URI Template"},{"location":"unified/requests/#example-request","text":"Note that server-generated values are not provided in the request. POST /v1/vault/credit-cards { \"payer_id\": \"user12345\", \"type\": \"visa\", \"number\": \"4417119669820331\", \"expire_month\": \"11\", \"expire_year\": \"2018\", \"first_name\": \"Betsy\", \"last_name\": \"Buyer\", \"billing_address\": { \"line1\": \"111 First Street\", \"city\": \"Saratoga\", \"country_code\": \"US\", \"state\": \"CA\", \"postal_code\": \"95070\" } }","title":"Example Request:"},{"location":"unified/requests/#example-response","text":"On successful execution, the method returns with status code 201. 201 Created { \"id\": \"CARD-1MD19612EW4364010KGFNJQI\", \"valid_until\": \"2016-05-07T00:00:00Z\", \"state\": \"ok\", \"payer_id\": \"user12345\", \"type\": \"visa\", \"number\": \"xxxxxxxxxxxx0331\", \"expire_month\": \"11\", \"expire_year\": \"2018\", \"first_name\": \"Betsy\", \"last_name\": \"Buyer\", \"links\": [ { \"href\": \"https://api.sandbox.example.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI\", \"rel\": \"self\", \"method\": \"GET\" }, { \"href\": \"https://api.sandbox.example.com/v1/vault/credit-cards/CARD-1MD19612EW4364010KGFNJQI\", \"rel\": \"delete\", \"method\": \"DELETE\" } ] }","title":"Example Response"},{"location":"unified/requests/#create-new-resource-consumer-supplied-identifier","text":"When an API consumer provides the resource identifier, PUT method SHOULD be utilized, as the operation is idempotent, even during creation. The same interaction as Create Resource is used here. 201 Created + response body on resource creation, and 204 No Content + no response body when an existing resource is updated.","title":"Create New Resource - Consumer Supplied Identifier"},{"location":"unified/requests/#collection-resource","text":"A collection resource should return a list of representation of all of the given resources (instances), including any related metadata. An array of resources should be in the items field. Consistent naming of collection resource fields allows API clients to create generic handling for using the provided data across various resource collections. The GET verb should not affect the system, and should not change the response on subsequent requests (unless the underlying data changes), i.e. it should be idempotent. Exceptions to 'changing the system' are typically instrumentation/logging-related. The list of data is presumed to be filtered based on the privileges available to the API client. In other words, it should not be a list of all resources in the domain. It should only be resources for which the client has authorization to view within its current context. Providing a summarized, or minimized version of the data representation can reduce the bandwidth footprint, in cases where individual resources contain a large object. If the service allows partial retrieval of the set, the following patterns MUST be followed.","title":"Collection Resource"},{"location":"unified/requests/#resource-filtering","text":"Often it is desired to be able to filter the set of resources based on a resource property. The filter is defined based on the following conventions and behaviors: filter query argument: ?filter=<filter-def> filter-def: <filter-spec>,...,<filter-spec> filter-spec: <property><operator><value> property: the name of a property within the resource. value: the value to use in the comparison operation operator: a character which indicates the type of operations equals: : less than: < less than or equal: <: greater than: > greater than or equal: >: like: ~ NOTE: there must be leading and/or trailing * character(s) in the value string negation: ! added before the operator Ensure that query definitions are URL-encoded properly Resources matching the filter MUST match all of the <filter-spec> definitions. Except: specifying the same property to be equal to two values is an implicit 'IN' operation. For example: GET /v1/movies?filter=genre:Comedy,genre:RomCom will provide a list of all Comedy or RomCom movies. Examples: GET /v1/movies?filter=gross>=1000000 would get all movies grossing $1M or more GET /v1/movies?filter=genre!~*edy would get all movies not Comedy or Romantic Comedy or Dramedy GET /v1/movies?filter=genre:Comedy,gross>=500000,origin!:us would get all successful (over $500K) foreign comedies This is not meant to be an exhaustive API, but rather a set of simple rules which are generally useful for all APIs. APIs supporting any type of filtering on Collection resources MUST support the above conventions. APIs which need additional capabilities MAY augment the above definitions provided the consumer expectations are not violated, and the meaning of the basic filter definition is not changed. For example, an API may choose to support a more complicated method of filtering based on properties of related resources, as in the following example: GET /v1/movies?filter=actor.name:Kevin%20DBacon might get all movies in which Kevin Bacon played a role.","title":"Resource Filtering"},{"location":"unified/requests/#time-selection","text":"Query parameters with regard to time range could be used to select a subset of items in the following manner: startTime or {propertyName}After A timestamp (in either Unix time or ISO-8601 format) indicating the non-inclusive start of a temporal range. startTime may be used when there is only one unambiguous time dimension; otherwise, the property name should be used (e.g., processedAfter, updatedAfter). The property SHOULD map to a time field in the representation. endTime or {propertyName}Before A timestamp (in either Unix time or ISO-8601 format) indicating the non-inclusive end of a temporal range. endTime may be used when there is only one unambiguous time dimension; otherwise, the property name should be used (e.g., processed_before, updated_before). The property SHOULD map to a time field in the representation.","title":"Time Selection"},{"location":"unified/requests/#sorting","text":"Results could be ordered according to sorting related instructions given by the client. This includes sorting by a specific field's value and sorting order as described in the query parameters below. sortBy A dimension by which items should be sorted; the dimensions SHOULD be an attribute in the item's representation; the default (ascending or descending) is left to the implementation and MUST be specified in the documentation. sortOrder The order, one of asc or desc , indicating ascending or descending order.","title":"Sorting"},{"location":"unified/requests/#pagination","text":"Any resource that could return a large, potentially unbounded list of resources in its GET response MUST implement pagination using the patterns described here.","title":"Pagination"},{"location":"unified/requests/#sample-uri-path","text":"/accounts?pageSize={pageSize}&page={page} Clients MUST assume no inherent ordering of results unless a default sort order has been specified for this collection. It is RECOMMENDED that service implementers specify a default sort order whenever it would be useful.","title":"Sample URI path:"},{"location":"unified/requests/#query-parameters","text":"pageSize : A non-negative, non-zero integer indicating the maximum number of results to return at one time. This parameter: MUST be optional for the client to provide. MUST have a default value, for when the client does not provide a value. page : A non-zero integer representing the page of the results. This parameter: MUST be optional for the client to provide. MUST have a default value of 1 for when the client does not provide a value. MUST respond to a semantically invalid page count, such as zero, with the HTTP status code 400 Bad Request . If a page number is too large -- for instance, if there are only 50 results, but the client requests pageSize=100&page=3 -- the resource MUST respond with the HTTP status code 200 OK and an empty result list. pageToken : In certain cases such as querying on a large data set, in order to optimize the query execution while paginating, querying and retrieving the data based on result set of previous page migh be appropriate. Such a pageToken could be an encrypted value of primary keys to navigate next and previous page along with the directions. totalRequired : A boolean indicating total number of items ( totalItems ) and pages ( totalPages ) are expected to be returned in the response. This parameter: SHOULD be optional for the client to provide. SHOULD have a default value of false. MAY be used by the client in the very first request. The client MAY then cache the values returned in the response to help build subsequent requests. SHOULD only be implemented when it will improve API performance and/or it is necessary for front-end pagination display.","title":"Query Parameters"},{"location":"unified/requests/#response-properties","text":"JSON response to a request of this type SHOULD be an object containing the following properties: items MUST be an array containing the current page of the result list. Unless there are performance or implementation limitations: totalItems SHOULD be used to indicate the total number of items in the full result list, not just this page. If totalRequired has been implemented by an API, then the value SHOULD only be returned when totalRequired is set to true. If totalRequired has not been implemented by an API, then the value MAY be returned in every response if necessary, useful, and performant. If present, this parameter MUST be a non-negative integer. Clients MUST NOT assume that the value of totalItems is constant. The value MAY change from one request to the next. totalPages SHOULD be used to indicate how many pages are available, in total. If totalRequired has been implemented by an API, then the value SHOULD only be returned when totalRequired is set to true. If totalRequired has not been implemented by an API, then the value MAY be returned in every response if necessary, useful, and performant. If present, this parameter MUST be a non-negative, non-zero integer. Clients MUST NOT assume that the value of totalPages is constant. The value MAY change from one request to the next. links SHOULD be an array containing one or more HATEOAS link relations that are relevant for traversing the result list.","title":"Response Properties"},{"location":"unified/requests/#page-navigation","text":"Relationship Description self Refers to the current page of the result list. first Refers to the first page of the result list. If you are using pageToken , you may not return this link. last Refers to the last page of the result list. Returning of this link is optional. You need to return this link only if totalRequired is specified as a query parameter. If you are using pageToken , you may not return this link. next Refers to the next page of the result list. prev Refers to the previous page of the result list. This is a sample JSON schema that returns a collection of resources with pagination: { \"id\": \"plan_list:v1\", \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"description\": \"Resource representing a list of billing plans with basic information.\", \"name\": \"plan_list Resource\", \"type\": \"object\", \"required\": true, \"properties\": { \"plans\": { \"type\": \"array\", \"description\": \"Array of billing plans.\", \"items\": { \"type\": \"object\", \"description\": \"Billing plan details.\", \"$ref\": \"plan.json\" } }, \"totalItems\": { \"type\": \"string\", \"readonly\": true, \"description\": \"Total number of items.\" }, \"totalPages\": { \"type\": \"string\", \"readonly\": true, \"description\": \"Total number of pages.\" }, \"links\": { \"type\": \"array\", \"items\": { \"$ref\": \"http://json-schema.org/draft-04/hyper-schema#\" } } }, \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page}&status={status}\", \"rel\": \"self\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page}&start={start_id}&status={status}\", \"rel\": \"first\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page+1}&status={status}\", \"rel\": \"next\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={page-1}&status={status}\", \"rel\": \"prev\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize={pageSize}&page={last}&status={status}\", \"rel\": \"last\" } ] } This is a sample JSON response that returns a collection of resources with pagination: { \"totalItems\": \"166\", \"totalPages\": \"83\", \"plans\": [ { \"id\": \"P-6EM196669U062173D7QCVDRA\", \"state\": \"ACTIVE\", \"name\": \"Testing1-Regular3\", \"description\": \"Create Plan for Regular\", \"type\": \"FIXED\", \"create_time\": \"2014-08-22T04:41:52.836Z\", \"update_time\": \"2014-08-22T04:41:53.169Z\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans/P-6EM196669U062173D7QCVDRA\", \"rel\": \"self\" } ] }, { \"id\": \"P-83567698LH138572V7QCVZJY\", \"state\": \"ACTIVE\", \"name\": \"Testing1-Regular4\", \"description\": \"Create Plan for Regular\", \"type\": \"INFINITE\", \"create_time\": \"2014-08-22T04:41:55.623Z\", \"update_time\": \"2014-08-22T04:41:56.055Z\", \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans/P-83567698LH138572V7QCVZJY\", \"rel\": \"self\" } ] } ], \"links\": [ { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=3&status=active\", \"rel\": \"self\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=1&first=3&status=active\", \"rel\": \"first\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=2&status=active\", \"rel\": \"prev\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=4&status=active\", \"rel\": \"next\" }, { \"href\": \"https://api.foo.com/v1/payments/billing-plans?pageSize=2&page=82&status=active\", \"rel\": \"last\" } ] }","title":"Page Navigation"},{"location":"unified/requests/#read-single-resource","text":"A single resource is typically derived from the parent collection of resources, often more detailed than an item in the representation of a collection resource. Executing GET should never affect the system, and should not change response on subsequent requests, i.e. it should be idempotent. All identifiers for sensitive data should be non-sequential, and preferably non-numeric. In scenarios where this data might be used as a subordinate to other data, immutable string identifiers should be utilized for easier readability and debugging (i.e. NAME_OF_VALUE vs 1421321 ).","title":"Read Single Resource"},{"location":"unified/requests/#uri-template_1","text":"GET /{version}/{namespace}/{resource}/{resourceId}","title":"URI Template"},{"location":"unified/requests/#example-request_1","text":"GET /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY","title":"Example Request:"},{"location":"unified/requests/#example-response_1","text":"{ \"merchant_customer_id\": \"merchant-1\", \"merchant_id\": \"target\", \"create_time\": \"2014-10-10T16:10:55Z\", \"update_time\": \"2014-10-10T16:10:55Z\", \"first_name\": \"Kartik\", \"last_name\": \"Hattangadi\" }","title":"Example Response:"},{"location":"unified/requests/#http-status","text":"If the provided resource identifier is not found, the response 404 Not Found HTTP status should be returned (even with \u2019soft deleted\u2019 records in data sources). Otherwise, 200 OK HTTP status should be utilized when data is found.","title":"HTTP Status:"},{"location":"unified/requests/#delete-single-resource","text":"In order to enable retries (e.g., poor connectivity), DELETE is treated as idempotent, so it should always respond with a 204 No Content HTTP status. 404 Not Found HTTP status should not be utilized here, as on a second retry a client might mistakenly think the resource never existed at all. GET can be utilized to verify the resources exists prior to DELETE. For a number of reasons, some data exposed as a resource MAY disappear: because it has been specifically deleted, because it expired, because of a policy (e.g., only transactions less than 2 years old are available), etc. Services MAY return a 410 Gone error to a request related to a resource that no longer exists. However, there may be significant costs associated with doing so. Service designers are advised to weigh in those costs and ways to reduce them (e.g., using resource identifiers that can be validated without access to a data store), and MAY return a 404 Not Found instead if those costs are prohibitive.","title":"Delete Single Resource"},{"location":"unified/requests/#uri-template_2","text":"DELETE /{version}/{namespace}/{resource}/{resourceId}","title":"URI Template"},{"location":"unified/requests/#example-request_2","text":"DELETE /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY 204 No Content","title":"Example Request:"},{"location":"unified/requests/#update-single-resource","text":"To perform an update to an entire resource, PUT method MUST be utilized. The same response body supplied in the resource's GET should be provided in the resource's PUT request body. If the update is successful, a 204 No Content HTTP status code (with no response body) is appropriate. Where there is a justifying use case (typically to optimize some client interaction), a 200 OK HTTP status code with a response body can be utilized. While the entire resource's representation must be supplied with the PUT method, the APIs validation logic can enforce constraints regarding fields that are allowed to be updated. These fields can be specified as readOnly in the JSON schema. Fields in the request body can be optional or ignored during deserialization, such as create_time or other system-calculated values. Typical error handling, utilizing the 400 Bad Request status code, should be applied in cases where the client attempts to update fields which are not allowed or if the resource is in a non-updateable state. See Sample Input Validation Error Response for examples of error handling.","title":"Update Single Resource"},{"location":"unified/requests/#uri-template_3","text":"PUT /{version}/{namespace}/{resource}/{resourceId}","title":"URI Template"},{"location":"unified/requests/#example-request_3","text":"PUT /v1/vault/customers/CUSTOMER-66W27667YB813414MKQ4AKDY { \"merchant_customer_id\": \"merchant-1\", \"merchant_id\": \"target\", \"create_time\": \"2014-10-10T16:10:55Z\", \"update_time\": \"2014-10-10T16:10:55Z\", \"first_name\": \"Kartik\", \"last_name\": \"Hattangadi\" }","title":"Example Request:"},{"location":"unified/requests/#http-status_1","text":"Any failed request validation MUST respond with 400 Bad Request HTTP status. If clients attempt to modify read-only fields, this MUST also result in a 400 Bad Request . If there are business rules (more than simple data-type or length constraints), the system SHOULD provide a specific error code and message (in addition to the 400 Bad Request ) for that validation. For situations which require interaction with APIs or processes outside of the current request, the 422 Unprocessable Entity status code is appropriate. After successful update, PUT operations SHOULD respond with 204 No Content status, with no response body.","title":"HTTP Status:"},{"location":"unified/requests/#partially-update-single-resource","text":"Often, previously created resources need to be updated based on customer or facilitator-initiated interactions (like adding items to a cart). In such cases, APIs SHOULD provide an RFC 6902 JSON Patch compatible solution. JSON patch uses the HTTP PATCH method defined in RFC 5789 to enable partial updates to resources. A JSON patch expresses a sequence of operations to apply to a target JSON document. The operations defined by the JSON patch specification include add, remove, replace, move, copy, and test. To support partial updates to resources, APIs SHOULD support add, remove and replace operations. Support for the other operations (move, copy, and test) is left to the individual API owner based on needs. Below is a sample PATCH request to do partial updates to a resource: PATCH /v1/namespace/resources/:id HTTP/1.1 Host: api.foo.com Content-Length: 326 Content-Type: application/json-patch+json If-Match: \"etag-value\" [ { \"op\": \"remove\", \"path\": \"/a/b/c\" }, { \"op\": \"add\", \"path\": \"/a/b/c\", \"value\": [ \"foo\", \"bar\" ] }, { \"op\": \"replace\", \"path\": \"/a/b/c\", \"value\": 42 } ] The value of path is a string containing a RFC 6901 JSON Pointer that references a location within the target document where the operation is performed. For example, the value /a/b/c refers to the element c in the sample JSON below: { \"a\": { \"b\": { \"c\": \"\", \"d\": \"\" }, \"e\": \"\" } }","title":"Partially Update Single Resource"},{"location":"unified/requests/#path-parameter","text":"When JSON Pointer is used with arrays, concurrency protection is best implemented with ETags. In many cases, ETags are not an option: It is expensive to calculate ETags because the API collates data from multiple data sources or has very large response objects. The response data are frequently modified.","title":"path Parameter"},{"location":"unified/requests/#json-pointer-expression","text":"In cases where ETags are not available to provide concurrency protection when updating arrays, it is recommended to use an extension to RFC 6901 which provides expressions of the following form. \"path\": \"/object-name/@filter-expression/attribute-name\" object-name is the name of the collection.The symbol \u201c@\u201d refers to the current object. It also signals the beginning of a filter-expression. The filter-expression SHOULD only contain the following operators: a comparison operator (== for equality) or a Logical AND (&&) operator or both. For example: /address/@id==123/streetName , address/@id==123 && primary==true are valid filter expressions. The right hand side operand for the operator \u201c==\u201d MUST have a value that matches the type of the left hand side operand. For example: addresss/@integer_id == 123 , /address/@string_name == \u2018james\u2019 , /address/@boolean_primary == true , /address/@decimal_number == 12.1 are valid expressions. If the right hand operand of \"==\" is a string then it SHOULD NOT contain any of the following escape sequences: a Line Continuation or a Unicode Escape Sequence. attribute-name is the name of the attribute to which a PATCH operation is applied if the filter condition is met.","title":"JSON Pointer Expression"},{"location":"unified/requests/#patch-array-examples","text":"","title":"PATCH Array Examples"},{"location":"unified/requests/#example-1","text":"\"op\": \"replace\",\"path\": \u201c/address/@id==12345/primary\u201d,\"value\": true This would set the array element \"primary\" to true if the element \"id\" has a value \"12345\".","title":"Example 1:"},{"location":"unified/requests/#example-2","text":"\"op\": \"replace\",\"path\": \u201c/address/@countryCode==\u2019GB\u2019 && type==\u2019office\u2019/active\u201d,\"value\": true This would set the array element \"active\" to true if the element \"countryCode\" equals to \"GB\" and type equals to \"office\".","title":"Example 2:"},{"location":"unified/requests/#other-implementation-considerations-for-patch","text":"It is not necessary that an API support the updating of all attributes via a PATCH operation. An API implementer SHOULD make an informed decision to support PATCH updates only for a subset of attributes through a specific resource operation.","title":"Other Implementation Considerations For PATCH"},{"location":"unified/requests/#responses-to-a-patch-request","text":"Note that the operations are applied sequentially in the order they appear in the payload. If the update is successful, a 204 No Content HTTP status code (with no response body) is appropriate. Where there is a justifying use case (typically to optimize some client interaction) and the request has the header Prefer:return=representation , a 200 OK HTTP status code with a response body can be utilized. Responses body with 200 OK SHOULD return the entire resource representation unless the client uses the fields parameter to reduce the response size. If a PATCH request results in a new resource state that is invalid, the API SHOULD return a 400 Bad Request or 422 Unprocessable Entity. See Sample Input Validation Error Response for examples of error handling.","title":"Responses to a PATCH request"},{"location":"unified/requests/#patch-examples","text":"PATCH examples for modifying objects can be found in RFC 6902 .","title":"PATCH Examples"},{"location":"unified/requests/#projected-response","text":"An API typically responds with full representation of a resource after processing requests for methods such as GET. For efficiency, the client can ask the service to return partial representation using Prefer: return=minimal HTTP header. Here, The determination of what constitutes an appropriate \"minimal\" response is solely at the discretion of the service. To request partial representation with specific field(s), a client can use the fields query parameter. For selecting multiple fields, a comma-separated list of fields SHOULD be used. The following example shows the use of the fields parameter with users API.","title":"Projected Response"},{"location":"unified/requests/#request","text":"HTTP GET without fields parameter GET https://api.foo.com/v1/users/dbrown Authorization: Bearer your_auth_token","title":"Request:"},{"location":"unified/requests/#response","text":"The complete resource representation is returned in the response. { \"uid\": \"dbrown\", \"given_name\": \"David\", \"sn\": \"Brown\", \"location\": \"Austin\", \"department\": \"RISK\", \"title\": \"Manager\", \"manager\": \"ipivin\", \"email\": \"dbrown@foo.com\", \"employeeId\": \"234167\" }","title":"Response:"},{"location":"unified/requests/#request_1","text":"HTTP GET request specifies a subset of the fields. GET https://api.foo.com/v1/users/dbrown?fields=department,title,location Authorization: Bearer your_auth_token","title":"Request:"},{"location":"unified/requests/#response_1","text":"The response has only fields specified by the fields query parameter as well as mandatory fields. 200 OK { \"uid\": \"dbrown\", \"department\": \"RISK\", \"title\": \"Manager\", \"location\": \"Austin\" } You could use the same pattern for Collection Resource as well as following. GET https://api.foo.com/v1/users?fields=department,title,location The response will have entries with the fields specified in request as well as mandatory fields.","title":"Response:"},{"location":"unified/requests/#sub-resource-collection","text":"Sometimes, multiple identifiers are required ('composite keys', in the database lexicon) to identify a given resource. In these scenarios, all behaviors of a Collection Resource are implemented, as a subordinate of another resource. It is always implied that the resourceId in the URL must be the parent of the sub-resources.","title":"Sub-Resource Collection"},{"location":"unified/requests/#cautions","text":"The need to maintain multiple identifiers can create a burden on client developers. Look for opportunities to promote resources with unique identifiers (i.e. there is no need to identify the parent resource) to a first-level resource. Caution should be used in identifying the name of the sub-resource, as to not interfere with the identifier naming conventions of the base resource. In other words, /{version}/{namespace}/{resource}/{resourceId}/{subResourceId} is not appropriate, as the subResourceId has ambiguous meaning. Two levels is a practical limit for resource identifiers API client usability suffers, as the need for clients to maintain state about identifier hierarchy increases complexity. Server developers must validate each level of identifiers in order to verify that they are allowed access, and that they relate to each other, thus increasing risk and complexity. Note these templates/examples are brief: for more detail on the Collection Resource style, see above. Although this section explains the sub-resource collection, all interactions should be the same, simply with the addition of a parent identifier.","title":"Cautions"},{"location":"unified/requests/#uri-templates","text":"POST /{version}/{namespace}/{resource}/{resourceId}/{sub-resource} GET /{version}/{namespace}/{resource}/{resourceId}/{sub-resource} GET /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId} PUT /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId} DELETE /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}/{subResourceId}","title":"URI Templates"},{"location":"unified/requests/#examples","text":"GET /v1/notifications/webhooks/{webhook-id}/event-types POST /v1/factory/widgets/PART-4312/sub-assemblies GET /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG PUT /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG DELETE /v1/factory/widgets/PART-4312/sub-assemblies/INNER-COG","title":"Examples:"},{"location":"unified/requests/#sub-resource-singleton","text":"When a sub-resource has a one-to-one relationship with the parent resource, it could be modeled as a singleton sub-resource . This approach is usually used as a means to reduce the size of a resource, when use cases support segmenting a large resource into smaller resources. For a singleton sub-resource , the name should be a singular noun. As often as possible, that single resource should always be present (i.e. does not respond with 404). The sub-resource should be owned by the parent resource; otherwise this sub-resource should probably be promoted to its own collection resource, and relationships represented with sub-resource collections in the other direction. Sub-resource singletons should not duplicate a resource from another collection. If the singleton sub-resource needs to be created, PUT should be used, as the operation is idempotent, on creation or update. PATCH can be used for partial updates, but should not be available on creation (in part because it is not idempotent). This should not be used as a mechanism to update single or subsets of fields with PUT. The resource should remain intact, and PATCH should be utilized for partial update. Creating sub-resource singletons for each use case of updates is not a scalable design approach, as many endpoints could result long-term.","title":"Sub-Resource Singleton"},{"location":"unified/requests/#uri-template_4","text":"GET/PUT /{version}/{namespace}/{resource}/{resourceId}/{sub-resource}","title":"URI Template"},{"location":"unified/requests/#examples_1","text":"GET /v1/customers/devices/DEV-FDU233FDSE213f)/vendor-information","title":"Examples:"},{"location":"unified/requests/#idempotency","text":"Idempotency is an important aspect of building a fault-tolerant API. Idempotent APIs enable clients to safely retry an operation without worrying about the side-effects that the operation can cause. For example, a client can safely retry an idempotent request in the event of a request failing due to a network connection error. Per HTTP Specification , a method is idempotent if the side-effects of more than one identical requests are the same as those for a single request. Methods GET, HEAD, PUT and DELETE (additionally, TRACE and OPTIONS) are defined idempotent. POST operations by definition are neither safe nor idempotent. All service implementations MUST ensure that safe and idempotent behaviour of HTTP methods is implemented as per HTTP specifications. Services that require idempotency for POST operations MUST be implemented as per the following guidelines.","title":"Idempotency"},{"location":"unified/requests/#idempotency-for-post-requests","text":"POST operations by definition are not idempotent which means that executing POST more than once with the same input creates as many resources. To avoid creation of duplicate resources, an API SHOULD implement the protocol defined in the section below. This guarantees that only one record is created for the same input payload. For many use cases that require idempotency for POST requests, creation of a duplicate record is a severe problem. For example, duplicate records for the use cases that create or execute a payment on an account are not allowed by definition. To track an idempotent request, a unique idempotency key is used and sent in every request. By convention, the API Styleguide defines a header Idempotency-Key for use as an idempotency key for any request that supports idempotency. For the very first request from the client:","title":"Idempotency For POST Requests"},{"location":"unified/requests/#on-the-client-side","text":"The API client sends a new POST request with the Idempotency-Key header that contains the idempotency key. POST /v1/payments/referenced-payouts-items HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Idempotency-Key: 123e4567-e89b-12d3-a456-426655440000 { \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\" }","title":"On the client side:"},{"location":"unified/requests/#on-the-server-side","text":"If the call is successful and leads to a resource creation, the service MUST return a 201 Created response to indicate both success and a change of state.","title":"On the server side:"},{"location":"unified/requests/#sample-response","text":"HTTP/1.1 201 CREATED Content-Type: application/json { \"item_id\": \"CDZEC5MJ8R5HY\", \"links\": [{ \"href\": \"https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY\", \"rel\": \"self\", \"method\": \"GET\" }] } The service MAY send back the idempotency key as part of Idempotency-Key header in the response. For subsequent requests from the client with same input payload:","title":"Sample response:"},{"location":"unified/requests/#on-the-client-side_1","text":"The API client sends a POST request with the same idempotency key and input body as before. POST /v1/payments/referenced-payouts-items HTTP/1.1 Host: api.foo.com Content-Type: application/json Authorization: Bearer oauth2_token Idempotency-Key: 123e4567-e89b-12d3-a456-426655440000 { \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\" }","title":"On the client side:"},{"location":"unified/requests/#on-the-server-side_1","text":"The server, after checking that the call is identical to the first execution, MUST return a 200 OK response with a representation of the resource to indicate that the request has already been processed successfully.","title":"On the server side:"},{"location":"unified/requests/#sample-response_1","text":"HTTP/1.1 200 OK Content-Type: application/json { \"item_id\": \"CDZEC5MJ8R5HY\", \"processing_state\": { \"status\": \"PROCESSING\" }, \"reference_id\": \"4766687568468\", \"reference_type\": \"egflf465vbk7468mvnb\", \"payout_amount\": { \"currency_code\": \"USD\", \"value\": \"2.0\" }, \"payout_destination\": \"9C8SEAESMWFKA\", \"payout_transaction_id\": \"35257aef-54f7-43cf-a258-3b45caf3293\", \"links\": [{ \"href\": \"https://api.foo.com/v1/payments/referenced-payouts-items/CDZEC5MJ8R5HY\", \"rel\": \"self\", \"method\": \"GET\" }] }","title":"Sample response:"},{"location":"unified/requests/#uniqueness-of-idempotency-key","text":"The idempotency key that is supplied as part of every POST request MUST be unique and can not be reused with another request with a different input payload. See error scenarios described below to understand the server behavior for repeating idempotency keys in requests. How to make the key unique is up to the client and its agreed protocol with the server. It is recommended that a UUID or a similar random identifier be used as the idempotency key. It is also recommended that the server implements the idempotency keys to be time-based and, thus, be able to purge or delete a key upon its expiry.","title":"Uniqueness of Idempotency Key"},{"location":"unified/requests/#error-scenarios","text":"If the Idempotency-Key header is missing for an idempotent request, the service MUST reply with a 400 Bad Request error with a link pointing to the public documentation about this pattern. If there is an attempt to reuse an idempotency key with a different request payload, the service MUST reply with a 422 Unprocessable Entity error with a link pointing to the public documentation about this pattern. For other errors, the service MUST return the appropriate error message.","title":"Error Scenarios"},{"location":"unified/requests/#asynchronous-operations","text":"Certain types of operations might require processing of the request in an asynchronous manner (e.g. validating a bank account, processing an image, etc.) in order to avoid long delays on the client side and prevent long-standing open client connections waiting for the operations to complete. For such use cases, APIs MUST employ the following pattern:","title":"Asynchronous Operations"},{"location":"unified/requests/#for-post-requests","text":"Return the 202 Accepted HTTP response code. In the response body, include one or more URIs as hypermedia links, which could include: The final URI of the resource where it will be available in future if the ID and path are already known. Clients can then make an HTTP GET request to that URI in order to obtain the completed resource. Until the resource is ready, the final URI SHOULD return the HTTP status code 404 Not Found . { \"href\": \"/v1/namespace/resources/{resourceId}\", \"rel\": \"self\", \"method\": \"GET\" } A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. Implementations MAY provide additional functionality in the form of job control (via PUT / DELETE) if such capabilities are useful to consumers. { \"href\": \"/v1/queue/requests/{requestId}\", \"rel\": \"self\", \"method\": \"GET\" }","title":"For POST requests:"},{"location":"unified/requests/#for-putpatchdeleteget-requests","text":"Like POST, you can support PUT/PATCH/DELETE/GET to be asynchronous. The behaviour would be as follows: Return the 202 Accepted HTTP response code. In the response body, include one or more URIs as hypermedia links, which could include: A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients SHOULD make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. Implementations MAY provide additional functionality in the form of job control (via PUT / DELETE) if such capabilities are useful to consumers. { \"href\": \"/v1/queue/requests/{requestId}\", \"rel\": \"self\", \"method\": \"GET\" } APIs that support both synchronous and asynchronous operations for a particular URI and an HTTP method combination, MUST recognize the Prefer header and exhibit following behavior: If the request contains a Prefer=respond-async header, the service MUST switch the processing to asynchronous mode. If the request doesn't contain a Prefer=respond-async header, the service MUST process the request synchronously. It is desirable that all APIs that implement asynchronous processing, also support webhooks as a mechanism of pushing the processing status to the client.","title":"For PUT/PATCH/DELETE/GET requests:"},{"location":"unified/resources/","text":"Resource Identifiers Oversimplifying a bit, there are four types of resource endpoints: Collections, Individual Resources, Reified Resources, and Non-resourceful endpoints. In RESTful APIs, the URL path (e.g.without the querystring) acts as an identifier for the resource. As a general principle, all resource URL paths should avoid the use of verbs in the resource name. Collection resources These represent a collection of resources. Prefer plural nouns with no identifier in the URL path. List resources can be filtered, sorted, paged, etc using query parameters. Example: /orders?page=2&size=25&line_items=1 Singular resources These represent a single instance of a resource in a collection. They should be completely and uniquely identified on the URL path. A resource identifier (id) can be a made up composite key when we have no valid shadow key. IDs should be treated as opaque by clients. Example: /orders/12345 Reified resources Reification is the act of naming an abstract concept, which is sometimes useful in RESTful modeling. Reified resources generally represent the intent of a change, as opposed to a simple CRUD operation. As such, they tend to avoid PUTs in favor of immutable resources modeling some user action or workflow. Example: /registrationRequest Non-resourceful endpoints There may be considerations that force us into an intentionally non-resourceful endpoint. For example, you may decide to support searching by credit cards as a POST instead of a GET because we want to keep the credit card number off of the URL. In this case, we are clearly and intentionally breaking the Uniform Interface architectural constraint of REST. To indicate this as intentional, we should put a verb on the path to label this as RPC instead of RESTful. See the next section on Controller Resources for a more in-depth discussion. Example: /orders/search","title":"Resource Identifiers"},{"location":"unified/resources/#resource-identifiers","text":"Oversimplifying a bit, there are four types of resource endpoints: Collections, Individual Resources, Reified Resources, and Non-resourceful endpoints. In RESTful APIs, the URL path (e.g.without the querystring) acts as an identifier for the resource. As a general principle, all resource URL paths should avoid the use of verbs in the resource name.","title":"Resource Identifiers"},{"location":"unified/resources/#collection-resources","text":"These represent a collection of resources. Prefer plural nouns with no identifier in the URL path. List resources can be filtered, sorted, paged, etc using query parameters. Example: /orders?page=2&size=25&line_items=1","title":"Collection resources"},{"location":"unified/resources/#singular-resources","text":"These represent a single instance of a resource in a collection. They should be completely and uniquely identified on the URL path. A resource identifier (id) can be a made up composite key when we have no valid shadow key. IDs should be treated as opaque by clients. Example: /orders/12345","title":"Singular resources"},{"location":"unified/resources/#reified-resources","text":"Reification is the act of naming an abstract concept, which is sometimes useful in RESTful modeling. Reified resources generally represent the intent of a change, as opposed to a simple CRUD operation. As such, they tend to avoid PUTs in favor of immutable resources modeling some user action or workflow. Example: /registrationRequest","title":"Reified resources"},{"location":"unified/resources/#non-resourceful-endpoints","text":"There may be considerations that force us into an intentionally non-resourceful endpoint. For example, you may decide to support searching by credit cards as a POST instead of a GET because we want to keep the credit card number off of the URL. In this case, we are clearly and intentionally breaking the Uniform Interface architectural constraint of REST. To indicate this as intentional, we should put a verb on the path to label this as RPC instead of RESTful. See the next section on Controller Resources for a more in-depth discussion. Example: /orders/search","title":"Non-resourceful endpoints"},{"location":"unified/responses/","text":"HTTP Response Standards HTTP Status Codes RESTful services use HTTP status codes to specify the outcomes of HTTP method execution. HTTP protocol specifies the outcome of a request execution using an integer and a message. The number is known as the status code and the message as the reason phrase. The reason phrase is a human readable message used to clarify the outcome of the response. HTTP protocol categorizes status codes in ranges. Status Code Ranges When responding to API requests, the following status code ranges MUST be used. Range Meaning 2xx Successful execution. It is possible for a method execution to succeed in several ways. This status code specifies which way it succeeded. 3xx Indicates that further action needs to be taken by the user agent in order to fulfill a request. The required action may be carried out by the user agent without interaction with the user, if and only if, the method used in the second request is GET or HEAD. 4xx Usually these are problems with the request, the data in the request, invalid authentication or authorization, etc. In most cases the client can modify their request and resubmit. 5xx Server error: The server was not able to execute the method due to site outage or software defect. 5xx range status codes SHOULD NOT be utilized for validation or logical error handling. Status Reporting Success and failure apply to the whole operation not just to the SOA framework portion or to the business logic portion of code execution. Following are the guidelines for status codes and reason phrases. Success MUST be reported with a status code in the 2xx range. HTTP status codes in the 2xx range MUST be returned only if the complete code execution path is successful. This includes any container/SOA framework code as well as the business logic code execution of the method. A server returning a status code in the 2xx or 3xx range MUST NOT return a response following error.json , or any kind of error code, as the response body. Failures MUST be reported in the 4xx or 5xx range for both system and application errors. There MUST be a consistent, JSON-formatted error response in the body as defined by the error.json schema. This schema is used to qualify the kind of error. Please refer to Error Handling guidelines for more details. A server returning a status code in the 4xx or 5xx range MUST return the error.json response body. For client errors in the 4xx code range, the reason phrase SHOULD provide enough information for the client to be able to determine what caused the error and how to fix it. For server errors in the 5xx code range, the reason phrase and an error response following error.json SHOULD limit the amount of information to avoid exposing internal service implementation details to clients. This is true for both external facing and internal APIs. Service developers should use logging and tracking utilities to provide additional information. Allowed Status Codes List All REST APIs MUST use only the following status codes . The rest are primarily intended for web-services framework developers reporting framework-level errors related to security, content negotiation, etc. APIs MUST NOT return a status code that is not defined in this table. APIs MAY return only some of status codes defined in this table Status Code Description 200 OK General success message. 201 Created Used as a response to POST method execution to indicate successful creation of a resource. If the resource was already created (by a previous execution of the same method, for example), then the server should return status code 200 OK. 202 Accepted Used for asynchronous method execution to specify the server has accepted the request and will execute it at a later time. For more details, please refer Asynchronous Operations. 204 No Content The server has successfully executed the method, but there is no entity body to return. 301 Moved Permanently Used to indicate that the resource is located at a different path. This is typically implemented at the Gateway or Service Mesh level. 302 Found Used to indicate that the resource is temporarily located at a different path. This is typically implemented at the Gateway or Service Mesh level. 304 Not Modified Used in conditional GET operations as part of a caching strategy. 400 Bad Request The request could not be understood by the server. Use this status code to specify if either a) The data as part of the payload cannot be converted to the underlying data type, b) The data is not in the expected data format, c) Required field is not available, or d) Simple data validation type of error. 401 Unauthorized The request requires authentication and none was provided. Note the difference between this and 403 Forbidden . 403 Forbidden The client is not authorized to access the resource, although it may have valid credentials. API could use this code in case business level authorization fails. 404 Not Found The server has not found anything matching the request URI. This either means that the URI is incorrect or the resource is not available. For example, it may be that no data exists in the database at that key. 405 Method Not Allowed The server has not implemented the requested HTTP method. This is typically default behavior for API frameworks. 406 Not Acceptable The server MUST return this status code when it cannot return the payload of the response using the media type requested by the client. For example, if the client sends an Accept: application/xml header, and the API can only generate application/json , the server MUST return 406. 409 Conflict Indicates that the request could not be processed because of conflict in the current state of the resource, such as an edit conflict between multiple simultaneous updates. 415 Unsupported Media Type The server MUST return this status code when the media type of the request\u2019s payload cannot be processed. For example, if the client sends a Content-Type: application/xml header, but the API can only accept application/json , the server MUST return 415. 422 Unprocessable Entity The requested action cannot be performed and may require interaction with APIs or processes outside of the current request. This is distinct from a 500 response in that there are no systemic problems limiting the API from performing the request. 429 Too Many Requests The server must return this status code if the rate limit for the user, the application, or the token has exceeded a predefined value. Defined in Additional HTTP Status Codes RFC 6585 . 500 Internal Server Error This is either a system or application error, and generally indicates that although the client appeared to provide a correct request, something unexpected has gone wrong on the server. A 500 response indicates a server-side software defect or site outage. 500 SHOULD NOT be utilized for client validation or logic error handling. 501 Not Implemented The client made a request for functionality that is currently unsupported. 503 Service Unavailable The server is unable to handle the request for a service due to temporary maintenance. 504 Gateway Timeout A dependency failed to respond within a reasonable timeframe. NOTE: For 202 Accepted response, the response body returned should include one or more URIs as hypermedia links, which could include: The final URI of the resource where it will be available in future if the ID and path are already known. Clients can then make an HTTP GET request to that URI in order to obtain the completed resource. Until the resource is ready, the final URI SHOULD return the HTTP status code 404 Not Found. { \"rel\": \"self\", \"href\": \"/v1/namespace/resources/{resource_id}\", \"method\": \"GET\" } A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients should make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. { \"rel\": \"self\", \"href\": \"/v1/queue/requests/{request_id}, \"method\": \"GET\" }\" HTTP Method to Status Code Mapping For each HTTP method, API developers SHOULD use only status codes marked as \u201cX\u201d in this table. If an API needs to return any of the status codes marked with an X, then the use case SHOULD be reviewed as part of API design review process and maturity level assessment. Most of these status codes are used to support very rare use cases. Status Code GET POST PUT PATCH DELETE 200 \u2013 Success X X X X X 201 \u2013 Created X 202 \u2013 Accepted X X 204 \u2013 No Content X X X 301 \u2013 Moved Permanently 302 \u2013 Found 304 \u2013 Not Modified X 400 \u2013 Bad Request X X X X X 401 \u2013 Unauthorized X X X X X 403 \u2013 Forbidden X X X X X 404 \u2013 Not found X X X X 405 \u2013 Method Not Allowed X X X X X 406 \u2013 Not Acceptable X X X X X 409 \u2013 Conflict X X X X 415 \u2013 Unsupported Media Type X X X 422 \u2013 Unprocessable Entity X X X X X 429 \u2013 Too Many Requests X X X X X 500 \u2013 Internal server Error X X X X X 503 \u2013 Service Unavailable X X X X X GET The purpose of the GET method is to retrieve a resource. On success, a status code 200 OK and a response with the content of the resource is expected. In cases where resource collections are empty (0 items in /v1/namespace/resources), 200 OK is the appropriate status (resource will contain an empty items array). If a resource item is \u2018soft deleted\u2019 in the underlying data, 200 OK is not appropriate ( 404 Not Found is correct) unless the \u2018DELETED\u2019 status is intended to be exposed. POST The primary purpose of POST is to create a resource. If the resource did not exist and was created as part of the execution, then a status code 201 Created SHOULD be returned. It is expected that on a successful execution, a reference to the resource created (in the form of a link or resource identifier) is returned in the response body. Idempotency semantics: If this is a subsequent execution of the same invocation (including the Idempotency-Key header) and the resource was already created, then a status code of 200 OK SHOULD be returned. For more details on idempotency in APIs, refer to idempotency. If a sub-resource is utilized (\u2018controller\u2019 or data resource), and the primary resource identifier is non-existent, 404 Not Found is an appropriate response. POST can also be used while utilizing the controller pattern, 200 OK is the appropriate status code. In rare cases, server generated values may need to be provided in the response, to optimize client flow (if the client necessarily has to perform a GET after PUT). In these cases, 200 OK and a response body are appropriate. PUT Since a PUT request is a wholesale replacement, the client already has the full content of the entity, so 204 No Content + no response body is appropriate in this context. 200 OK + response body should be avoided, since responding with the entire resource can result in large bandwidth usage, especially for bandwidth-sensitive mobile clients. In rare cases, server generated values may need to be provided in the response, to optimize client flow (if the client necessarily has to perform a GET after PUT). In these cases, 200 OK + response body are appropriate. DELETE This method SHOULD return status code 204 as there is no need to return any content in most cases as the request is to delete a resource and it was successfully deleted. As the DELETE method MUST be idempotent as well, it SHOULD still return 204 No Content , even if the resource was already deleted. Usually the API consumer does not care if the resource was deleted as part of this operation, or before. This is also the reason why 204 No Content instead of 404 Not Found should be returned. PATCH This method should follow the same status/response semantics as PUT, 204 No Content status and no response body. POST-as-GET There may be considerations that force us into an intentionally non-resourceful endpoint. This is particularly true when using PII as query parameters / filters. For example, you may decide to support searching by credit cards as a POST instead of a GET because we want to keep the credit card number off of the URL. In this case, we are clearly and intentionally breaking the Uniform Interface architectural constraint of REST. To indicate this as intentional, we should put a verb on the path to label this as RPC instead of RESTful.","title":"HTTP Response Standards"},{"location":"unified/responses/#http-response-standards","text":"","title":"HTTP Response Standards"},{"location":"unified/responses/#http-status-codes","text":"RESTful services use HTTP status codes to specify the outcomes of HTTP method execution. HTTP protocol specifies the outcome of a request execution using an integer and a message. The number is known as the status code and the message as the reason phrase. The reason phrase is a human readable message used to clarify the outcome of the response. HTTP protocol categorizes status codes in ranges.","title":"HTTP Status Codes"},{"location":"unified/responses/#status-code-ranges","text":"When responding to API requests, the following status code ranges MUST be used. Range Meaning 2xx Successful execution. It is possible for a method execution to succeed in several ways. This status code specifies which way it succeeded. 3xx Indicates that further action needs to be taken by the user agent in order to fulfill a request. The required action may be carried out by the user agent without interaction with the user, if and only if, the method used in the second request is GET or HEAD. 4xx Usually these are problems with the request, the data in the request, invalid authentication or authorization, etc. In most cases the client can modify their request and resubmit. 5xx Server error: The server was not able to execute the method due to site outage or software defect. 5xx range status codes SHOULD NOT be utilized for validation or logical error handling.","title":"Status Code Ranges"},{"location":"unified/responses/#status-reporting","text":"Success and failure apply to the whole operation not just to the SOA framework portion or to the business logic portion of code execution. Following are the guidelines for status codes and reason phrases. Success MUST be reported with a status code in the 2xx range. HTTP status codes in the 2xx range MUST be returned only if the complete code execution path is successful. This includes any container/SOA framework code as well as the business logic code execution of the method. A server returning a status code in the 2xx or 3xx range MUST NOT return a response following error.json , or any kind of error code, as the response body. Failures MUST be reported in the 4xx or 5xx range for both system and application errors. There MUST be a consistent, JSON-formatted error response in the body as defined by the error.json schema. This schema is used to qualify the kind of error. Please refer to Error Handling guidelines for more details. A server returning a status code in the 4xx or 5xx range MUST return the error.json response body. For client errors in the 4xx code range, the reason phrase SHOULD provide enough information for the client to be able to determine what caused the error and how to fix it. For server errors in the 5xx code range, the reason phrase and an error response following error.json SHOULD limit the amount of information to avoid exposing internal service implementation details to clients. This is true for both external facing and internal APIs. Service developers should use logging and tracking utilities to provide additional information.","title":"Status Reporting"},{"location":"unified/responses/#allowed-status-codes-list","text":"All REST APIs MUST use only the following status codes . The rest are primarily intended for web-services framework developers reporting framework-level errors related to security, content negotiation, etc. APIs MUST NOT return a status code that is not defined in this table. APIs MAY return only some of status codes defined in this table Status Code Description 200 OK General success message. 201 Created Used as a response to POST method execution to indicate successful creation of a resource. If the resource was already created (by a previous execution of the same method, for example), then the server should return status code 200 OK. 202 Accepted Used for asynchronous method execution to specify the server has accepted the request and will execute it at a later time. For more details, please refer Asynchronous Operations. 204 No Content The server has successfully executed the method, but there is no entity body to return. 301 Moved Permanently Used to indicate that the resource is located at a different path. This is typically implemented at the Gateway or Service Mesh level. 302 Found Used to indicate that the resource is temporarily located at a different path. This is typically implemented at the Gateway or Service Mesh level. 304 Not Modified Used in conditional GET operations as part of a caching strategy. 400 Bad Request The request could not be understood by the server. Use this status code to specify if either a) The data as part of the payload cannot be converted to the underlying data type, b) The data is not in the expected data format, c) Required field is not available, or d) Simple data validation type of error. 401 Unauthorized The request requires authentication and none was provided. Note the difference between this and 403 Forbidden . 403 Forbidden The client is not authorized to access the resource, although it may have valid credentials. API could use this code in case business level authorization fails. 404 Not Found The server has not found anything matching the request URI. This either means that the URI is incorrect or the resource is not available. For example, it may be that no data exists in the database at that key. 405 Method Not Allowed The server has not implemented the requested HTTP method. This is typically default behavior for API frameworks. 406 Not Acceptable The server MUST return this status code when it cannot return the payload of the response using the media type requested by the client. For example, if the client sends an Accept: application/xml header, and the API can only generate application/json , the server MUST return 406. 409 Conflict Indicates that the request could not be processed because of conflict in the current state of the resource, such as an edit conflict between multiple simultaneous updates. 415 Unsupported Media Type The server MUST return this status code when the media type of the request\u2019s payload cannot be processed. For example, if the client sends a Content-Type: application/xml header, but the API can only accept application/json , the server MUST return 415. 422 Unprocessable Entity The requested action cannot be performed and may require interaction with APIs or processes outside of the current request. This is distinct from a 500 response in that there are no systemic problems limiting the API from performing the request. 429 Too Many Requests The server must return this status code if the rate limit for the user, the application, or the token has exceeded a predefined value. Defined in Additional HTTP Status Codes RFC 6585 . 500 Internal Server Error This is either a system or application error, and generally indicates that although the client appeared to provide a correct request, something unexpected has gone wrong on the server. A 500 response indicates a server-side software defect or site outage. 500 SHOULD NOT be utilized for client validation or logic error handling. 501 Not Implemented The client made a request for functionality that is currently unsupported. 503 Service Unavailable The server is unable to handle the request for a service due to temporary maintenance. 504 Gateway Timeout A dependency failed to respond within a reasonable timeframe. NOTE: For 202 Accepted response, the response body returned should include one or more URIs as hypermedia links, which could include: The final URI of the resource where it will be available in future if the ID and path are already known. Clients can then make an HTTP GET request to that URI in order to obtain the completed resource. Until the resource is ready, the final URI SHOULD return the HTTP status code 404 Not Found. { \"rel\": \"self\", \"href\": \"/v1/namespace/resources/{resource_id}\", \"method\": \"GET\" } A temporary request queue URI where the status of the operation may be obtained via some temporary identifier. Clients should make an HTTP GET request to obtain the status of the operation which MAY include such information as completion state, ETA, and final URI once it is completed. { \"rel\": \"self\", \"href\": \"/v1/queue/requests/{request_id}, \"method\": \"GET\" }\"","title":"Allowed Status Codes List"},{"location":"unified/responses/#http-method-to-status-code-mapping","text":"For each HTTP method, API developers SHOULD use only status codes marked as \u201cX\u201d in this table. If an API needs to return any of the status codes marked with an X, then the use case SHOULD be reviewed as part of API design review process and maturity level assessment. Most of these status codes are used to support very rare use cases. Status Code GET POST PUT PATCH DELETE 200 \u2013 Success X X X X X 201 \u2013 Created X 202 \u2013 Accepted X X 204 \u2013 No Content X X X 301 \u2013 Moved Permanently 302 \u2013 Found 304 \u2013 Not Modified X 400 \u2013 Bad Request X X X X X 401 \u2013 Unauthorized X X X X X 403 \u2013 Forbidden X X X X X 404 \u2013 Not found X X X X 405 \u2013 Method Not Allowed X X X X X 406 \u2013 Not Acceptable X X X X X 409 \u2013 Conflict X X X X 415 \u2013 Unsupported Media Type X X X 422 \u2013 Unprocessable Entity X X X X X 429 \u2013 Too Many Requests X X X X X 500 \u2013 Internal server Error X X X X X 503 \u2013 Service Unavailable X X X X X","title":"HTTP Method to Status Code Mapping"},{"location":"unified/responses/#get","text":"The purpose of the GET method is to retrieve a resource. On success, a status code 200 OK and a response with the content of the resource is expected. In cases where resource collections are empty (0 items in /v1/namespace/resources), 200 OK is the appropriate status (resource will contain an empty items array). If a resource item is \u2018soft deleted\u2019 in the underlying data, 200 OK is not appropriate ( 404 Not Found is correct) unless the \u2018DELETED\u2019 status is intended to be exposed.","title":"GET"},{"location":"unified/responses/#post","text":"The primary purpose of POST is to create a resource. If the resource did not exist and was created as part of the execution, then a status code 201 Created SHOULD be returned. It is expected that on a successful execution, a reference to the resource created (in the form of a link or resource identifier) is returned in the response body. Idempotency semantics: If this is a subsequent execution of the same invocation (including the Idempotency-Key header) and the resource was already created, then a status code of 200 OK SHOULD be returned. For more details on idempotency in APIs, refer to idempotency. If a sub-resource is utilized (\u2018controller\u2019 or data resource), and the primary resource identifier is non-existent, 404 Not Found is an appropriate response. POST can also be used while utilizing the controller pattern, 200 OK is the appropriate status code. In rare cases, server generated values may need to be provided in the response, to optimize client flow (if the client necessarily has to perform a GET after PUT). In these cases, 200 OK and a response body are appropriate.","title":"POST"},{"location":"unified/responses/#put","text":"Since a PUT request is a wholesale replacement, the client already has the full content of the entity, so 204 No Content + no response body is appropriate in this context. 200 OK + response body should be avoided, since responding with the entire resource can result in large bandwidth usage, especially for bandwidth-sensitive mobile clients. In rare cases, server generated values may need to be provided in the response, to optimize client flow (if the client necessarily has to perform a GET after PUT). In these cases, 200 OK + response body are appropriate.","title":"PUT"},{"location":"unified/responses/#delete","text":"This method SHOULD return status code 204 as there is no need to return any content in most cases as the request is to delete a resource and it was successfully deleted. As the DELETE method MUST be idempotent as well, it SHOULD still return 204 No Content , even if the resource was already deleted. Usually the API consumer does not care if the resource was deleted as part of this operation, or before. This is also the reason why 204 No Content instead of 404 Not Found should be returned.","title":"DELETE"},{"location":"unified/responses/#patch","text":"This method should follow the same status/response semantics as PUT, 204 No Content status and no response body.","title":"PATCH"},{"location":"unified/responses/#post-as-get","text":"There may be considerations that force us into an intentionally non-resourceful endpoint. This is particularly true when using PII as query parameters / filters. For example, you may decide to support searching by credit cards as a POST instead of a GET because we want to keep the credit card number off of the URL. In this case, we are clearly and intentionally breaking the Uniform Interface architectural constraint of REST. To indicate this as intentional, we should put a verb on the path to label this as RPC instead of RESTful.","title":"POST-as-GET"},{"location":"unified/security/","text":"Security Authentication & Authorization OAuth 2.0 has become the de-facto standard for API security. OpenId Connect (OIDC) is a simple identity layer on top of the OAuth 2.0 that enables clients to verify the identity of the end-user. Every authenticated API endpoint must be secured using OAuth 2.0/OpenId Connect. Please refer to the Authentication section of the official OpenAPI Specification on how to specify security definitions in your API. For OpenID Connect, use a bearer HTTP authentication scheme with a JSON Web Token (JWT) format. We recommend using appropriate OAuth2.0 flows when Authenticating and Authorizing different kinds of API consumers. Machine to Machine communication For situations involving communication between two systems that trust each other. For example; Batch jobs or system jobs running in the background. Or, if a user identity (authentication) and role (authorization) has already been established, and the participating systems trust each other to have established this beforehand. Use the OAuth2.0 Client Credentials Flow, where client credentials (client ID and client Secret) are exchanged for an access token. API Usage with an end user context accessed In many cases you need to get a user context into the API call, i.e. the backend service needs to know on behalf of which actual user an API call is done. Confidential Clients (clients that are able to keep secret/credentials confidential, i.e. server side) should use the OAuth2.0 Authorization Code grant to get access to APIs (in case the API supports this flow). Non-confidential clients , such as Single Page Application (aka Public clients) must now use the OAuth2.0 Authorization Code grant with flow with the PKCE extension. APIs without end user context Clients who want to use an API without actually having an end user context can still make use of a similar approach to getting access tokens to the API. By using a device ID or even a random number as client credentials, rate limiting and such can be applied to a specific client. The Authorization Server would then usually unconditionally accept the client\u2019s credentials and issue tokens. You would then still have the possibility to revoke or at least limit access to specific devices/IDs in your Authorization Server implementation. Confidential Clients should use the OAuth2.0 Authorization Code grant to get access to APIs (in case the API supports this flow). Non-confidential clients , such as Single Page Application (aka Public clients) must now use the OAuth2.0 Authorization Code grant with flow with the PKCE extension Defining OAuth 2.0 Scopes Scopes are a mechanism to restrict API consumers access to an API. APIs must define scopes to protect their resources. Thus, at least one scope must be assigned to each endpoint. The challenge when defining scopes for an API is to not get carried away with defining too many scopes. Users need to be able to understand the scope of the authorization they are granting, and this will be presented to the user in a list. Points to consider when defining scopes; Read vs. Write \u2013 Typically API consumers that need to be able to create content on behalf of a user need a different level of access from API consumers that only need to read a user\u2019s public data. For the majority of use cases, restricting access to specific API endpoints using read and write is sufficient for controlling access for API consumers Restricting access to sensitive information \u2013 Sensitive information such as PII and PHI need to be restricted and should therefore require a different scope Selectively enabling access to functionality \u2013 A great use of scope is to selectively enable access to a user\u2019s account based on the functionality needed. For example, Google offers a set of scopes for their various services such as Google Drive, Gmail, YouTube, etc. Limiting Access to Billable Resources \u2013 If a service provides an API that may cause the user to incur charges, scope is a great way to protect against applications abusing this. NOTE: All OAuth 2.0 claims for APIs must be part of a common scope to avoid confusion across API providers Scope Naming Convention The naming convention for scopes MUST identify the name of the scope and the admissible action for the scope. The name of the scope SHOULD be a dot-separated tuple containing the namespace, an optional resource name, and an optional category name. The namespace SHOULD match the API URL namespace component, as SHOULD the resource scope (if necessary). Scopes MUST use : to separate the name of the scope from the permissible action. The full scope name MUST be formed as a URI namespacing the scopes to the Organization. https://api.example.com/auth/<namespace>[.<resource>][.<category>]:<action> where [] s indicate optional parts of the scope name. For example, https://api.example.com/auth/platform.teams:register allows a user with this scope to register a new team with the DI platform. This also allows for an API endpoint to share a more generic namespace-level scope when appropriate. For example, instead of defining a specific scope for each resource, the namespace-level scope https://api.example.com/auth/platform:write can be shared across multiple resources within the platform namespace. Generic Read Scope For endpoints which do not have security implications, a generic https://api.example.com/auth/public:read scope can be used to allow generic access to endpoints. Resolvable Scope URI The URI SHOULD be resolvable to provide additional information pertaining to the capabilities enabled by the scope. If the query uses Accept: application/json , then a machine-readable form of the documentation MUST be returned. If the query uses Accept: text/html , then human-formatted HTML or a redirect to appropriate documentation pages MAY be returned. Otherwise, the machine-readable format MAY be returned in all cases. Secure transport everywhere All API resources (internal and external) must be accessed via a secure communication channel using Transport Layer Security (TLS). Another advantage of always using TLS is that guaranteed encrypted communications simplifies authentication efforts - you can secure the communication with simple access tokens instead of having to sign each API request. Personally Identifiable Information Personally Identifiable Information (PII) is any sensitive information that a third-party could use to identify an entity, such as a veteran, patient, or client. PII should remain private and secure from any party except the owner of that information. To avoid making PII vulnerable, the following practices are required: Avoid directly logging PII for monitoring usage. If an API needs to log metadata pertaining to a request, obfuscate the data or use a request identifier not derived from PII. The presence of PII as a query parameter requires the use of the complex query payload. This avoids the use of PII in query params, path params, a URL, or HTTP headers. Clearly define which PII is accessible via a given set of endpoints, and define permissions/scopes based on that access. Note: As mentioned above < >, when supporting query parameters with PII, we create a non-RESTful endpoint as follows: /<collection>/search with a payload body containing the search query parameters: json { \"query\": { \"relations\": [ { \"type\": \"conjunction\", \"operator\": \"and\", \"relations\": [ { \"type\": \"criteria\", \"propertyName\": \"name\", \"operator\": \"equals\", \"value\": \"something\" }, { \"type\": \"conjunction\", \"operator\": \"or\", \"relations\": [ { \"type\": \"criteria\", \"propertyName\": \"age\", \"operator\": \"lt\", \"value\": \"18\" }, { \"type\": \"criteria\", \"propertyName\": \"age\", \"operator\": \"gt\", \"value\": \"65\" } ] } ] } ] } }","title":"Security"},{"location":"unified/security/#security","text":"","title":"Security"},{"location":"unified/security/#authentication-authorization","text":"OAuth 2.0 has become the de-facto standard for API security. OpenId Connect (OIDC) is a simple identity layer on top of the OAuth 2.0 that enables clients to verify the identity of the end-user. Every authenticated API endpoint must be secured using OAuth 2.0/OpenId Connect. Please refer to the Authentication section of the official OpenAPI Specification on how to specify security definitions in your API. For OpenID Connect, use a bearer HTTP authentication scheme with a JSON Web Token (JWT) format. We recommend using appropriate OAuth2.0 flows when Authenticating and Authorizing different kinds of API consumers.","title":"Authentication &amp; Authorization"},{"location":"unified/security/#machine-to-machine-communication","text":"For situations involving communication between two systems that trust each other. For example; Batch jobs or system jobs running in the background. Or, if a user identity (authentication) and role (authorization) has already been established, and the participating systems trust each other to have established this beforehand. Use the OAuth2.0 Client Credentials Flow, where client credentials (client ID and client Secret) are exchanged for an access token.","title":"Machine to Machine communication"},{"location":"unified/security/#api-usage-with-an-end-user-context-accessed","text":"In many cases you need to get a user context into the API call, i.e. the backend service needs to know on behalf of which actual user an API call is done. Confidential Clients (clients that are able to keep secret/credentials confidential, i.e. server side) should use the OAuth2.0 Authorization Code grant to get access to APIs (in case the API supports this flow). Non-confidential clients , such as Single Page Application (aka Public clients) must now use the OAuth2.0 Authorization Code grant with flow with the PKCE extension.","title":"API Usage with an end user context accessed"},{"location":"unified/security/#apis-without-end-user-context","text":"Clients who want to use an API without actually having an end user context can still make use of a similar approach to getting access tokens to the API. By using a device ID or even a random number as client credentials, rate limiting and such can be applied to a specific client. The Authorization Server would then usually unconditionally accept the client\u2019s credentials and issue tokens. You would then still have the possibility to revoke or at least limit access to specific devices/IDs in your Authorization Server implementation. Confidential Clients should use the OAuth2.0 Authorization Code grant to get access to APIs (in case the API supports this flow). Non-confidential clients , such as Single Page Application (aka Public clients) must now use the OAuth2.0 Authorization Code grant with flow with the PKCE extension","title":"APIs without end user context"},{"location":"unified/security/#defining-oauth-20-scopes","text":"Scopes are a mechanism to restrict API consumers access to an API. APIs must define scopes to protect their resources. Thus, at least one scope must be assigned to each endpoint. The challenge when defining scopes for an API is to not get carried away with defining too many scopes. Users need to be able to understand the scope of the authorization they are granting, and this will be presented to the user in a list. Points to consider when defining scopes; Read vs. Write \u2013 Typically API consumers that need to be able to create content on behalf of a user need a different level of access from API consumers that only need to read a user\u2019s public data. For the majority of use cases, restricting access to specific API endpoints using read and write is sufficient for controlling access for API consumers Restricting access to sensitive information \u2013 Sensitive information such as PII and PHI need to be restricted and should therefore require a different scope Selectively enabling access to functionality \u2013 A great use of scope is to selectively enable access to a user\u2019s account based on the functionality needed. For example, Google offers a set of scopes for their various services such as Google Drive, Gmail, YouTube, etc. Limiting Access to Billable Resources \u2013 If a service provides an API that may cause the user to incur charges, scope is a great way to protect against applications abusing this. NOTE: All OAuth 2.0 claims for APIs must be part of a common scope to avoid confusion across API providers","title":"Defining OAuth 2.0 Scopes"},{"location":"unified/security/#scope-naming-convention","text":"The naming convention for scopes MUST identify the name of the scope and the admissible action for the scope. The name of the scope SHOULD be a dot-separated tuple containing the namespace, an optional resource name, and an optional category name. The namespace SHOULD match the API URL namespace component, as SHOULD the resource scope (if necessary). Scopes MUST use : to separate the name of the scope from the permissible action. The full scope name MUST be formed as a URI namespacing the scopes to the Organization. https://api.example.com/auth/<namespace>[.<resource>][.<category>]:<action> where [] s indicate optional parts of the scope name. For example, https://api.example.com/auth/platform.teams:register allows a user with this scope to register a new team with the DI platform. This also allows for an API endpoint to share a more generic namespace-level scope when appropriate. For example, instead of defining a specific scope for each resource, the namespace-level scope https://api.example.com/auth/platform:write can be shared across multiple resources within the platform namespace.","title":"Scope Naming Convention"},{"location":"unified/security/#generic-read-scope","text":"For endpoints which do not have security implications, a generic https://api.example.com/auth/public:read scope can be used to allow generic access to endpoints.","title":"Generic Read Scope"},{"location":"unified/security/#resolvable-scope-uri","text":"The URI SHOULD be resolvable to provide additional information pertaining to the capabilities enabled by the scope. If the query uses Accept: application/json , then a machine-readable form of the documentation MUST be returned. If the query uses Accept: text/html , then human-formatted HTML or a redirect to appropriate documentation pages MAY be returned. Otherwise, the machine-readable format MAY be returned in all cases.","title":"Resolvable Scope URI"},{"location":"unified/security/#secure-transport-everywhere","text":"All API resources (internal and external) must be accessed via a secure communication channel using Transport Layer Security (TLS). Another advantage of always using TLS is that guaranteed encrypted communications simplifies authentication efforts - you can secure the communication with simple access tokens instead of having to sign each API request.","title":"Secure transport everywhere"},{"location":"unified/security/#personally-identifiable-information","text":"Personally Identifiable Information (PII) is any sensitive information that a third-party could use to identify an entity, such as a veteran, patient, or client. PII should remain private and secure from any party except the owner of that information. To avoid making PII vulnerable, the following practices are required: Avoid directly logging PII for monitoring usage. If an API needs to log metadata pertaining to a request, obfuscate the data or use a request identifier not derived from PII. The presence of PII as a query parameter requires the use of the complex query payload. This avoids the use of PII in query params, path params, a URL, or HTTP headers. Clearly define which PII is accessible via a given set of endpoints, and define permissions/scopes based on that access. Note: As mentioned above < >, when supporting query parameters with PII, we create a non-RESTful endpoint as follows: /<collection>/search with a payload body containing the search query parameters: json { \"query\": { \"relations\": [ { \"type\": \"conjunction\", \"operator\": \"and\", \"relations\": [ { \"type\": \"criteria\", \"propertyName\": \"name\", \"operator\": \"equals\", \"value\": \"something\" }, { \"type\": \"conjunction\", \"operator\": \"or\", \"relations\": [ { \"type\": \"criteria\", \"propertyName\": \"age\", \"operator\": \"lt\", \"value\": \"18\" }, { \"type\": \"criteria\", \"propertyName\": \"age\", \"operator\": \"gt\", \"value\": \"65\" } ] } ] } ] } }","title":"Personally Identifiable Information"},{"location":"unified/service-principles/","text":"Service Design Principles This section captures the principles guiding the design of the services that expose APIs to internal and external developers, agencies, partners and affiliates. A service refers to functionality pertaining to a particular capability, exposed as an API. Following are the core design principles for a service. Loose Coupling Services and consumers must be loosely coupled to each other. Coupling refers to a connection or relationship between two things. A measure of coupling is comparable to a level of dependency. This principle advocates the design of service contracts, with a constant emphasis on reducing (loosening) dependencies between the service contract, its implementation, and service consumers. The principle of Loose Coupling promotes the independent design and evolution of a service\u2019s logic and implementation while still emphasizing baseline interoperability with consumers that have come to rely on the service\u2019s capabilities. This principle implies the following: A service contract should not expose implementation details. A service contract can evolve without impacting existing consumers. A service in a particular domain can evolve independently of other domains. Encapsulation A domain service can access data and functionality it does not own only through other service contracts. A service exposes functionality that comprises the capability and data it owns and implements, as well as the capability and data it depends upon which it does not own. This principle advocates that any capability or data that a service depends on and which it does not own must only be accessed through service contracts. This principle implies the following: A service has a clear isolation boundary - a clear scope of ownership in terms of functionality and data. A service cannot expose the data it does not own directly. Stability Service contracts must be stable. Services must be designed in such a way that the contract they expose remains valid for existing customers. Should the service contract need to evolve in an incompatible fashion for the consumer, this should be communicated clearly. This principle implies the following: Existing clients of a service must be supported for a documented period of time. Additional functionality must be introduced in a way that does not impact existing consumers. Deprecation and migration policies must be clearly stated to set consumers\u2019 expectations. Results of applying this principle can be seen in the sections on API Versioning. Reusable Services must be developed to be reusable across multiple contexts and by multiple consumers. The main goal of an API platform is to enable applications to be developed quickly and cost effectively by using and combining services. This principle advocates that services be developed in a manner that enables them to be used by multiple consumers and in multiple contexts, some of which may evolve over time. This principle implies the following: A service contract should be designed for not just the immediate context, but with support and/or extensibility to be used by multiple consumers in different contexts. A service contract may need to incrementally evolve to support multiple contexts and consumers over time. Contract-based Functionality and data must only be exposed through standardized service contracts. A service exposes its purpose and capabilities via a service contract. A service contract is comprised of functional aspects, non-functional aspects (such as availability, response-time), and business aspects (such as cost-per-call, terms and conditions). Standardized means that the service contracts must be compliant with the contract design standards. This principle advocates that all functionality and data must only be exposed through standardized service contracts. Consumers of services can, therefore, understand and access functionality and data only through service contracts. This principle implies the following: Functionality and data cannot be understood or accessed outside of service contracts. Each piece of data (such as that managed in a datastore) is owned by only one service. Consistency Services must follow a common set of rules, interaction styles, vocabulary and shared types. A set of rules prescribes the definition of services in order to expose those in a consistent manner. This principle increases the ease of use of the API platform by reducing the learning curve for consumers of new services. This principle implies the following: A set of standards is defined for services with which to comply. A service should use vocabulary from common and shared dictionaries. Compatible interaction styles, service granularity and shared types are key for full interoperability and ease of service compositions. Ease Of Use Services must be easy to use and compose in consumers (and applications). A service that is difficult and time consuming to use reduces the benefits of a microservices architecture by encouraging consumers to find alternate mechanisms to access the same functionality. Composability means that services can be combined easily because the service contracts and access protocols are consistent, and each service contract does not have to be understood independently. This principle implies the following: A service contract is easily discoverable and understandable. Service contracts and protocols are consistent in all aspects that they can be - e.g. identification and authentication mechanisms, error semantics, common type usage, pagination, etc. A service has clear ownership, so that consumer providers can reach service owners regarding SLAs, requirements, and issues. A consumer provider can easily integrate, test, and deploy a consumer that uses this service. A consumer provider can easily understand the non-functional guarantees provided by a service. Externalizable A service must be designed so that the functionality it provides is easily accessible to consumers outside the team. A service is developed for use by consumers that may be from another domain or team, another business unit or another company. In all of these cases, the functionality exposed is the same; what changes is the access mechanism or the policies enforced by a service, like authentication, authorization and rate-limiting. Since the functionality exposed is the same, the service should be designed once and then externalized based on business needs through appropriate policies. This principle implies the following: The service interface must be derived from the domain model and the intended use-cases it is meant to support. The service contract and access (binding) protocols supported must meet the consumer\u2019s needs. The externalization of a service must not require reimplementation, or a change in service contract. Observability A service must provide a way for consumers to understand its operational characteristics. Consumers need a way to understand the operational properties of a system in a (near) real-time manner. This is critical to a consumer's ability to support their own systems which are dependent upon the service. This principle implies the following: The service should provide a method for a consumer to view its health status. The service should provide access to metrics related to SLAs/SLOs. The consumer should be able to access some level of logging or response information related to their own specific queries.","title":"Service Design Principles"},{"location":"unified/service-principles/#service-design-principles","text":"This section captures the principles guiding the design of the services that expose APIs to internal and external developers, agencies, partners and affiliates. A service refers to functionality pertaining to a particular capability, exposed as an API. Following are the core design principles for a service.","title":"Service Design Principles"},{"location":"unified/service-principles/#loose-coupling","text":"Services and consumers must be loosely coupled to each other. Coupling refers to a connection or relationship between two things. A measure of coupling is comparable to a level of dependency. This principle advocates the design of service contracts, with a constant emphasis on reducing (loosening) dependencies between the service contract, its implementation, and service consumers. The principle of Loose Coupling promotes the independent design and evolution of a service\u2019s logic and implementation while still emphasizing baseline interoperability with consumers that have come to rely on the service\u2019s capabilities. This principle implies the following: A service contract should not expose implementation details. A service contract can evolve without impacting existing consumers. A service in a particular domain can evolve independently of other domains.","title":"Loose Coupling"},{"location":"unified/service-principles/#encapsulation","text":"A domain service can access data and functionality it does not own only through other service contracts. A service exposes functionality that comprises the capability and data it owns and implements, as well as the capability and data it depends upon which it does not own. This principle advocates that any capability or data that a service depends on and which it does not own must only be accessed through service contracts. This principle implies the following: A service has a clear isolation boundary - a clear scope of ownership in terms of functionality and data. A service cannot expose the data it does not own directly.","title":"Encapsulation"},{"location":"unified/service-principles/#stability","text":"Service contracts must be stable. Services must be designed in such a way that the contract they expose remains valid for existing customers. Should the service contract need to evolve in an incompatible fashion for the consumer, this should be communicated clearly. This principle implies the following: Existing clients of a service must be supported for a documented period of time. Additional functionality must be introduced in a way that does not impact existing consumers. Deprecation and migration policies must be clearly stated to set consumers\u2019 expectations. Results of applying this principle can be seen in the sections on API Versioning.","title":"Stability"},{"location":"unified/service-principles/#reusable","text":"Services must be developed to be reusable across multiple contexts and by multiple consumers. The main goal of an API platform is to enable applications to be developed quickly and cost effectively by using and combining services. This principle advocates that services be developed in a manner that enables them to be used by multiple consumers and in multiple contexts, some of which may evolve over time. This principle implies the following: A service contract should be designed for not just the immediate context, but with support and/or extensibility to be used by multiple consumers in different contexts. A service contract may need to incrementally evolve to support multiple contexts and consumers over time.","title":"Reusable"},{"location":"unified/service-principles/#contract-based","text":"Functionality and data must only be exposed through standardized service contracts. A service exposes its purpose and capabilities via a service contract. A service contract is comprised of functional aspects, non-functional aspects (such as availability, response-time), and business aspects (such as cost-per-call, terms and conditions). Standardized means that the service contracts must be compliant with the contract design standards. This principle advocates that all functionality and data must only be exposed through standardized service contracts. Consumers of services can, therefore, understand and access functionality and data only through service contracts. This principle implies the following: Functionality and data cannot be understood or accessed outside of service contracts. Each piece of data (such as that managed in a datastore) is owned by only one service.","title":"Contract-based"},{"location":"unified/service-principles/#consistency","text":"Services must follow a common set of rules, interaction styles, vocabulary and shared types. A set of rules prescribes the definition of services in order to expose those in a consistent manner. This principle increases the ease of use of the API platform by reducing the learning curve for consumers of new services. This principle implies the following: A set of standards is defined for services with which to comply. A service should use vocabulary from common and shared dictionaries. Compatible interaction styles, service granularity and shared types are key for full interoperability and ease of service compositions.","title":"Consistency"},{"location":"unified/service-principles/#ease-of-use","text":"Services must be easy to use and compose in consumers (and applications). A service that is difficult and time consuming to use reduces the benefits of a microservices architecture by encouraging consumers to find alternate mechanisms to access the same functionality. Composability means that services can be combined easily because the service contracts and access protocols are consistent, and each service contract does not have to be understood independently. This principle implies the following: A service contract is easily discoverable and understandable. Service contracts and protocols are consistent in all aspects that they can be - e.g. identification and authentication mechanisms, error semantics, common type usage, pagination, etc. A service has clear ownership, so that consumer providers can reach service owners regarding SLAs, requirements, and issues. A consumer provider can easily integrate, test, and deploy a consumer that uses this service. A consumer provider can easily understand the non-functional guarantees provided by a service.","title":"Ease Of Use"},{"location":"unified/service-principles/#externalizable","text":"A service must be designed so that the functionality it provides is easily accessible to consumers outside the team. A service is developed for use by consumers that may be from another domain or team, another business unit or another company. In all of these cases, the functionality exposed is the same; what changes is the access mechanism or the policies enforced by a service, like authentication, authorization and rate-limiting. Since the functionality exposed is the same, the service should be designed once and then externalized based on business needs through appropriate policies. This principle implies the following: The service interface must be derived from the domain model and the intended use-cases it is meant to support. The service contract and access (binding) protocols supported must meet the consumer\u2019s needs. The externalization of a service must not require reimplementation, or a change in service contract.","title":"Externalizable"},{"location":"unified/service-principles/#observability","text":"A service must provide a way for consumers to understand its operational characteristics. Consumers need a way to understand the operational properties of a system in a (near) real-time manner. This is critical to a consumer's ability to support their own systems which are dependent upon the service. This principle implies the following: The service should provide a method for a consumer to view its health status. The service should provide access to metrics related to SLAs/SLOs. The consumer should be able to access some level of logging or response information related to their own specific queries.","title":"Observability"},{"location":"unified/versioning/","text":"API Versioning This section describes how to version APIs. It describes API\u2019s lifecycle states, enumerates versioning policy, describes backwards compatibility related guidelines and describes an End-Of-Life policy. API Versioning Strategy APIs should be designed so that they are extensible and backward compatible. An API is backward compatible if a new change to the API does not break existing API consumers. This minimizes the work required for consumers to utilize new releases of the API services. However, there are cases where API providers need to introduce breaking changes. In such cases, API versioning provides the flexibility to roll out a new version of the API containing breaking changes. The following strategies help consumers migrate to new versions of the API in an efficient and cost-effective manner. API Lifecycle An API Version has its own lifecycle as it starts with planned improvements. As it progresses through its maturity cycle, consumers test it, use it, and eventually migrate away from it. Ultimately the API Version is replaced with an updated API and is retired from service. State Description PLANNED API has been scheduled for development. API release plans have been established. BETA API is operational and is available to selected new subscribers in production for the purposes of testing, validating, and rolling out a new API. LIVE API is operational and is available to new subscribers in production. API version is fully supported. DEPRECATED API is operational and available at runtime to existing subscribers for a fixed period of time. API version is fully supported, including bug fixes addressed in a backwards compatible way. API version is not available to new subscribers. RETIRED API is unpublished from production and no longer available at runtime to any subscribers. The footprint of all deployed applications entering this state must be completely removed from production and stage environments. API Versioning Identification APIs are versioned products and MUST adhere to the following versioning principles. API specifications MUST follow the versioning scheme where the v introduces the version, the major is an ordinal starting with 1 for the first LIVE release, and minor is an ordinal starting with 0 for the first minor release of any major release. Every time there is an incremental change to an API, whether or not backward compatible, the API specification MUST be versioned. This allows the change to be labeled, documented, reviewed, discussed, published and communicated. API endpoints MUST only reflect the major version. API specification versions reflect interface changes and MAY be separate from service implementation versioning schemes. A minor API version MUST maintain backward compatibility with all previous minor versions, within the same major version. A major API version MAY maintain backward compatibility with a previous major version. For a given functionality set, there MUST be only one API version in the LIVE state at any given time across all major and minor versions. This ensures that subscribers always understand which versioned API product they should be using. For example, v1.2 RETIRED, v1.3 DEPRECATED, or v2.0 LIVE. Backwards API Compatibility APIs SHOULD be designed in a forward and extensible way to maintain compatibility and avoid duplication of resources, functionality and excessive versioning. APIs MUST adhere to the following principles to be considered backwards compatible: All changes MUST be additive. All changes MUST be optional. The semantics of an existing parameter, entire representation, or resource MUST NOT be changed. Existing URI attributes such as query parameter keys or path parameters MUST NOT be renamed. There MUST NOT be any change in the behavior of the API for request URIs without the newly added query parameters. Query-parameters and request body parameters MUST be unordered. All additional query parameters on resource URIs MUST be optional. Additional functionality for an existing resource MUST be implemented either: As an optional extension, or As an operation on a new child resource, or By altering a request body, while still accepting all the previous, existing request variations, if an existing operation (e.g. resource creation) cannot be reasonably extended. The API implementation (service) MUST recognize a previously valid value for a request parameter and SHOULD NOT throw an error when used. There MUST NOT be any change in the HTTP status codes returned by the URIs. There MUST NOT be any change in the HTTP verbs (e.g. GET, POST, PUT or PATCH) supported earlier by the URI. The URI MAY however support a new HTTP verb. There MUST NOT be any change in the name and type of the request or response headers of a URI. Additional headers MAY be added, provided they\u2019re optional. Backwards Payload Compatibility Ensure that the previous JSON API schema is extensible. There are simple traps in JSON that make an API contract impossible to evolve without making breaking changes. One common pitfall is returning a raw JSON array from an API endpoint. Without an object wrapper, there\u2019s no ability to later add metadata like paging without breaking the contract. Similarly, when working with international context (or expect to), use objects for monetary amounts in order to support adding currency without breaking the contract. It is also common to use objects for strings (messages) which may need to be internationalized with additional locale-specific translations. An existing property in a JSON object of an API response MUST continue to be returned with the same name and JSON type (number, integer, string, array, object). If the value of a response field is an array, then the type of the contents in the array MUST NOT change. If the value of the response field is an object, then the compatibility policy MUST apply to the JSON object as a whole. New properties added to the request body MUST NOT be mandatory. If the property of an object is a URI, then it MUST have the same stability mentioned as URIs. For an API returning HATEOAS links as part of the representation, the values of rel and href MUST remain the same. For primitive types, unless there is a constraint described in the API documentation (e.g. length of the string, possible values for an ENUM type), clients MUST not assume that the values are constrained in any way. For ENUM types, there MUST NOT be any change in already supported enumerated values or meaning of these values. New properties MAY be added to a representation any time, but it SHOULD NOT alter the meaning of an existing property. New properties that are added MUST NOT be mandatory. Previously mandatory fields MUST be present in the response. Consumer Compatibility Guidelines Being able to make changes to an API in a backward compatible manner requires that API providers add new fields and expect API consumers not to break when they do so. API consumers need to follow these guidelines in order to support backward compatible API providers: Be tolerant with unknown fields in the payload (see Martin Fowler\u2019s \"TolerantReader\" post), that is to say, ignore deserialization of new fields but do not eliminate them from the payload if needed for subsequent PUT requests. Be prepared to handle HTTP status codes not explicitly specified in endpoint definitions. Follow the redirect when the server returns HTTP status code 301 (Moved Permanently) Support redirection in case a URL has to change 301 (Moved Permanently). Plan to Version The following guidelines should be applied when breaking changes require a new version of the APIs: Put the API version in the URL \u2013 While header-based versioning is arguably more RESTful, it\u2019s also less obvious. Keeping the version in the URL allows the API consumer to open it in a browser, send it in email, and bookmark it. It\u2019s also immediately visible in logs. Use only the major version \u2013 API versioning MUST follow a scheme where the v introduces the version, and the major is an ordinal starting with 1 for the first release version. For example; http://api.example.com/v1/users. Minor versions SHOULD NOT be supported because it adds versioning overhead and brings no value to the API consumers. Use a version number \u2013 There are popular APIs who use a different identifier (e.g. Twilio uses a date). This is both less obvious and exposes information that should not matter to the API consumer. Always start with a versioned URL \u2013 It can seem convenient for an API provider to start without a version and only add it in when needed. The down side of this approach is that it\u2019s less obvious, requires out-of-band information to be understood, and provides an inconsistent experience to API consumers. In the unlikely event that the API provider starts with an unversioned URL and later needs to version, they SHOULD treat the unversioned URL as an alias for v1, so that both URLs route to the same implementation. Manage multiple concurrent versions as separate instances \u2013 Multiple concurrent versions SHOULD be managed as separately running instances of a service with a router in front, rather than multiple versions managed concurrently in the same codebase. This approach avoids any accidental breaking changes of older versions while refactoring code. When releasing a new version of the API, take this opportunity to re-evaluate the optionality of parameters and properties which have been added. If there will be breaking changes, this is an opportunity to rationalize optional properties. Removing legacy options, making the API clear, consistent and easy to use will benefit users while also simplifying code and removing accumulated tech debt. End of Life Policy The End-of-Life (EOL) policy regulates how API versions move from the LIVE to the RETIRED state. It is designed to ensure a consistent and reasonable transition period for API customers who need to migrate from the old to the new API version while enabling a healthy process to retire technical debt. Minor API Version EOL Per versioning policy, minor API versions MUST be backwards compatible with preceding minor versions within the same major version. Thus, minor API versions are RETIRED immediately after a newer minor version of the same major version becomes LIVE. This change should have no impact on existing subscribers so there is no need to transition through a DEPRECATED state to facilitate client migration. Major API Version EOL Per versioning policy, major API versions MAY be backwards compatible with preceding major versions. As such, the following rules apply when retiring a major API version. A major API version MUST NOT be in the DEPRECATED state until a replacement service is LIVE that provides a clear customer migration path for all functionality that will be retained moving forward. This SHOULD include documentation and, as appropriate, migration tools and sample code that provide customers what they need to make a clean migration. The deprecated API version MUST be in the DEPRECATED state for a minimum period of time to give client customers adequate notice to migrate. Deprecation of API versions with external clients SHOULD be considered on a case-by-case basis and may require additional deprecation time and/or constraints to minimize impact on customer base. If a versioned API in LIVE or DEPRECATED state has no clients, it MAY move to the RETIRED state immediately. End of Life Policy: Replacement Major API Version Introduction Since a new major API version that results in deprecation of a pre-existing API version is a significant business investment decision, API owners MUST justify the new major version before beginning significant design and development work. API owners SHOULD explore all possible alternatives to introducing a new major API version with the objective of minimizing the impact on customers before deciding to introduce a new version. Justification SHOULD include the following: Business Case Customer value delivered by a new version that is not possible with the existing version. Cost-benefit analysis of deprecated version versus the new version. Explanation of alternatives to introducing a new major version and why those were not chosen. If a backwards incompatible change is required to address a critical security issue, items 1 and 2 (above) are not required. API Design A domain model of all resources in the new API version and how they compare to the domain model of the previous major API version. Description of APIs operations and use cases they implement. Definition of service level objectives for performance and availability that are equal or better to the major API version to be deprecated. Migration Strategy Number of existing customers impacted; internal, external, and partners. Communication and support plan to inform existing customers of new version, value, and migration path. Background When defining your API, you must make a lot of material decisions that have long lasting implications. The objective is to make a long-lived, durable, and reusable API. You are trying to get it \u201cright\u201d. Practically speaking, however, you are not going to succeed every time. In fact, evidence suggests you will be wrong more often then you are right. New requirements come in. Your understanding of the problem changes. What probably looked like a good decision at the time, may now limit your ability to elegantly extend your API to satisfy your new understanding. Lightweight decisions made in the past now seem somewhat heavy as the implications come into focus. Maintaining backward compatibility is a persistent challenge. One option is to create a new major version of your API. This allows you to leave past decisions behind and start fresh. Unfortunately, it also means that all of your clients now need to migrate to new endpoints for any of the new work to deliver customer value. This is hard. Many clients will not move without good incentives. There is a lot of overhead in managing the customer migration. You also need to support two sets of interfaces for quite some time. The other consideration is that your API product may have multiple endpoints, but the breaking changes that you want to make only affect one. Making your customers migrate their applications for all the API endpoints just so you can \u201cfix\u201d one small part is a pretty heavyweight and expensive change. While pure and simple from a philosophical and engineering point of view, it is often unjustifiable from an ROI standpoint. The goal of this guideline is to find a middle ground that provides a more practical path forward when minor changes are needed, but which is still consistent, in spirit, with the API Versioning Policy. Deprecation Process As the API evolves, a need may arise to deprecate an API version, an API endpoint or a field in the API. The goal of deprecation is to progress to a state in which there are no consumers using the version, endpoint or field to be deprecated. Once this state is reached, the API version can be retired and removed from production. The following requirements should be applied when deprecating an API; An API developer SHOULD be able to deprecate an API Element in a minor version of an API. An API specification MUST highlight one or more deprecated elements of the API so the API consumers are aware. An API provider MUST inform API consumers regarding deprecated elements present in request and/or response at runtime so that tools can recognize this, log warnings and highlight the usage of deprecated elements as needed. Deprecated API Elements MUST remain supported for the life of the major version. The requirements listed above can be addressed by documenting deprecated elements via the API specification. Listed below are a couple of examples that illustrate deprecation of elements when using OpenAPI Specification 3.1 Deprecation Documentation The most important part of deprecation is providing documentation for the user to understand what/when parts of the API will be deprecated. The API Documentation must include not only what is being deprecated, but when. The timeline should be selected to be sufficient to allow consumers to migrate their systems onto the new API. Deprecating an HTTP Method Deprecating an endpoint involves adding \u201cdeprecated: true\u201d attribute to the endpoint method as shown below: openapi: 3.1 ... paths: /appeals: get: description: Deprecated endpoint to retrieve appeals deprecated: true Deprecating a query parameter openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status parameters: - name: fromDate in: query description: Deprecated Start date of appeal deprecated: true Deprecating a header openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status parameters: - name: ORG-Authorization-Token in: header description: Deprecated ORG-Authorization-Token Header deprecated: true Deprecating a property in a resource openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status responses: 200: description: Successful Appeal content: application/json: schema: \\$ref: \"#/components/schemas/Appeal\" components: schemas: Appeal: description: Appeal status schema properties: appealType: type: string description: The decision review option chosen by the appellant deprecated: true Adding a Deprecation header During the deprecation phase, the API provider should add a Deprecation HTTP response header. See draft: RFC Deprecation HTTP Header ). A Sunset HTTP response header can be added (see RFC 8594 ) on a resource that will be deprecated. The deprecation header can either be set to true if a feature is retired, or carry a deprecation timestamp, at which point a replacement will become available and consumers must not on-board any longer. NOTE: Applications consuming this header MUST not take any action based on the value of the header at this time. Instead, we recommend that these applications SHOULD take action based only on the existence of the header in the response.","title":"Versioning Policy"},{"location":"unified/versioning/#api-versioning","text":"This section describes how to version APIs. It describes API\u2019s lifecycle states, enumerates versioning policy, describes backwards compatibility related guidelines and describes an End-Of-Life policy.","title":"API Versioning"},{"location":"unified/versioning/#api-versioning-strategy","text":"APIs should be designed so that they are extensible and backward compatible. An API is backward compatible if a new change to the API does not break existing API consumers. This minimizes the work required for consumers to utilize new releases of the API services. However, there are cases where API providers need to introduce breaking changes. In such cases, API versioning provides the flexibility to roll out a new version of the API containing breaking changes. The following strategies help consumers migrate to new versions of the API in an efficient and cost-effective manner.","title":"API Versioning Strategy"},{"location":"unified/versioning/#api-lifecycle","text":"An API Version has its own lifecycle as it starts with planned improvements. As it progresses through its maturity cycle, consumers test it, use it, and eventually migrate away from it. Ultimately the API Version is replaced with an updated API and is retired from service. State Description PLANNED API has been scheduled for development. API release plans have been established. BETA API is operational and is available to selected new subscribers in production for the purposes of testing, validating, and rolling out a new API. LIVE API is operational and is available to new subscribers in production. API version is fully supported. DEPRECATED API is operational and available at runtime to existing subscribers for a fixed period of time. API version is fully supported, including bug fixes addressed in a backwards compatible way. API version is not available to new subscribers. RETIRED API is unpublished from production and no longer available at runtime to any subscribers. The footprint of all deployed applications entering this state must be completely removed from production and stage environments.","title":"API Lifecycle"},{"location":"unified/versioning/#api-versioning-identification","text":"APIs are versioned products and MUST adhere to the following versioning principles. API specifications MUST follow the versioning scheme where the v introduces the version, the major is an ordinal starting with 1 for the first LIVE release, and minor is an ordinal starting with 0 for the first minor release of any major release. Every time there is an incremental change to an API, whether or not backward compatible, the API specification MUST be versioned. This allows the change to be labeled, documented, reviewed, discussed, published and communicated. API endpoints MUST only reflect the major version. API specification versions reflect interface changes and MAY be separate from service implementation versioning schemes. A minor API version MUST maintain backward compatibility with all previous minor versions, within the same major version. A major API version MAY maintain backward compatibility with a previous major version. For a given functionality set, there MUST be only one API version in the LIVE state at any given time across all major and minor versions. This ensures that subscribers always understand which versioned API product they should be using. For example, v1.2 RETIRED, v1.3 DEPRECATED, or v2.0 LIVE.","title":"API Versioning Identification"},{"location":"unified/versioning/#backwards-api-compatibility","text":"APIs SHOULD be designed in a forward and extensible way to maintain compatibility and avoid duplication of resources, functionality and excessive versioning. APIs MUST adhere to the following principles to be considered backwards compatible: All changes MUST be additive. All changes MUST be optional. The semantics of an existing parameter, entire representation, or resource MUST NOT be changed. Existing URI attributes such as query parameter keys or path parameters MUST NOT be renamed. There MUST NOT be any change in the behavior of the API for request URIs without the newly added query parameters. Query-parameters and request body parameters MUST be unordered. All additional query parameters on resource URIs MUST be optional. Additional functionality for an existing resource MUST be implemented either: As an optional extension, or As an operation on a new child resource, or By altering a request body, while still accepting all the previous, existing request variations, if an existing operation (e.g. resource creation) cannot be reasonably extended. The API implementation (service) MUST recognize a previously valid value for a request parameter and SHOULD NOT throw an error when used. There MUST NOT be any change in the HTTP status codes returned by the URIs. There MUST NOT be any change in the HTTP verbs (e.g. GET, POST, PUT or PATCH) supported earlier by the URI. The URI MAY however support a new HTTP verb. There MUST NOT be any change in the name and type of the request or response headers of a URI. Additional headers MAY be added, provided they\u2019re optional.","title":"Backwards API Compatibility"},{"location":"unified/versioning/#backwards-payload-compatibility","text":"Ensure that the previous JSON API schema is extensible. There are simple traps in JSON that make an API contract impossible to evolve without making breaking changes. One common pitfall is returning a raw JSON array from an API endpoint. Without an object wrapper, there\u2019s no ability to later add metadata like paging without breaking the contract. Similarly, when working with international context (or expect to), use objects for monetary amounts in order to support adding currency without breaking the contract. It is also common to use objects for strings (messages) which may need to be internationalized with additional locale-specific translations. An existing property in a JSON object of an API response MUST continue to be returned with the same name and JSON type (number, integer, string, array, object). If the value of a response field is an array, then the type of the contents in the array MUST NOT change. If the value of the response field is an object, then the compatibility policy MUST apply to the JSON object as a whole. New properties added to the request body MUST NOT be mandatory. If the property of an object is a URI, then it MUST have the same stability mentioned as URIs. For an API returning HATEOAS links as part of the representation, the values of rel and href MUST remain the same. For primitive types, unless there is a constraint described in the API documentation (e.g. length of the string, possible values for an ENUM type), clients MUST not assume that the values are constrained in any way. For ENUM types, there MUST NOT be any change in already supported enumerated values or meaning of these values. New properties MAY be added to a representation any time, but it SHOULD NOT alter the meaning of an existing property. New properties that are added MUST NOT be mandatory. Previously mandatory fields MUST be present in the response.","title":"Backwards Payload Compatibility"},{"location":"unified/versioning/#consumer-compatibility-guidelines","text":"Being able to make changes to an API in a backward compatible manner requires that API providers add new fields and expect API consumers not to break when they do so. API consumers need to follow these guidelines in order to support backward compatible API providers: Be tolerant with unknown fields in the payload (see Martin Fowler\u2019s \"TolerantReader\" post), that is to say, ignore deserialization of new fields but do not eliminate them from the payload if needed for subsequent PUT requests. Be prepared to handle HTTP status codes not explicitly specified in endpoint definitions. Follow the redirect when the server returns HTTP status code 301 (Moved Permanently) Support redirection in case a URL has to change 301 (Moved Permanently).","title":"Consumer Compatibility Guidelines"},{"location":"unified/versioning/#plan-to-version","text":"The following guidelines should be applied when breaking changes require a new version of the APIs: Put the API version in the URL \u2013 While header-based versioning is arguably more RESTful, it\u2019s also less obvious. Keeping the version in the URL allows the API consumer to open it in a browser, send it in email, and bookmark it. It\u2019s also immediately visible in logs. Use only the major version \u2013 API versioning MUST follow a scheme where the v introduces the version, and the major is an ordinal starting with 1 for the first release version. For example; http://api.example.com/v1/users. Minor versions SHOULD NOT be supported because it adds versioning overhead and brings no value to the API consumers. Use a version number \u2013 There are popular APIs who use a different identifier (e.g. Twilio uses a date). This is both less obvious and exposes information that should not matter to the API consumer. Always start with a versioned URL \u2013 It can seem convenient for an API provider to start without a version and only add it in when needed. The down side of this approach is that it\u2019s less obvious, requires out-of-band information to be understood, and provides an inconsistent experience to API consumers. In the unlikely event that the API provider starts with an unversioned URL and later needs to version, they SHOULD treat the unversioned URL as an alias for v1, so that both URLs route to the same implementation. Manage multiple concurrent versions as separate instances \u2013 Multiple concurrent versions SHOULD be managed as separately running instances of a service with a router in front, rather than multiple versions managed concurrently in the same codebase. This approach avoids any accidental breaking changes of older versions while refactoring code. When releasing a new version of the API, take this opportunity to re-evaluate the optionality of parameters and properties which have been added. If there will be breaking changes, this is an opportunity to rationalize optional properties. Removing legacy options, making the API clear, consistent and easy to use will benefit users while also simplifying code and removing accumulated tech debt.","title":"Plan to Version"},{"location":"unified/versioning/#end-of-life-policy","text":"The End-of-Life (EOL) policy regulates how API versions move from the LIVE to the RETIRED state. It is designed to ensure a consistent and reasonable transition period for API customers who need to migrate from the old to the new API version while enabling a healthy process to retire technical debt.","title":"End of Life Policy"},{"location":"unified/versioning/#minor-api-version-eol","text":"Per versioning policy, minor API versions MUST be backwards compatible with preceding minor versions within the same major version. Thus, minor API versions are RETIRED immediately after a newer minor version of the same major version becomes LIVE. This change should have no impact on existing subscribers so there is no need to transition through a DEPRECATED state to facilitate client migration.","title":"Minor API Version EOL"},{"location":"unified/versioning/#major-api-version-eol","text":"Per versioning policy, major API versions MAY be backwards compatible with preceding major versions. As such, the following rules apply when retiring a major API version. A major API version MUST NOT be in the DEPRECATED state until a replacement service is LIVE that provides a clear customer migration path for all functionality that will be retained moving forward. This SHOULD include documentation and, as appropriate, migration tools and sample code that provide customers what they need to make a clean migration. The deprecated API version MUST be in the DEPRECATED state for a minimum period of time to give client customers adequate notice to migrate. Deprecation of API versions with external clients SHOULD be considered on a case-by-case basis and may require additional deprecation time and/or constraints to minimize impact on customer base. If a versioned API in LIVE or DEPRECATED state has no clients, it MAY move to the RETIRED state immediately.","title":"Major API Version EOL"},{"location":"unified/versioning/#end-of-life-policy-replacement-major-api-version-introduction","text":"Since a new major API version that results in deprecation of a pre-existing API version is a significant business investment decision, API owners MUST justify the new major version before beginning significant design and development work. API owners SHOULD explore all possible alternatives to introducing a new major API version with the objective of minimizing the impact on customers before deciding to introduce a new version. Justification SHOULD include the following:","title":"End of Life Policy: Replacement Major API Version Introduction"},{"location":"unified/versioning/#business-case","text":"Customer value delivered by a new version that is not possible with the existing version. Cost-benefit analysis of deprecated version versus the new version. Explanation of alternatives to introducing a new major version and why those were not chosen. If a backwards incompatible change is required to address a critical security issue, items 1 and 2 (above) are not required.","title":"Business Case"},{"location":"unified/versioning/#api-design","text":"A domain model of all resources in the new API version and how they compare to the domain model of the previous major API version. Description of APIs operations and use cases they implement. Definition of service level objectives for performance and availability that are equal or better to the major API version to be deprecated.","title":"API Design"},{"location":"unified/versioning/#migration-strategy","text":"Number of existing customers impacted; internal, external, and partners. Communication and support plan to inform existing customers of new version, value, and migration path.","title":"Migration Strategy"},{"location":"unified/versioning/#background","text":"When defining your API, you must make a lot of material decisions that have long lasting implications. The objective is to make a long-lived, durable, and reusable API. You are trying to get it \u201cright\u201d. Practically speaking, however, you are not going to succeed every time. In fact, evidence suggests you will be wrong more often then you are right. New requirements come in. Your understanding of the problem changes. What probably looked like a good decision at the time, may now limit your ability to elegantly extend your API to satisfy your new understanding. Lightweight decisions made in the past now seem somewhat heavy as the implications come into focus. Maintaining backward compatibility is a persistent challenge. One option is to create a new major version of your API. This allows you to leave past decisions behind and start fresh. Unfortunately, it also means that all of your clients now need to migrate to new endpoints for any of the new work to deliver customer value. This is hard. Many clients will not move without good incentives. There is a lot of overhead in managing the customer migration. You also need to support two sets of interfaces for quite some time. The other consideration is that your API product may have multiple endpoints, but the breaking changes that you want to make only affect one. Making your customers migrate their applications for all the API endpoints just so you can \u201cfix\u201d one small part is a pretty heavyweight and expensive change. While pure and simple from a philosophical and engineering point of view, it is often unjustifiable from an ROI standpoint. The goal of this guideline is to find a middle ground that provides a more practical path forward when minor changes are needed, but which is still consistent, in spirit, with the API Versioning Policy.","title":"Background"},{"location":"unified/versioning/#deprecation-process","text":"As the API evolves, a need may arise to deprecate an API version, an API endpoint or a field in the API. The goal of deprecation is to progress to a state in which there are no consumers using the version, endpoint or field to be deprecated. Once this state is reached, the API version can be retired and removed from production. The following requirements should be applied when deprecating an API; An API developer SHOULD be able to deprecate an API Element in a minor version of an API. An API specification MUST highlight one or more deprecated elements of the API so the API consumers are aware. An API provider MUST inform API consumers regarding deprecated elements present in request and/or response at runtime so that tools can recognize this, log warnings and highlight the usage of deprecated elements as needed. Deprecated API Elements MUST remain supported for the life of the major version. The requirements listed above can be addressed by documenting deprecated elements via the API specification. Listed below are a couple of examples that illustrate deprecation of elements when using OpenAPI Specification 3.1","title":"Deprecation Process"},{"location":"unified/versioning/#deprecation-documentation","text":"The most important part of deprecation is providing documentation for the user to understand what/when parts of the API will be deprecated. The API Documentation must include not only what is being deprecated, but when. The timeline should be selected to be sufficient to allow consumers to migrate their systems onto the new API.","title":"Deprecation Documentation"},{"location":"unified/versioning/#deprecating-an-http-method","text":"Deprecating an endpoint involves adding \u201cdeprecated: true\u201d attribute to the endpoint method as shown below: openapi: 3.1 ... paths: /appeals: get: description: Deprecated endpoint to retrieve appeals deprecated: true","title":"Deprecating an HTTP Method"},{"location":"unified/versioning/#deprecating-a-query-parameter","text":"openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status parameters: - name: fromDate in: query description: Deprecated Start date of appeal deprecated: true","title":"Deprecating a query parameter"},{"location":"unified/versioning/#deprecating-a-header","text":"openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status parameters: - name: ORG-Authorization-Token in: header description: Deprecated ORG-Authorization-Token Header deprecated: true","title":"Deprecating a header"},{"location":"unified/versioning/#deprecating-a-property-in-a-resource","text":"openapi: 3.1 ... paths: /appeals: get: description: Retrieve appeals status responses: 200: description: Successful Appeal content: application/json: schema: \\$ref: \"#/components/schemas/Appeal\" components: schemas: Appeal: description: Appeal status schema properties: appealType: type: string description: The decision review option chosen by the appellant deprecated: true","title":"Deprecating a property in a resource"},{"location":"unified/versioning/#adding-a-deprecation-header","text":"During the deprecation phase, the API provider should add a Deprecation HTTP response header. See draft: RFC Deprecation HTTP Header ). A Sunset HTTP response header can be added (see RFC 8594 ) on a resource that will be deprecated. The deprecation header can either be set to true if a feature is retired, or carry a deprecation timestamp, at which point a replacement will become available and consumers must not on-board any longer. NOTE: Applications consuming this header MUST not take any action based on the value of the header at this time. Instead, we recommend that these applications SHOULD take action based only on the existence of the header in the response.","title":"Adding a Deprecation header"}]}